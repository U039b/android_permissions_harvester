{
  "groups": {
    "android.permission-group.CONTACTS": {
      "name": "android.permission-group.CONTACTS",
      "request_ptr": "permgrouprequest_contacts",
      "description": "acc\u00e9der \u00e0 vos contacts",
      "description_ptr": "permgroupdesc_contacts",
      "label": "Contacts",
      "label_ptr": "permgrouplab_contacts",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4,1h16v2h-16z\" fill=\"#000000\"/><path d=\"M4,21h16v2h-16z\" fill=\"#000000\"/><path d=\"M20,5H4C2.9,5 2,5.9 2,7v10c0,1.1 0.9,2 2,2h2h12h2c1.1,0 2,-0.9 2,-2V7C22,5.9 21.1,5 20,5zM8.21,17c0.7,-0.47 2.46,-1 3.79,-1s3.09,0.53 3.79,1H8.21zM20,17h-2c0,-1.99 -4,-3 -6,-3s-6,1.01 -6,3H4V7h16V17z\" fill=\"#000000\"/><path d=\"M12,13.5c1.66,0 3,-1.34 3,-3c0,-1.66 -1.34,-3 -3,-3s-3,1.34 -3,3C9,12.16 10.34,13.5 12,13.5zM12,9.5c0.55,0 1,0.45 1,1s-0.45,1 -1,1s-1,-0.45 -1,-1S11.45,9.5 12,9.5z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_contacts"
    },
    "android.permission-group.CALENDAR": {
      "name": "android.permission-group.CALENDAR",
      "request_ptr": "permgrouprequest_calendar",
      "description": "acc\u00e9der \u00e0 votre agenda",
      "description_ptr": "permgroupdesc_calendar",
      "label": "Agenda",
      "label_ptr": "permgrouplab_calendar",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99 .9 -1.99 2L3 19c0 1.1 .89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_calendar"
    },
    "android.permission-group.SMS": {
      "name": "android.permission-group.SMS",
      "request_ptr": "permgrouprequest_sms",
      "description": "envoyer et consulter des SMS",
      "description_ptr": "permgroupdesc_sms",
      "label": "SMS",
      "label_ptr": "permgrouplab_sms",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20,2H4C2.9,2 2,2.9 2,4v18l4.75,-4h14C21.1,18 22,17.1 22,16V4C22,2.9 21.1,2 20,2zM20,16H4V4h16V16zM9,11H7V9h2V11zM17,11h-2V9h2V11zM13,11h-2V9h2V11z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_sms"
    },
    "android.permission-group.STORAGE": {
      "name": "android.permission-group.STORAGE",
      "request_ptr": "permgrouprequest_storage",
      "description": "acc\u00e9der \u00e0 des photos, \u00e0 des contenus multim\u00e9dias et \u00e0 des fichiers sur votre appareil",
      "description_ptr": "permgroupdesc_storage",
      "label": "Stockage",
      "label_ptr": "permgrouplab_storage",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20,6h-8l-2,-2H4C2.9,4 2.01,4.9 2.01,6L2,18c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V8C22,6.9 21.1,6 20,6zM20,18H4V8h16V18z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_storage"
    },
    "android.permission-group.LOCATION": {
      "name": "android.permission-group.LOCATION",
      "request_ptr": "permgrouprequest_location",
      "description": "acc\u00e9der \u00e0 la position de l'appareil",
      "description_ptr": "permgroupdesc_location",
      "label": "Localisation",
      "label_ptr": "permgrouplab_location",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13C19,5.13 15.87,2 12,2zM7,9c0,-2.76 2.24,-5 5,-5s5,2.24 5,5c0,2.88 -2.88,7.19 -5,9.88C9.92,16.21 7,11.85 7,9z\" fill=\"#000000\"/><path d=\"M12,9m-2.5,0a2.5,2.5 0,1 1,5 0a2.5,2.5 0,1 1,-5 0\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_location"
    },
    "android.permission-group.CALL_LOG": {
      "name": "android.permission-group.CALL_LOG",
      "request_ptr": "permgrouprequest_calllog",
      "description": "",
      "description_ptr": "permgroupdesc_calllog",
      "label": "",
      "label_ptr": "permgrouplab_calllog",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24.0\" viewBox=\"0 0 24.0 24.0\" width=\"24.0\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.01,14.48l-2.62,2.62c-2.75,-1.49 -5.01,-3.75 -6.5,-6.5l2.62,-2.62c0.24,-0.24 0.34,-0.58 0.27,-0.9L9.13,3.82c-0.09,-0.47 -0.5,-0.8 -0.98,-0.8L4,3.01c-0.56,0 -1.03,0.47 -1,1.03c0.17,2.91 1.04,5.63 2.43,8.01c1.57,2.69 3.81,4.93 6.5,6.5c2.38,1.39 5.1,2.26 8.01,2.43c0.56,0.03 1.03,-0.44 1.03,-1v-4.15c0,-0.48 -0.34,-0.89 -0.8,-0.98l-3.26,-0.65C16.58,14.14 16.24,14.24 16.01,14.48z\" fill=\"#000000\"/><path d=\"M12,8h10V6H12V8zM12,4h10V2H12V4zM22,10H12v2h10V10z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_call_log"
    },
    "android.permission-group.PHONE": {
      "name": "android.permission-group.PHONE",
      "request_ptr": "permgrouprequest_phone",
      "description": "effectuer et g\u00e9rer des appels t\u00e9l\u00e9phoniques",
      "description_ptr": "permgroupdesc_phone",
      "label": "T\u00e9l\u00e9phone",
      "label_ptr": "permgrouplab_phone",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27 .67 -.36 1.02-.24 1.12 .37 2.33 .57 3.57 .57 .55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55 .45 -1 1-1h3.5c.55 0 1 .45 1 1 0 1.25 .2 2.45 .57 3.57 .11 .35 .03 .74-.25 1.02l-2.2 2.2z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_phone_calls"
    },
    "android.permission-group.MICROPHONE": {
      "name": "android.permission-group.MICROPHONE",
      "request_ptr": "permgrouprequest_microphone",
      "description": "enregistrer des fichiers audio",
      "description_ptr": "permgroupdesc_microphone",
      "label": "Microphone",
      "label_ptr": "permgrouplab_microphone",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12,14c1.66,0 3,-1.34 3,-3V5c0,-1.66 -1.34,-3 -3,-3S9,3.34 9,5v6C9,12.66 10.34,14 12,14zM11,5c0,-0.55 0.45,-1 1,-1s1,0.45 1,1v6c0,0.55 -0.45,1 -1,1s-1,-0.45 -1,-1V5z\" fill=\"#000000\"/><path d=\"M17,11c0,2.76 -2.24,5 -5,5s-5,-2.24 -5,-5H5c0,3.53 2.61,6.43 6,6.92V21h2v-3.08c3.39,-0.49 6,-3.39 6,-6.92H17z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_microphone"
    },
    "android.permission-group.CAMERA": {
      "name": "android.permission-group.CAMERA",
      "request_ptr": "permgrouprequest_camera",
      "description": "prendre des photos et enregistrer des vid\u00e9os",
      "description_ptr": "permgroupdesc_camera",
      "label": "Appareil photo",
      "label_ptr": "permgrouplab_camera",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20,5h-3.17L15,3H9L7.17,5H4C2.9,5 2,5.9 2,7v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V7C22,5.9 21.1,5 20,5zM20,19H4V7h16V19z\" fill=\"#000000\"/><path d=\"M12,9c-2.21,0 -4,1.79 -4,4c0,2.21 1.79,4 4,4s4,-1.79 4,-4C16,10.79 14.21,9 12,9z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_camera"
    },
    "android.permission-group.SENSORS": {
      "name": "android.permission-group.SENSORS",
      "request_ptr": "permgrouprequest_sensors",
      "description": "acc\u00e9der aux donn\u00e9es des capteurs relatives \u00e0 vos signes vitaux",
      "description_ptr": "permgroupdesc_sensors",
      "label": "Capteurs corporels",
      "label_ptr": "permgrouplab_sensors",
      "icon": "<?xml version=\"1.0\" ?><svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.49 5.48c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-3.6 13.9l1-4.4 2.1 2v6h2v-7.5l-2.1-2 .6-3c1.3 1.5 3.3 2.5 5.5 2.5v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5 .1 -.8 .1 l-5.2 2.2v4.7h2v-3.4l1.8-.7-1.6 8.1-4.9-1-.4 2 7 1.4z\" fill=\"#000000\"/></svg>",
      "icon_ptr": "perm_group_sensors"
    }
  },
  "permissions": {
    "android.permission.READ_CONTACTS": {
      "name": "android.permission.READ_CONTACTS",
      "label": "Voir les contacts",
      "label_ptr": "permlab_readContacts",
      "description": "Permet \u00e0 l'application de lire les donn\u00e9es relatives aux contacts stock\u00e9s sur votre t\u00e9l\u00e9phone, y compris la fr\u00e9quence \u00e0 laquelle vous avez appel\u00e9 des personnes sp\u00e9cifiques, leur avez envoy\u00e9 des e-mails ou avez communiqu\u00e9 avec elles par d'autres moyens. Cette autorisation permet aux applications d'enregistrer ces donn\u00e9es. Les applications malveillantes peuvent les partager \u00e0 votre insu.",
      "description_ptr": "permdesc_readContacts",
      "permission_group": "android.permission-group.CONTACTS",
      "protection_level": "dangerous"
    },
    "android.permission.WRITE_CONTACTS": {
      "name": "android.permission.WRITE_CONTACTS",
      "label": "modifier les contacts",
      "label_ptr": "permlab_writeContacts",
      "description": "Permet \u00e0 l'application de modifier les donn\u00e9es relatives aux contacts stock\u00e9s sur votre t\u00e9l\u00e9phone, y compris la fr\u00e9quence \u00e0 laquelle vous avez appel\u00e9 des personnes sp\u00e9cifiques, leur avez envoy\u00e9 des e-mails ou avez communiqu\u00e9 avec elles par d'autres moyens. Cette autorisation permet aux applications de supprimer ces donn\u00e9es.",
      "description_ptr": "permdesc_writeContacts",
      "permission_group": "android.permission-group.CONTACTS",
      "protection_level": "dangerous"
    },
    "android.permission.READ_CALENDAR": {
      "name": "android.permission.READ_CALENDAR",
      "label": "Lire les \u00e9v\u00e9nements d'agenda et les d\u00e9tails associ\u00e9s",
      "label_ptr": "permlab_readCalendar",
      "description": "Cette application peut lire tous les \u00e9v\u00e9nements d'agenda enregistr\u00e9s sur votre t\u00e9l\u00e9phone et partager ou enregistrer vos donn\u00e9es d'agenda.",
      "description_ptr": "permdesc_readCalendar",
      "permission_group": "android.permission-group.CALENDAR",
      "protection_level": "dangerous"
    },
    "android.permission.WRITE_CALENDAR": {
      "name": "android.permission.WRITE_CALENDAR",
      "label": "ajouter ou modifier des \u00e9v\u00e9nements d'agenda et envoyer des e-mails aux invit\u00e9s \u00e0 l'insu des propri\u00e9taires",
      "label_ptr": "permlab_writeCalendar",
      "description": "Cette application peut ajouter, supprimer ou modifier les \u00e9v\u00e9nements d'agenda enregistr\u00e9s sur votre t\u00e9l\u00e9phone. Elle peut en outre envoyer des messages qui semblent provenir du propri\u00e9taire de l'agenda, ou modifier des \u00e9v\u00e9nements sans en informer leur propri\u00e9taire.",
      "description_ptr": "permdesc_writeCalendar",
      "permission_group": "android.permission-group.CALENDAR",
      "protection_level": "dangerous"
    },
    "android.permission.SEND_SMS": {
      "name": "android.permission.SEND_SMS",
      "label": "envoyer et consulter des SMS",
      "label_ptr": "permlab_sendSms",
      "description": "Permet \u00e0 l'application d'envoyer des messages SMS. Cette autorisation peut entra\u00eener des frais inattendus. Les applications malveillantes peuvent g\u00e9n\u00e9rer des frais en envoyant des messages sans votre consentement.",
      "description_ptr": "permdesc_sendSms",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous",
      "methods": [
        {
          "method_name": "android.telephony.TelephonyManager.sendVisualVoicemailSmsForSubscriber",
          "documentation": "Send a visual voicemail SMS. The IPC caller must be the current default\ndialer. @param phoneAccountHandle The account to send the SMS with. @param\nnumber The destination number. @param port The destination port for data SMS,\nor 0 for text SMS. @param text The message content. For data sms, it will be\nencoded as a UTF-8 byte stream. @param sentIntent The sent intent passed to\nthe {@link SmsManager} @see SmsManager#sendDataMessage(String, String, short,\nbyte[], PendingIntent, PendingIntent) @see SmsManager#sendTextMessage(String,\nString, String, PendingIntent, PendingIntent) @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4226
        }
      ]
    },
    "android.permission.RECEIVE_SMS": {
      "name": "android.permission.RECEIVE_SMS",
      "label": "recevoir des messages texte (SMS)",
      "label_ptr": "permlab_receiveSms",
      "description": "Permet \u00e0 l'application de recevoir et de traiter les SMS. Cette autorisation lui donne la possibilit\u00e9 de surveiller ou supprimer les messages envoy\u00e9s \u00e0 votre appareil sans vous les montrer.",
      "description_ptr": "permdesc_receiveSms",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous"
    },
    "android.permission.READ_SMS": {
      "name": "android.permission.READ_SMS",
      "label": "voir les messages texte (SMS ou MMS)",
      "label_ptr": "permlab_readSms",
      "description": "Cette application peut lire tous les SMS enregistr\u00e9s sur votre t\u00e9l\u00e9phone.",
      "description_ptr": "permdesc_readSms",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous",
      "methods": [
        {
          "method_name": "android.telephony.TelephonyManager.getLine1Number",
          "documentation": "Returns the phone number string for line 1, for example, the MSISDN for a GSM\nphone for a particular subscription. Return null if it is unavailable.\n\nThe default SMS app can also use this. @param subId whose phone number for\nline 1 is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3707
        }
      ]
    },
    "android.permission.RECEIVE_WAP_PUSH": {
      "name": "android.permission.RECEIVE_WAP_PUSH",
      "label": "recevoir des messages texte (WAP)",
      "label_ptr": "permlab_receiveWapPush",
      "description": "Permet \u00e0 l'application de recevoir et de traiter les messages WAP. Cette autorisation lui donne la possibilit\u00e9 de surveiller ou supprimer les messages envoy\u00e9s \u00e0 votre appareil sans vous les montrer.",
      "description_ptr": "permdesc_receiveWapPush",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous"
    },
    "android.permission.RECEIVE_MMS": {
      "name": "android.permission.RECEIVE_MMS",
      "label": "recevoir des messages texte (MMS)",
      "label_ptr": "permlab_receiveMms",
      "description": "Permet \u00e0 l'application de recevoir et de traiter les MMS. Cette autorisation lui donne la possibilit\u00e9 de surveiller ou supprimer les messages envoy\u00e9s \u00e0 votre appareil sans vous les montrer.",
      "description_ptr": "permdesc_receiveMms",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous"
    },
    "android.permission.READ_CELL_BROADCASTS": {
      "name": "android.permission.READ_CELL_BROADCASTS",
      "label": "lire les messages re\u00e7us via un canal de diffusion cellulaire",
      "label_ptr": "permlab_readCellBroadcasts",
      "description": "Permet \u00e0 l'application de lire les messages que votre appareil re\u00e7oit via un canal de diffusion cellulaire. Dans certaines zones g\u00e9ographiques, des alertes vous sont envoy\u00e9es afin de vous pr\u00e9venir en cas de situation d'urgence. Les applications malveillantes peuvent venir perturber les performances ou le fonctionnement de votre appareil lorsqu'un message est re\u00e7u via un canal de diffusion cellulaire.",
      "description_ptr": "permdesc_readCellBroadcasts",
      "permission_group": "android.permission-group.SMS",
      "protection_level": "dangerous"
    },
    "android.permission.READ_EXTERNAL_STORAGE": {
      "name": "android.permission.READ_EXTERNAL_STORAGE",
      "label": "voir le contenu de la carte\u00a0SD",
      "label_ptr": "permlab_sdcardRead",
      "description": "Permettre \u00e0 l'application de lire le contenu de la carte\u00a0SD",
      "description_ptr": "permdesc_sdcardRead",
      "permission_group": "android.permission-group.STORAGE",
      "protection_level": "dangerous",
      "methods": [
        {
          "method_name": "android.app.WallpaperManager.getFastDrawable",
          "documentation": "Like {@link #getDrawable()}, but the returned Drawable has a number of\nlimitations to reduce its overhead as much as possible. It will never scale\nthe wallpaper (only centering it if the requested bounds do match the bitmap\nbounds, which should not be typical), doesn't allow setting an alpha, color\nfilter, or other attributes, etc. The bounds of the returned drawable will be\ninitialized to the same bounds as the wallpaper, so normally you will not need\nto touch it. The drawable also assumes that it will be used in a context\nrunning in the same density as the screen (not in density compatibility mode).\n@return Returns a Drawable object that will draw the wallpaper.\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 797
        },
        {
          "method_name": "android.app.WallpaperManager.peekFastDrawable",
          "documentation": "Like {@link #getFastDrawable()}, but if there is no wallpaper set, a null\npointer is returned. @return Returns an optimized Drawable object that will\ndraw the wallpaper or a null pointer if these is none.\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 813
        }
      ]
    },
    "android.permission.WRITE_EXTERNAL_STORAGE": {
      "name": "android.permission.WRITE_EXTERNAL_STORAGE",
      "label": "modifier ou supprimer le contenu de la carte SD",
      "label_ptr": "permlab_sdcardWrite",
      "description": "Permet \u00e0 l'application de modifier le contenu de la carte\u00a0SD.",
      "description_ptr": "permdesc_sdcardWrite",
      "permission_group": "android.permission-group.STORAGE",
      "protection_level": "dangerous"
    },
    "android.permission.ACCESS_FINE_LOCATION": {
      "name": "android.permission.ACCESS_FINE_LOCATION",
      "label": "acc\u00e9der \u00e0 votre position pr\u00e9cise (GPS et r\u00e9seau)",
      "label_ptr": "permlab_accessFineLocation",
      "description": "Cette application peut obtenir votre position via le GPS ou des sources de positionnement de r\u00e9seau telles que les antennes-relais et les r\u00e9seaux Wi-Fi. Ces services de localisation doivent \u00eatre activ\u00e9s et disponibles sur votre t\u00e9l\u00e9phone pour que l'application puisse les utiliser. Ceci peut r\u00e9duire l'autonomie de la batterie.",
      "description_ptr": "permdesc_accessFineLocation",
      "permission_group": "android.permission-group.LOCATION",
      "protection_level": "dangerous|instant",
      "methods": [
        {
          "method_name": "android.location.LocationManager.requestSingleUpdate",
          "documentation": "Register for a single location update using a Criteria and pending intent.\n\nSee {@link #requestLocationUpdates(long, float, Criteria, PendingIntent)} for\nmore detail on how to use this method. @param criteria contains parameters for\nthe location manager to choose the appropriate provider and parameters to\ncompute the location @param intent a {@link PendingIntent} to be sent for the\nlocation update @throws IllegalArgumentException if provider is null or\ndoesn't exist @throws IllegalArgumentException if intent is null @throws\nSecurityException if no suitable permission is present\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 858
        },
        {
          "method_name": "android.location.LocationManager.injectLocation",
          "documentation": "Set the last known location with a new location.\n\nA privileged client can inject a {@link Location} if it has a better estimate\nof what the recent location is. This is especially useful when the device\nboots up and the GPS chipset is in the process of getting the first fix. If\nthe client has cached the location, it can inject the {@link Location}, so if\nan app requests for a {@link Location} from {@link\n#getLastKnownLocation(String)}, the location information is still useful\nbefore getting the first fix.\n\nUseful in products like Auto. @param newLocation newly available {@link\nLocation} object @return true if update was successful, false if not @throws\nSecurityException if no suitable permission is present @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 980
        },
        {
          "method_name": "android.location.LocationManager.addProximityAlert",
          "documentation": "Set a proximity alert for the location given by the position (latitude,\nlongitude) and the given radius.\n\nWhen the device detects that it has entered or exited the area surrounding the\nlocation, the given PendingIntent will be used to create an Intent to be\nfired.\n\nThe fired Intent will have a boolean extra added with key {@link\n#KEY_PROXIMITY_ENTERING}. If the value is true, the device is entering the\nproximity region; if false, it is exiting.\n\nDue to the approximate nature of position estimation, if the device passes\nthrough the given area briefly, it is possible that no Intent will be fired.\nSimilarly, an Intent could be fired if the device passes very close to the\ngiven area but does not actually enter it.\n\nAfter the number of milliseconds given by the expiration parameter, the\nlocation manager will delete this proximity alert and no longer monitor it. A\nvalue of -1 indicates that there should be no expiration time.\n\nInternally, this method uses both {@link #NETWORK_PROVIDER} and {@link\n#GPS_PROVIDER}.\n\nBefore API version 17, this method could be used with {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} or {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}. From API version 17 and\nonwards, this method requires {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} permission. @param latitude\nthe latitude of the central point of the alert region @param longitude the\nlongitude of the central point of the alert region @param radius the radius of\nthe central point of the alert region, in meters @param expiration time for\nthis proximity alert, in milliseconds, or -1 to indicate no expiration @param\nintent a PendingIntent that will be used to generate an Intent to fire when\nentry to or exit from the alert region is detected @throws SecurityException\nif {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission is not\npresent\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1109
        },
        {
          "method_name": "android.location.LocationManager.addGeofence",
          "documentation": "Add a geofence with the specified LocationRequest quality of service.\n\nWhen the device detects that it has entered or exited the area surrounding the\nlocation, the given PendingIntent will be used to create an Intent to be\nfired.\n\nThe fired Intent will have a boolean extra added with key {@link\n#KEY_PROXIMITY_ENTERING}. If the value is true, the device is entering the\nproximity region; if false, it is exiting.\n\nThe geofence engine fuses results from all location providers to provide the\nbest balance between accuracy and power. Applications can choose the quality\nof service required using the {@link LocationRequest} object. If it is null\nthen a default, low power geo-fencing implementation is used. It is possible\nto cross a geo-fence without notification, but the system will do its best to\ndetect, using {@link LocationRequest} as a hint to trade-off accuracy and\npower.\n\nThe power required by the geofence engine can depend on many factors, such as\nquality and interval requested in {@link LocationRequest}, distance to nearest\ngeofence and current device velocity. @param request quality of service\nrequired, null for default low power @param fence a geographical description\nof the geofence area @param intent pending intent to receive geofence updates\n@throws IllegalArgumentException if fence is null @throws\nIllegalArgumentException if intent is null @throws SecurityException if {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} permission is not present\n@hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1160
        },
        {
          "method_name": "android.location.LocationManager.getLastKnownLocation",
          "documentation": "Returns a Location indicating the data from the last known location fix\nobtained from the given provider.\n\nThis can be done without starting the provider. Note that this location could\nbe out-of-date, for example if the device was turned off and moved to another\nlocation.\n\nIf the provider is currently disabled, null is returned. @param provider the\nname of the provider @return the last known location for the provider, or null\n@throws SecurityException if no suitable permission is present @throws\nIllegalArgumentException if provider is null or doesn't exist\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1416
        },
        {
          "method_name": "android.location.LocationManager.addGpsStatusListener",
          "documentation": "Adds a GPS status listener. @param listener GPS status listener object to\nregister @return true if the listener was successfully added @throws\nSecurityException if the ACCESS_FINE_LOCATION permission is not present\n@deprecated use {@link #registerGnssStatusCallback(GnssStatus.Callback)}\ninstead.\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1821
        },
        {
          "method_name": "android.location.LocationManager.registerGnssStatusCallback",
          "documentation": "Registers a GNSS status callback. @param callback GNSS status callback object\nto register @param handler the handler that the callback runs on. @return true\nif the listener was successfully added @throws SecurityException if the\nACCESS_FINE_LOCATION permission is not present\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1884
        },
        {
          "method_name": "android.location.LocationManager.addNmeaListener",
          "documentation": "Adds an NMEA listener. @param listener a {@link OnNmeaMessageListener} object\nto register @param handler the handler that the listener runs on. @return true\nif the listener was successfully added @throws SecurityException if the\nACCESS_FINE_LOCATION permission is not present\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1995
        },
        {
          "method_name": "android.location.LocationManager.registerGnssMeasurementsCallback",
          "documentation": "Registers a GPS Measurement callback. @param callback a {@link\nGnssMeasurementsEvent.Callback} object to register. @param handler the handler\nthat the callback runs on. @return {@code true} if the callback was added\nsuccessfully, {@code false} otherwise.\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2064
        },
        {
          "method_name": "android.location.LocationManager.registerGnssNavigationMessageCallback",
          "documentation": "Registers a GNSS Navigation Message callback. @param callback a {@link\nGnssNavigationMessage.Callback} object to register. @param handler the handler\nthat the callback runs on. @return {@code true} if the callback was added\nsuccessfully, {@code false} otherwise.\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2137
        },
        {
          "method_name": "android.location.LocationManager.getGpsStatus",
          "documentation": "Retrieves information about the current status of the GPS engine. This should\nonly be called from the {@link GpsStatus.Listener#onGpsStatusChanged} callback\nto ensure that the data is copied atomically. The caller may either pass in a\n{@link GpsStatus} object to set with the latest status information, or pass\nnull to create a new {@link GpsStatus} object. @param status object containing\nGPS status details, or null. @return status object containing updated GPS\nstatus.\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2165
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCellLocation",
          "documentation": "Returns the current location of the device.\n\nIf there is only one radio in the device and that radio has an LTE connection,\nthis method will return null. The implementation must not to try add LTE\nidentifiers into the existing cdma/gsm classes.\n\n@return Current location of the device or null if not available. @deprecated\nuse {@link #getAllCellInfo} instead, which returns a superset of this API.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1817
        },
        {
          "method_name": "android.telephony.TelephonyManager.getAllCellInfo",
          "documentation": "Requests all available cell information from all radios on the device\nincluding the camped/registered, serving, and neighboring cells.\n\nThe response can include one or more {@link android.telephony.CellInfoGsm\nCellInfoGsm}, {@link android.telephony.CellInfoCdma CellInfoCdma}, {@link\nandroid.telephony.CellInfoTdscdma CellInfoTdscdma}, {@link\nandroid.telephony.CellInfoLte CellInfoLte}, and {@link\nandroid.telephony.CellInfoWcdma CellInfoWcdma} objects, in any combination. It\nis typical to see instances of one or more of any these in the list. In\naddition, zero or more of the returned objects may be considered registered;\nthat is, their {@link android.telephony.CellInfo#isRegistered\nCellInfo.isRegistered()} methods may return true, indicating that the cell is\nbeing used or would be used for signaling communication if necessary.\n\nBeginning with {@link android.os.Build.VERSION_CODES#Q Android Q}, if this API\nresults in a change of the cached CellInfo, that change will be reported via\n{@link android.telephony.PhoneStateListener#onCellInfoChanged\nonCellInfoChanged()}.\n\nApps targeting {@link android.os.Build.VERSION_CODES#Q Android Q} or higher\nwill no longer trigger a refresh of the cached CellInfo by invoking this API.\nInstead, those apps will receive the latest cached results, which may not be\ncurrent. Apps targeting {@link android.os.Build.VERSION_CODES#Q Android Q} or\nhigher that wish to request updated CellInfo should call {@link\nandroid.telephony.TelephonyManager#requestCellInfoUpdate\nrequestCellInfoUpdate()}; however, in all cases, updates will be rate-limited\nand are not guaranteed. To determine the recency of CellInfo data, callers\nshould check {@link android.telephony.CellInfo#getTimeStamp\nCellInfo#getTimeStamp()}.\n\nThis method returns valid data for devices with {@link\nandroid.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. In\ncases where only partial information is available for a particular CellInfo\nentry, unavailable fields will be reported as {@link\nandroid.telephony.CellInfo#UNAVAILABLE}. All reported cells will include at\nleast a valid set of technology-specific identification info and a power level\nmeasurement.\n\nThis method is preferred over using {@link\nandroid.telephony.TelephonyManager#getCellLocation getCellLocation()}. @return\nList of {@link android.telephony.CellInfo}; null if cell information is\nunavailable.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5106
        },
        {
          "method_name": "android.telephony.TelephonyManager.requestCellInfoUpdate",
          "documentation": "Requests all available cell information from the current subscription for\nobserved camped/registered, serving, and neighboring cells.\n\nAny available results from this request will be provided by calls to {@link\nandroid.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}\nfor each active subscription. @param workSource the requestor to whom the\npower consumption for this should be attributed. @param executor the executor\non which callback will be invoked. @param callback a callback to receive\nCellInfo. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5223
        },
        {
          "method_name": "android.telephony.TelephonyManager.requestNetworkScan",
          "documentation": "@deprecated Use {@link #requestNetworkScan(NetworkScanRequest, Executor,\nTelephonyScanManager.NetworkScanCallback)} @removed\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7092
        },
        {
          "method_name": "android.net.wifi.rtt.WifiRttManager.startRanging",
          "documentation": "Initiate a request to range to a set of devices specified in the {@link\nRangingRequest}. Results will be returned in the {@link RangingResultCallback}\nset of callbacks. @param workSource A mechanism to specify an alternative\nwork-source for the request. @param request A request specifying a set of\ndevices whose distance measurements are requested. @param executor The\nExecutor on which to run the callback. @param callback A callback for the\nresult of the ranging request. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/rtt/WifiRttManager.java",
          "line": 133
        }
      ]
    },
    "android.permission.ACCESS_COARSE_LOCATION": {
      "name": "android.permission.ACCESS_COARSE_LOCATION",
      "label": "acc\u00e9der \u00e0 votre position approximative (selon le r\u00e9seau)",
      "label_ptr": "permlab_accessCoarseLocation",
      "description": "Cette application peut obtenir votre position via des sources de r\u00e9seau telles que les antennes-relais et les r\u00e9seaux Wi-Fi. Ces services de localisation doivent \u00eatre activ\u00e9s et disponibles sur votre t\u00e9l\u00e9phone pour que l'application puisse les utiliser.",
      "description_ptr": "permdesc_accessCoarseLocation",
      "permission_group": "android.permission-group.LOCATION",
      "protection_level": "dangerous|instant",
      "methods": [
        {
          "method_name": "android.location.LocationManager.requestSingleUpdate",
          "documentation": "Register for a single location update using a Criteria and pending intent.\n\nSee {@link #requestLocationUpdates(long, float, Criteria, PendingIntent)} for\nmore detail on how to use this method. @param criteria contains parameters for\nthe location manager to choose the appropriate provider and parameters to\ncompute the location @param intent a {@link PendingIntent} to be sent for the\nlocation update @throws IllegalArgumentException if provider is null or\ndoesn't exist @throws IllegalArgumentException if intent is null @throws\nSecurityException if no suitable permission is present\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 858
        },
        {
          "method_name": "android.location.LocationManager.addProximityAlert",
          "documentation": "Set a proximity alert for the location given by the position (latitude,\nlongitude) and the given radius.\n\nWhen the device detects that it has entered or exited the area surrounding the\nlocation, the given PendingIntent will be used to create an Intent to be\nfired.\n\nThe fired Intent will have a boolean extra added with key {@link\n#KEY_PROXIMITY_ENTERING}. If the value is true, the device is entering the\nproximity region; if false, it is exiting.\n\nDue to the approximate nature of position estimation, if the device passes\nthrough the given area briefly, it is possible that no Intent will be fired.\nSimilarly, an Intent could be fired if the device passes very close to the\ngiven area but does not actually enter it.\n\nAfter the number of milliseconds given by the expiration parameter, the\nlocation manager will delete this proximity alert and no longer monitor it. A\nvalue of -1 indicates that there should be no expiration time.\n\nInternally, this method uses both {@link #NETWORK_PROVIDER} and {@link\n#GPS_PROVIDER}.\n\nBefore API version 17, this method could be used with {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} or {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}. From API version 17 and\nonwards, this method requires {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} permission. @param latitude\nthe latitude of the central point of the alert region @param longitude the\nlongitude of the central point of the alert region @param radius the radius of\nthe central point of the alert region, in meters @param expiration time for\nthis proximity alert, in milliseconds, or -1 to indicate no expiration @param\nintent a PendingIntent that will be used to generate an Intent to fire when\nentry to or exit from the alert region is detected @throws SecurityException\nif {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission is not\npresent\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1109
        },
        {
          "method_name": "android.location.LocationManager.addGeofence",
          "documentation": "Add a geofence with the specified LocationRequest quality of service.\n\nWhen the device detects that it has entered or exited the area surrounding the\nlocation, the given PendingIntent will be used to create an Intent to be\nfired.\n\nThe fired Intent will have a boolean extra added with key {@link\n#KEY_PROXIMITY_ENTERING}. If the value is true, the device is entering the\nproximity region; if false, it is exiting.\n\nThe geofence engine fuses results from all location providers to provide the\nbest balance between accuracy and power. Applications can choose the quality\nof service required using the {@link LocationRequest} object. If it is null\nthen a default, low power geo-fencing implementation is used. It is possible\nto cross a geo-fence without notification, but the system will do its best to\ndetect, using {@link LocationRequest} as a hint to trade-off accuracy and\npower.\n\nThe power required by the geofence engine can depend on many factors, such as\nquality and interval requested in {@link LocationRequest}, distance to nearest\ngeofence and current device velocity. @param request quality of service\nrequired, null for default low power @param fence a geographical description\nof the geofence area @param intent pending intent to receive geofence updates\n@throws IllegalArgumentException if fence is null @throws\nIllegalArgumentException if intent is null @throws SecurityException if {@link\nandroid.Manifest.permission#ACCESS_FINE_LOCATION} permission is not present\n@hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1160
        },
        {
          "method_name": "android.location.LocationManager.getLastKnownLocation",
          "documentation": "Returns a Location indicating the data from the last known location fix\nobtained from the given provider.\n\nThis can be done without starting the provider. Note that this location could\nbe out-of-date, for example if the device was turned off and moved to another\nlocation.\n\nIf the provider is currently disabled, null is returned. @param provider the\nname of the provider @return the last known location for the provider, or null\n@throws SecurityException if no suitable permission is present @throws\nIllegalArgumentException if provider is null or doesn't exist\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1416
        },
        {
          "method_name": "android.telephony.TelephonyManager.getNeighboringCellInfo",
          "documentation": "Returns the neighboring cell information of the device. @return List of\nNeighboringCellInfo or null if info unavailable. @removed @deprecated Use\n{@link #getAllCellInfo} which returns a superset of the information from\nNeighboringCellInfo, including LTE cell information.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1908
        },
        {
          "method_name": "android.telephony.TelephonyManager.getAvailableNetworks",
          "documentation": "Perform a radio scan and return the list of available networks.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nNote that this scan can take a long time (sometimes minutes) to happen.\n\nRequires Permissions: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\nor that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}) and {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}. @return {@link\nCellNetworkScanResult} with the status {@link\nCellNetworkScanResult#STATUS_SUCCESS} and a list of {@link\ncom.android.internal.telephony.OperatorInfo} if it's available. Otherwise, the\nfailure caused will be included in the result. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7019
        },
        {
          "method_name": "android.telephony.TelephonyManager.getServiceState",
          "documentation": "Returns the current {@link ServiceState} information.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}) and {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9155
        }
      ]
    },
    "android.permission.ACCESS_IMS_CALL_SERVICE": {
      "name": "android.permission.ACCESS_IMS_CALL_SERVICE",
      "label": "acc\u00e9der au service d'appel IMS",
      "label_ptr": "permlab_accessImsCallService",
      "description": "Permet \u00e0 l'application d'utiliser le service IMS pour passer des appels sans votre intervention.",
      "description_ptr": "permdesc_accessImsCallService",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.READ_CALL_LOG": {
      "name": "android.permission.READ_CALL_LOG",
      "label": "lire le journal d'appels",
      "label_ptr": "permlab_readCallLog",
      "description": "Cette application peut lire l'historique de vos appels.",
      "description_ptr": "permdesc_readCallLog",
      "permission_group": "android.permission-group.CALL_LOG",
      "protection_level": "dangerous"
    },
    "android.permission.WRITE_CALL_LOG": {
      "name": "android.permission.WRITE_CALL_LOG",
      "label": "modifier le journal d'appels",
      "label_ptr": "permlab_writeCallLog",
      "description": "Permet \u00e0 l'application de lire le journal d'appels de votre t\u00e9l\u00e9phone, y compris les donn\u00e9es relatives aux appels entrants et sortants. Des applications malveillantes peuvent utiliser cette fonctionnalit\u00e9 pour effacer ou modifier votre journal d'appels.",
      "description_ptr": "permdesc_writeCallLog",
      "permission_group": "android.permission-group.CALL_LOG",
      "protection_level": "dangerous"
    },
    "android.permission.PROCESS_OUTGOING_CALLS": {
      "name": "android.permission.PROCESS_OUTGOING_CALLS",
      "label": "transf\u00e9rer les appels sortants",
      "label_ptr": "permlab_processOutgoingCalls",
      "description": "Permettre \u00e0 l'application de lire le num\u00e9ro compos\u00e9 lors d'un appel sortant, et lui donner la possibilit\u00e9 de rediriger l'appel vers un autre num\u00e9ro ou d'abandonner l'appel",
      "description_ptr": "permdesc_processOutgoingCalls",
      "permission_group": "android.permission-group.CALL_LOG",
      "protection_level": "dangerous"
    },
    "android.permission.READ_PHONE_STATE": {
      "name": "android.permission.READ_PHONE_STATE",
      "label": "Voir l'\u00e9tat et l'identit\u00e9 du t\u00e9l\u00e9phone",
      "label_ptr": "permlab_readPhoneState",
      "description": "Permet \u00e0 l'application d'acc\u00e9der aux fonctionnalit\u00e9s t\u00e9l\u00e9phoniques de l'appareil. Cette autorisation permet \u00e0 l'application de d\u00e9terminer le num\u00e9ro de t\u00e9l\u00e9phone et les identifiants de l'appareil, si un appel est actif et le num\u00e9ro distant connect\u00e9 par un appel.",
      "description_ptr": "permdesc_readPhoneState",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous",
      "methods": [
        {
          "method_name": "android.os.Build.getSerial",
          "documentation": "Gets the hardware serial number, if available.\n\n**Note:** Root access may allow you to modify device identifiers, such as the\nhardware serial number. If you change these identifiers, you can use [key\nattestation](/training/articles/security-key-attestation.html) to obtain proof\nof the device's original identifiers. @return The serial number if specified.\n\n",
          "file": "./aosp/core/java/android/os/Build.java",
          "line": 133
        },
        {
          "method_name": "android.telecom.TelecomManager.getDefaultOutgoingPhoneAccount",
          "documentation": "Return the {@link PhoneAccount} which will be used to place outgoing calls to\naddresses with the specified {@code uriScheme}. This {@link PhoneAccount} will\nalways be a member of the list which is returned from invoking {@link\n#getCallCapablePhoneAccounts()}. The specific account returned depends on the\nfollowing priorities:\n\n  * If the user-selected default {@link PhoneAccount} supports the specified scheme, it will be returned. \n  * If there exists only one {@link PhoneAccount} that supports the specified scheme, it will be returned. \n\nIf no {@link PhoneAccount} fits the criteria above, this method will return\n{@code null}. Requires permission: {@link\nandroid.Manifest.permission#READ_PHONE_STATE} @param uriScheme The URI scheme.\n@return The {@link PhoneAccountHandle} corresponding to the account to be\nused.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 793
        },
        {
          "method_name": "android.telecom.TelecomManager.getUserSelectedOutgoingPhoneAccount",
          "documentation": "Return the {@link PhoneAccount} which is the user-chosen default for making\noutgoing phone calls. This {@code PhoneAccount} will always be a member of the\nlist which is returned from calling {@link #getCallCapablePhoneAccounts()}\n\nApps must be prepared for this method to return {@code null}, indicating that\nthere currently exists no user-chosen default {@code PhoneAccount}.\n\nThe default dialer has access to use this method. @return The user outgoing\nphone account selected by the user.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 818
        },
        {
          "method_name": "android.telecom.TelecomManager.getPhoneAccountsSupportingScheme",
          "documentation": "Returns a list of the {@link PhoneAccountHandle}s which can be used to make\nand receive phone calls which support the specified URI scheme.\n\nFor example, invoking with {@code \"tel\"} will find all {@link\nPhoneAccountHandle}s which support telephone calls (e.g. URIs such as {@code\ntel:555-555-1212}). Invoking with {@code \"sip\"} will find all {@link\nPhoneAccountHandle}s which support SIP calls (e.g. URIs such as {@code\nsip:example@sipexample.com}). @param uriScheme The URI scheme. @return A list\nof {@code PhoneAccountHandle} objects supporting the URI scheme. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 947
        },
        {
          "method_name": "android.telecom.TelecomManager.getSelfManagedPhoneAccounts",
          "documentation": "Returns a list of {@link PhoneAccountHandle}s for self-managed {@link\nConnectionService}s.\n\nSelf-Managed {@link ConnectionService}s have a {@link PhoneAccount} with\n{@link PhoneAccount#CAPABILITY_SELF_MANAGED}.\n\nRequires permission {@link android.Manifest.permission#READ_PHONE_STATE}, or\nthat the caller is the default dialer app.\n\nA {@link SecurityException} will be thrown if a called is not the default\ndialer, or lacks the {@link android.Manifest.permission#READ_PHONE_STATE}\npermission. @return A list of {@code PhoneAccountHandle} objects.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 990
        },
        {
          "method_name": "android.telecom.TelecomManager.isVoiceMailNumber",
          "documentation": "Return whether a given phone number is the configured voicemail number for a\nparticular phone account. Requires permission: {@link\nandroid.Manifest.permission#READ_PHONE_STATE} @param accountHandle The handle\nfor the account to check the voicemail number against @param number The number\nto look up.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1287
        },
        {
          "method_name": "android.telecom.TelecomManager.getVoiceMailNumber",
          "documentation": "Return the voicemail number for a given phone account. Requires permission:\n{@link android.Manifest.permission#READ_PHONE_STATE} @param accountHandle The\nhandle for the phone account. @return The voicemail number for the phone\naccount, and {@code null} if one has not been configured.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1309
        },
        {
          "method_name": "android.telecom.TelecomManager.getLine1Number",
          "documentation": "Return the line 1 phone number for given phone account. Requires permission:\n{@link android.Manifest.permission#READ_PHONE_STATE} @param accountHandle The\nhandle for the account retrieve a number for. @return A string representation\nof the line 1 phone number.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1330
        },
        {
          "method_name": "android.telecom.TelecomManager.isInCall",
          "documentation": "Returns whether there is an ongoing phone call (can be in dialing, ringing,\nactive or holding states) originating from either a manager or self-managed\n{@link ConnectionService}.\n\nRequires permission: {@link android.Manifest.permission#READ_PHONE_STATE}\n@return {@code true} if there is an ongoing call in either a managed or self-\nmanaged {@link ConnectionService}, {@code false} otherwise.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1352
        },
        {
          "method_name": "android.telecom.TelecomManager.isInManagedCall",
          "documentation": "Returns whether there is an ongoing call originating from a managed {@link\nConnectionService}. An ongoing call can be in dialing, ringing, active or\nholding states.\n\nIf you also need to know if there are ongoing self-managed calls, use {@link\n#isInCall()} instead.\n\nRequires permission: {@link android.Manifest.permission#READ_PHONE_STATE}\n@return {@code true} if there is an ongoing call in a managed {@link\nConnectionService}, {@code false} otherwise.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1377
        },
        {
          "method_name": "android.telecom.TelecomManager.isRinging",
          "documentation": "Returns whether there currently exists is a ringing incoming-call. @return\n{@code true} if there is a managed or self-managed ringing call. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1427
        },
        {
          "method_name": "android.telecom.TelecomManager.isTtySupported",
          "documentation": "Returns whether TTY is supported on this device.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1543
        },
        {
          "method_name": "android.telecom.TelecomManager.showInCallScreen",
          "documentation": "Brings the in-call screen to the foreground if there is an ongoing call. If\nthere is currently no ongoing call, then this method does nothing.\n\nRequires that the method-caller be set as the system dialer app or have the\n{@link android.Manifest.permission#READ_PHONE_STATE} permission.\n\n@param showDialpad Brings up the in-call dialpad as part of showing the in-\ncall screen.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1756
        },
        {
          "method_name": "android.telephony.SmsManager.checkSmsShortCodeDestination",
          "documentation": "Check if the destination address is a possible premium short code. NOTE: the\ncaller is expected to strip non-digits from the destination number with {@link\nPhoneNumberUtils#extractNetworkPortion} before calling this method. @param\ndestAddress the destination address to test for possible short code @param\ncountryIso the ISO country code @return {@link\nSmsManager#SMS_CATEGORY_NOT_SHORT_CODE}, {@link\nSmsManager#SMS_CATEGORY_FREE_SHORT_CODE}, {@link\nSmsManager#SMS_CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE}, {@link\nSmsManager#SMS_CATEGORY_PREMIUM_SHORT_CODE}, or {@link\nSmsManager#SMS_CATEGORY_STANDARD_SHORT_CODE} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SmsManager.java",
          "line": 2873
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getActiveSubscriptionInfo",
          "documentation": "Get the active SubscriptionInfo with the input subId.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\nTelephonyManager#hasCarrierPrivileges}). @param subId The unique\nSubscriptionInfo key in database. @return SubscriptionInfo, maybe null if its\nnot active.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 1169
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex",
          "documentation": "Get the active SubscriptionInfo associated with the slotIndex\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\nTelephonyManager#hasCarrierPrivileges}). @param slotIndex the slot which the\nsubscription is inserted @return SubscriptionInfo, maybe null if its not\nactive\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 1232
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getActiveSubscriptionInfoCount",
          "documentation": "Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\nTelephonyManager#hasCarrierPrivileges}). In the latter case, the count will\ninclude only those subscriptions accessible to the caller. @return the current\nnumber of active subscriptions. There is no guarantee the value returned by\nthis method will be the same as the length of the list returned by {@link\n#getActiveSubscriptionInfoList}.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 1512
        },
        {
          "method_name": "android.telephony.SubscriptionManager.isActiveSubscriptionId",
          "documentation": "Checks if the supplied subscription ID corresponds to a subscription which is\nactively in use on the device. An active subscription ID is a valid and usable\nsubscription ID. @param subscriptionId the subscription ID. @return {@code\ntrue} if the supplied subscription ID corresponds to an active subscription;\n{@code false} if it does not correspond to an active subscription; or throw a\nSecurityException if the caller hasn't got the right permission.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2329
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getOpportunisticSubscriptions",
          "documentation": "Return opportunistic subscriptions that can be visible to the caller.\nOpportunistic subscriptions are for opportunistic networks, which are cellular\nnetworks with limited capabilities and coverage, for example, CBRS.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\nTelephonyManager#hasCarrierPrivileges}). @return the list of opportunistic\nsubscription info. If none exists, an empty list.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2708
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getSubscriptionsInGroup",
          "documentation": "Get subscriptionInfo list of subscriptions that are in the same group of given\nsubId. See {@link #createSubscriptionGroup(List)} for more details. Caller\nwill either have {@link android.Manifest.permission#READ_PHONE_STATE}\npermission or had carrier privilege permission on the subscription. {@link\nTelephonyManager#hasCarrierPrivileges()} @throws SecurityException if the\ncaller doesn't meet the requirements outlined above. @param groupUuid of which\nlist of subInfo will be returned. @return list of subscriptionInfo that belong\nto the same group, including the given subscription itself. It will return an\nempty list if no subscription belongs to the group.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2951
        },
        {
          "method_name": "android.telephony.TelephonyManager.getDeviceSoftwareVersion",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1562
        },
        {
          "method_name": "android.telephony.TelephonyManager.getDeviceId",
          "documentation": "Returns the unique device ID of a subscription, for example, the IMEI for GSM\nand the MEID for CDMA phones. Return null if device ID is not available.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param slotIndex of which deviceID is returned\n@deprecated Use (@link getImei} which returns IMEI for GSM or (@link getMeid}\nwhich returns MEID for CDMA.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1616
        },
        {
          "method_name": "android.telephony.TelephonyManager.getImei",
          "documentation": "Returns the IMEI (International Mobile Equipment Identity). Return null if\nIMEI is not available.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param slotIndex of which IMEI is returned\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1654
        },
        {
          "method_name": "android.telephony.TelephonyManager.getMeid",
          "documentation": "Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not\navailable.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param slotIndex of which MEID is returned\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1718
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCarrierConfig",
          "documentation": "Returns the carrier config of the subscription ID pinned to the\nTelephonyManager. If an invalid subscription ID is pinned to the\nTelephonyManager, the returned config will contain default values.\n\nThis method may take several seconds to complete, so it should only be called\nfrom a worker thread.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @see CarrierConfigManager#getConfigForSubId(int) @see\n#createForSubscriptionId(int) @see\n#createForPhoneAccountHandle(PhoneAccountHandle)\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 2292
        },
        {
          "method_name": "android.telephony.TelephonyManager.getNetworkType",
          "documentation": "Returns a constant indicating the radio technology (network type) currently in\nuse on the device for a subscription. @return the network type @param subId\nfor which network type is returned @see #NETWORK_TYPE_UNKNOWN @see\n#NETWORK_TYPE_GPRS @see #NETWORK_TYPE_EDGE @see #NETWORK_TYPE_UMTS @see\n#NETWORK_TYPE_HSDPA @see #NETWORK_TYPE_HSUPA @see #NETWORK_TYPE_HSPA @see\n#NETWORK_TYPE_CDMA @see #NETWORK_TYPE_EVDO_0 @see #NETWORK_TYPE_EVDO_A @see\n#NETWORK_TYPE_EVDO_B @see #NETWORK_TYPE_1xRTT @see #NETWORK_TYPE_IDEN @see\n#NETWORK_TYPE_LTE @see #NETWORK_TYPE_EHRPD @see #NETWORK_TYPE_HSPAP @see\n#NETWORK_TYPE_NR @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 2497
        },
        {
          "method_name": "android.telephony.TelephonyManager.getDataNetworkType",
          "documentation": "Returns a constant indicating the radio technology (network type) currently in\nuse on the device for data transmission for a subscription @return the network\ntype @param subId for which network type is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 2561
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVoiceNetworkType",
          "documentation": "Returns the NETWORK_TYPE_xxxx for voice for a subId @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 2597
        },
        {
          "method_name": "android.telephony.TelephonyManager.getSimSerialNumber",
          "documentation": "Returns the serial number for the given subscription, if applicable. Return\nnull if it is unavailable.\n\n@param subId for which Sim Serial number is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3237
        },
        {
          "method_name": "android.telephony.TelephonyManager.getLteOnCdmaMode",
          "documentation": "Return if the current radio is LTE on CDMA for Subscription. This is a tri-\nstate return value as for a period of time the mode may be unknown. @param\nsubId for which radio is LTE on CDMA is returned @return {@link\nPhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}\nor {@link PhoneConstants#LTE_ON_CDMA_TRUE} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3281
        },
        {
          "method_name": "android.telephony.TelephonyManager.getSubscriberId",
          "documentation": "Returns the unique subscriber ID, for example, the IMSI for a GSM phone for a\nsubscription. Return null if it is unavailable. @param subId whose subscriber\nid is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3476
        },
        {
          "method_name": "android.telephony.TelephonyManager.getGroupIdLevel1",
          "documentation": "Returns the Group Identifier Level1 for a GSM phone for a particular\nsubscription. Return null if it is unavailable. @param subId whose subscriber\nid is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3657
        },
        {
          "method_name": "android.telephony.TelephonyManager.getLine1Number",
          "documentation": "Returns the phone number string for line 1, for example, the MSISDN for a GSM\nphone for a particular subscription. Return null if it is unavailable.\n\nThe default SMS app can also use this. @param subId whose phone number for\nline 1 is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3707
        },
        {
          "method_name": "android.telephony.TelephonyManager.getLine1AlphaTag",
          "documentation": "Returns the alphabetic identifier associated with the line 1 number for a\nsubscription. Return null if it is unavailable. @param subId whose alphabetic\nidentifier associated with line 1 is returned nobody seems to call this. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3795
        },
        {
          "method_name": "android.telephony.TelephonyManager.getMsisdn",
          "documentation": "Returns the MSISDN string. for a GSM phone. Return null if it is unavailable.\n@param subId for which msisdn is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3864
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVoiceMailNumber",
          "documentation": "Returns the voice mail number for a subscription. Return null if it is\nunavailable. @param subId whose voice mail number is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3898
        },
        {
          "method_name": "android.telephony.TelephonyManager.isVisualVoicemailEnabled",
          "documentation": "Returns whether the visual voicemail client is enabled. @param\nphoneAccountHandle the phone account to check for. @return {@code true} when\nthe visual voicemail client is enabled for this client @hide @deprecated\nVisual voicemail no longer in telephony. {@link VisualVoicemailService} should\nbe implemented instead.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4008
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVisualVoicemailPackageName",
          "documentation": "Returns the package responsible of processing visual voicemail for the\nsubscription ID pinned to the TelephonyManager. Returns {@code null} when\nthere is no package responsible for processing visual voicemail for the\nsubscription.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @see #createForSubscriptionId(int) @see\n#createForPhoneAccountHandle(PhoneAccountHandle) @see VisualVoicemailService\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4056
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVoiceMessageCount",
          "documentation": "Returns the voice mail count for a subscription. Return 0 if unavailable or\nthe caller does not have the READ_PHONE_STATE permission. @param subId whose\nvoice message count is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4503
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVoiceMailAlphaTag",
          "documentation": "Retrieves the alphabetic identifier associated with the voice mail number for\na subscription. @param subId whose alphabetic identifier associated with the\nvoice mail number is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4539
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaEriIconIndex",
          "documentation": "Returns the CDMA ERI icon index to display for a subscription @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4948
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaEriIconMode",
          "documentation": "Returns the CDMA ERI icon mode for a subscription. 0 - ON 1 - FLASHING @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4983
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaEriText",
          "documentation": "Returns the CDMA ERI text, of a subscription @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5014
        },
        {
          "method_name": "android.telephony.TelephonyManager.getForbiddenPlmns",
          "documentation": "Returns an array of Forbidden PLMNs from the specified SIM App Returns null if\nthe query fails. @param subId subscription ID used for authentication @param\nappType the icc application type, like {@link #APPTYPE_USIM} @return fplmns an\narray of forbidden PLMNs @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6487
        },
        {
          "method_name": "android.telephony.TelephonyManager.getNetworkSelectionMode",
          "documentation": "Get the network selection mode.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()} @return the network selection\nmode. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7167
        },
        {
          "method_name": "android.telephony.TelephonyManager.isOffhook",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isInCall} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7671
        },
        {
          "method_name": "android.telephony.TelephonyManager.isRinging",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isRinging} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7686
        },
        {
          "method_name": "android.telephony.TelephonyManager.isIdle",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isInCall} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7701
        },
        {
          "method_name": "android.telephony.TelephonyManager.isRadioOn",
          "documentation": "@deprecated Use {@link android.telephony.TelephonyManager#getServiceState}\ninstead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7716
        },
        {
          "method_name": "android.telephony.TelephonyManager.getRadioPowerState",
          "documentation": "@return current modem radio state.\n\nRequires permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or {@link\nandroid.Manifest.permission#READ_PHONE_STATE} or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}). @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8000
        },
        {
          "method_name": "android.telephony.TelephonyManager.isDataRoamingEnabled",
          "documentation": "Returns whether mobile data roaming is enabled on the subscription.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires one of the following permissions: {@link\nandroid.Manifest.permission#ACCESS_NETWORK_STATE}, {@link\nandroid.Manifest.permission#READ_PHONE_STATE} or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}). @return {@code true}\nif the data roaming is enabled on the subscription, otherwise return {@code\nfalse}.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8166
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaRoamingMode",
          "documentation": "Gets the roaming mode for CDMA phone.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()} @return one of {@link\n#CDMA_ROAMING_MODE_RADIO_DEFAULT}, {@link #CDMA_ROAMING_MODE_HOME}, {@link\n#CDMA_ROAMING_MODE_AFFILIATED}, {@link #CDMA_ROAMING_MODE_ANY}. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8192
        },
        {
          "method_name": "android.telephony.TelephonyManager.isVideoCallingEnabled",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8346
        },
        {
          "method_name": "android.telephony.TelephonyManager.getServiceState",
          "documentation": "Returns the current {@link ServiceState} information.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}) and {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9155
        },
        {
          "method_name": "android.telephony.TelephonyManager.isManualNetworkSelectionAllowed",
          "documentation": "Checks if manual network selection is allowed.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}. @return {@code true} if\nmanual network selection is allowed, otherwise return {@code false}. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9940
        },
        {
          "method_name": "android.telephony.TelephonyManager.getNumberOfModemsWithSimultaneousDataConnections",
          "documentation": "How many modems can have simultaneous data connections. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10137
        },
        {
          "method_name": "android.telephony.TelephonyManager.getEmergencyNumberList",
          "documentation": "Get the per-category emergency number list based on current locale, sim,\ndefault, modem and network.\n\nIn each returned list, the emergency number {@link EmergencyNumber} coming\nfrom higher priority sources will be located at the smaller index; the\npriority order of sources are: {@link\nEmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING} > {@link\nEmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM} > {@link\nEmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE} > {@link\nEmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT} > {@link\nEmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG}\n\nThe subscriptions which the returned list would be based on, are all the\nactive subscriptions, no matter which subscription could be used to create\nTelephonyManager.\n\nRequires permission {@link android.Manifest.permission#READ_PHONE_STATE} or\nthe calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\n@param categories the emergency service categories which are the bitwise-OR\ncombination of the following constants:\n\n  1. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED} \n  2. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_POLICE} \n  3. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AMBULANCE} \n  4. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_FIRE_BRIGADE} \n  5. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MARINE_GUARD} \n  6. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MOUNTAIN_RESCUE} \n  7. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MIEC} \n  8. {@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AIEC} \n\n@return Map including the keys as the active subscription IDs (Note: if there\nis no active subscription, the key is {@link\nSubscriptionManager#getDefaultSubscriptionId}) and the value as the list of\n{@link EmergencyNumber}; empty Map if this information is not available; or\nthrow a SecurityException if the caller does not have the permission.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10463
        },
        {
          "method_name": "android.telephony.TelephonyManager.getPreferredOpportunisticDataSubscription",
          "documentation": "Get preferred opportunistic data subscription Id\n\nRequires that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}), or has either READ_PRIVILEGED_PHONE_STATE or {@link\nandroid.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} permission.\n@return subId preferred opportunistic subscription id or {@link\nSubscriptionManager#DEFAULT_SUBSCRIPTION_ID} if there are no preferred\nsubscription id\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10685
        },
        {
          "method_name": "android.telephony.TelephonyManager.isMultiSimSupported",
          "documentation": "Returns if the usage of multiple SIM cards at the same time to register on the\nnetwork (e.g. Dual Standby or Dual Active) is supported by the device and by\nthe carrier.\n\nRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE\nREAD_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @return {@link #MULTISIM_ALLOWED} if the device\nsupports multiple SIMs. {@link #MULTISIM_NOT_SUPPORTED_BY_HARDWARE} if the\ndevice does not support multiple SIMs. {@link\n#MULTISIM_NOT_SUPPORTED_BY_CARRIER} in the device supports multiple SIMs, but\nthe functionality is restricted by the carrier.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10866
        }
      ]
    },
    "android.permission.READ_PHONE_NUMBERS": {
      "name": "android.permission.READ_PHONE_NUMBERS",
      "label": "lire les num\u00e9ros de t\u00e9l\u00e9phone",
      "label_ptr": "permlab_readPhoneNumbers",
      "description": "Permet \u00e0 l'application d'acc\u00e9der aux num\u00e9ros de t\u00e9l\u00e9phone de l'appareil.",
      "description_ptr": "permdesc_readPhoneNumbers",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous|instant",
      "methods": [
        {
          "method_name": "android.telephony.TelephonyManager.getLine1Number",
          "documentation": "Returns the phone number string for line 1, for example, the MSISDN for a GSM\nphone for a particular subscription. Return null if it is unavailable.\n\nThe default SMS app can also use this. @param subId whose phone number for\nline 1 is returned @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3707
        }
      ]
    },
    "android.permission.CALL_PHONE": {
      "name": "android.permission.CALL_PHONE",
      "label": "appeler directement les num\u00e9ros de t\u00e9l\u00e9phone",
      "label_ptr": "permlab_callPhone",
      "description": "Permet \u00e0 l'application d'appeler des num\u00e9ros de t\u00e9l\u00e9phone sans votre intervention. Cette autorisation peut entra\u00eener des frais ou des appels impr\u00e9vus et ne permet pas \u00e0 l'application d'appeler des num\u00e9ros d'urgence. Les applications malveillantes peuvent g\u00e9n\u00e9rer des frais en passant des appels sans votre consentement.",
      "description_ptr": "permdesc_callPhone",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous",
      "methods": [
        {
          "method_name": "android.telecom.TelecomManager.placeCall",
          "documentation": "Places a new outgoing call to the provided address using the system telecom\nservice with the specified extras. This method is equivalent to placing an\noutgoing call using {@link Intent#ACTION_CALL}, except that the outgoing call\nwill always be sent via the system telecom service. If method-caller is either\nthe user selected default dialer app or preloaded system dialer app, then\nemergency calls will also be allowed. Placing a call via a managed {@link\nConnectionService} requires permission: {@link\nandroid.Manifest.permission#CALL_PHONE} Usage example:\n\n    \n    \n     Uri uri = Uri.fromParts(\"tel\", \"12345\", null); Bundle extras = new Bundle(); extras.putBoolean(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, true); telecomManager.placeCall(uri, extras); \n\nThe following keys are supported in the supplied extras.\n\n  * {@link #EXTRA_OUTGOING_CALL_EXTRAS}\n  * {@link #EXTRA_PHONE_ACCOUNT_HANDLE}\n  * {@link #EXTRA_START_CALL_WITH_SPEAKERPHONE}\n  * {@link #EXTRA_START_CALL_WITH_VIDEO_STATE}\n\nAn app which implements the self-managed {@link ConnectionService} API uses\n{@link #placeCall(Uri, Bundle)} to inform Telecom of a new outgoing call. A\nself-managed {@link ConnectionService} must include {@link\n#EXTRA_PHONE_ACCOUNT_HANDLE} to specify its associated {@link\nandroid.telecom.PhoneAccountHandle}. Self-managed {@link ConnectionService}s\nrequire permission {@link android.Manifest.permission#MANAGE_OWN_CALLS}.\n\n**Note:** If this method is used to place an emergency call, it is not\nguaranteed that the call will be placed on the {@link PhoneAccount} provided\nin the {@link #EXTRA_PHONE_ACCOUNT_HANDLE} extra (if specified) and may be\nplaced on another {@link PhoneAccount} with the {@link\nPhoneAccount#CAPABILITY_PLACE_EMERGENCY_CALLS} capability, depending on\nexternal factors, such as network conditions and Modem/SIM status.\n\n@param address The address to make the call to. @param extras Bundle of extras\nto use with the call.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1815
        },
        {
          "method_name": "android.telephony.TelephonyManager.call",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#placeCall(Uri address,\nBundle extras)} instead. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7616
        },
        {
          "method_name": "android.telephony.TelephonyManager.endCall",
          "documentation": "@removed Use {@link android.telecom.TelecomManager#endCall()} instead. @hide\n@removed\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7634
        },
        {
          "method_name": "android.telephony.TelephonyManager.sendUssdRequest",
          "documentation": "Sends an Unstructured Supplementary Service Data (USSD) request to the mobile\nnetwork and informs the caller of the response via the supplied {@code\ncallback}.\n\nCarriers define USSD codes which can be sent by the user to request\ninformation such as the user's current data balance or minutes balance.\n\nRequires permission: {@link android.Manifest.permission#CALL_PHONE} @param\nussdRequest the USSD command to be executed. @param callback called by the\nframework to inform the caller of the result of executing the USSD request\n(see {@link UssdResponseCallback}). @param handler the {@link Handler} to run\nthe request on.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7836
        }
      ]
    },
    "com.android.voicemail.permission.ADD_VOICEMAIL": {
      "name": "com.android.voicemail.permission.ADD_VOICEMAIL",
      "label": "ajouter un message vocal",
      "label_ptr": "permlab_addVoicemail",
      "description": "Permet \u00e0 l'application d'ajouter des messages \u00e0 votre messagerie vocale.",
      "description_ptr": "permdesc_addVoicemail",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous"
    },
    "android.permission.USE_SIP": {
      "name": "android.permission.USE_SIP",
      "label": "effectuer/recevoir des appels\u00a0SIP",
      "label_ptr": "permlab_use_sip",
      "description": "Autorise l'application \u00e0 effectuer et \u00e0 recevoir des appels\u00a0SIP.",
      "description_ptr": "permdesc_use_sip",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous"
    },
    "android.permission.ANSWER_PHONE_CALLS": {
      "name": "android.permission.ANSWER_PHONE_CALLS",
      "label": "r\u00e9pondre aux appels t\u00e9l\u00e9phoniques",
      "label_ptr": "permlab_answerPhoneCalls",
      "description": "Autorise l'application \u00e0 r\u00e9pondre \u00e0 un appel t\u00e9l\u00e9phonique entrant.",
      "description_ptr": "permdesc_answerPhoneCalls",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous|runtime",
      "methods": [
        {
          "method_name": "android.telecom.TelecomManager.endCall",
          "documentation": "Ends the foreground call on the device.\n\nIf there is a ringing call, calling this method rejects the ringing call.\nOtherwise the foreground call is ended.\n\nRequires permission {@link android.Manifest.permission#ANSWER_PHONE_CALLS}.\n@return {@code true} if there is a call which will be rejected or terminated,\n{@code false} otherwise. @deprecated Companion apps for wearable devices\nshould use the {@link InCallService} API instead. Apps performing call\nscreening should use the {@link CallScreeningService} API instead.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1456
        },
        {
          "method_name": "android.telecom.TelecomManager.acceptRingingCall",
          "documentation": "If there is a ringing incoming call, this method accepts the call on behalf of\nthe user, with the specified video state. Requires permission: {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE} or {@link\nandroid.Manifest.permission#ANSWER_PHONE_CALLS} @param videoState The desired\nvideo state to answer the call with. @deprecated Companion apps for wearable\ndevices should use the {@link InCallService} API instead.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1509
        }
      ]
    },
    "android.permission.MANAGE_OWN_CALLS": {
      "name": "android.permission.MANAGE_OWN_CALLS",
      "label": "acheminer les appels via le syst\u00e8me",
      "label_ptr": "permlab_manageOwnCalls",
      "description": "Autorise l'application \u00e0 acheminer les appels via le syst\u00e8me afin d'optimiser le confort d'utilisation.",
      "description_ptr": "permdesc_manageOwnCalls",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.telecom.TelecomManager.placeCall",
          "documentation": "Places a new outgoing call to the provided address using the system telecom\nservice with the specified extras. This method is equivalent to placing an\noutgoing call using {@link Intent#ACTION_CALL}, except that the outgoing call\nwill always be sent via the system telecom service. If method-caller is either\nthe user selected default dialer app or preloaded system dialer app, then\nemergency calls will also be allowed. Placing a call via a managed {@link\nConnectionService} requires permission: {@link\nandroid.Manifest.permission#CALL_PHONE} Usage example:\n\n    \n    \n     Uri uri = Uri.fromParts(\"tel\", \"12345\", null); Bundle extras = new Bundle(); extras.putBoolean(TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, true); telecomManager.placeCall(uri, extras); \n\nThe following keys are supported in the supplied extras.\n\n  * {@link #EXTRA_OUTGOING_CALL_EXTRAS}\n  * {@link #EXTRA_PHONE_ACCOUNT_HANDLE}\n  * {@link #EXTRA_START_CALL_WITH_SPEAKERPHONE}\n  * {@link #EXTRA_START_CALL_WITH_VIDEO_STATE}\n\nAn app which implements the self-managed {@link ConnectionService} API uses\n{@link #placeCall(Uri, Bundle)} to inform Telecom of a new outgoing call. A\nself-managed {@link ConnectionService} must include {@link\n#EXTRA_PHONE_ACCOUNT_HANDLE} to specify its associated {@link\nandroid.telecom.PhoneAccountHandle}. Self-managed {@link ConnectionService}s\nrequire permission {@link android.Manifest.permission#MANAGE_OWN_CALLS}.\n\n**Note:** If this method is used to place an emergency call, it is not\nguaranteed that the call will be placed on the {@link PhoneAccount} provided\nin the {@link #EXTRA_PHONE_ACCOUNT_HANDLE} extra (if specified) and may be\nplaced on another {@link PhoneAccount} with the {@link\nPhoneAccount#CAPABILITY_PLACE_EMERGENCY_CALLS} capability, depending on\nexternal factors, such as network conditions and Modem/SIM status.\n\n@param address The address to make the call to. @param extras Bundle of extras\nto use with the call.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1815
        }
      ]
    },
    "android.permission.CALL_COMPANION_APP": {
      "name": "android.permission.CALL_COMPANION_APP",
      "label": "",
      "label_ptr": "permlab_callCompanionApp",
      "description": "",
      "description_ptr": "permdesc_callCompanionApp",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.ACCEPT_HANDOVER": {
      "name": "android.permission.ACCEPT_HANDOVER",
      "label": "",
      "label_ptr": "",
      "description": "Autorise l'application \u00e0 continuer un appel qui a \u00e9t\u00e9 d\u00e9marr\u00e9 dans une autre application.",
      "description_ptr": "permdesc_acceptHandovers",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "dangerous"
    },
    "android.permission.RECORD_AUDIO": {
      "name": "android.permission.RECORD_AUDIO",
      "label": "enregistrer des fichiers audio",
      "label_ptr": "permlab_recordAudio",
      "description": "Cette application peut utiliser le micro pour enregistrer du contenu audio \u00e0 tout moment.",
      "description_ptr": "permdesc_recordAudio",
      "permission_group": "android.permission-group.MICROPHONE",
      "protection_level": "dangerous|instant"
    },
    "android.permission.ACCESS_UCE_PRESENCE_SERVICE": {
      "name": "android.permission.ACCESS_UCE_PRESENCE_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_UCE_OPTIONS_SERVICE": {
      "name": "android.permission.ACCESS_UCE_OPTIONS_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "android.permission-group.PHONE",
      "protection_level": "signature|privileged"
    },
    "android.permission.CAMERA": {
      "name": "android.permission.CAMERA",
      "label": "prendre des photos et enregistrer des vid\u00e9os",
      "label_ptr": "permlab_camera",
      "description": "Cette application peut utiliser l'appareil photo pour prendre des photos et enregistrer des vid\u00e9os \u00e0 tout moment.",
      "description_ptr": "permdesc_camera",
      "permission_group": "android.permission-group.CAMERA",
      "protection_level": "dangerous|instant",
      "methods": [
        {
          "method_name": "android.hardware.camera2.CameraManager.openCamera",
          "documentation": "Open a connection to a camera with the given ID.\n\nThe behavior of this method matches that of {@link #openCamera(String,\nStateCallback, Handler)}, except that it uses {@link\njava.util.concurrent.Executor} as an argument instead of {@link\nandroid.os.Handler}.\n\n@param cameraId The unique identifier of the camera device to open @param\nexecutor The executor which will be used when invoking the callback. @param\ncallback The callback which is invoked once the camera is opened @throws\nCameraAccessException if the camera is disabled by device policy, has been\ndisconnected, or is being used by a higher-priority camera API client. @throws\nIllegalArgumentException if cameraId, the callback or the executor was null,\nor the cameraId does not match any currently or previously available camera\ndevice. @throws SecurityException if the application does not have permission\nto access the camera @see #getCameraIdList @see\nandroid.app.admin.DevicePolicyManager#setCameraDisabled\n\n",
          "file": "./aosp/core/java/android/hardware/camera2/CameraManager.java",
          "line": 503
        }
      ]
    },
    "android.permission.BODY_SENSORS": {
      "name": "android.permission.BODY_SENSORS",
      "label": "acc\u00e9der capteurs corp. (ex\u00a0: cardiofr\u00e9quencem\u00e8tres)",
      "label_ptr": "permlab_bodySensors",
      "description": "Permet \u00e0 l'application d'acc\u00e9der aux donn\u00e9es des capteurs qui contr\u00f4lent votre condition physique, comme votre rythme cardiaque.",
      "description_ptr": "permdesc_bodySensors",
      "permission_group": "android.permission-group.SENSORS",
      "protection_level": "dangerous"
    },
    "android.permission.USE_FINGERPRINT": {
      "name": "android.permission.USE_FINGERPRINT",
      "label": "Utiliser le mat\u00e9riel d'empreintes digitales",
      "label_ptr": "permlab_useFingerprint",
      "description": "Autoriser l'application \u00e0 utiliser le mat\u00e9riel d'empreintes digitales pour l'authentification",
      "description_ptr": "permdesc_useFingerprint",
      "permission_group": "android.permission-group.SENSORS",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.accessibilityservice.AccessibilityService.getFingerprintGestureController",
          "documentation": "Get the controller for fingerprint gestures. This feature requires {@link\nAccessibilityServiceInfo#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES}.\n**Note:** The service must be connected before this method is called. @return\nThe controller for fingerprint gestures, or {@code null} if gestures are\nunavailable.\n\n",
          "file": "./aosp/core/java/android/accessibilityservice/AccessibilityService.java",
          "line": 637
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.getEnrolledFingerprints",
          "documentation": "Obtain the list of enrolled fingerprints templates. @return list of current\nfingerprint items @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 741
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.hasEnrolledFingerprints",
          "documentation": "@hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 770
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.isHardwareDetected",
          "documentation": "Determine if fingerprint hardware is present and functional. @return true if\nhardware is present and functional, false otherwise. @deprecated See {@link\nBiometricPrompt} and {@link\nFingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 788
        }
      ]
    },
    "android.permission.USE_BIOMETRIC": {
      "name": "android.permission.USE_BIOMETRIC",
      "label": "",
      "label_ptr": "permlab_useBiometric",
      "description": "",
      "description_ptr": "permdesc_useBiometric",
      "permission_group": "android.permission-group.SENSORS",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.hardware.biometrics.BiometricPrompt.authenticate",
          "documentation": "This call warms up the fingerprint hardware, displays a system-provided\ndialog, and starts scanning for a fingerprint. It terminates when {@link\nAuthenticationCallback#onAuthenticationError(int, CharSequence)} is called,\nwhen {@link AuthenticationCallback#onAuthenticationSucceeded(\nAuthenticationResult)} is called, or when the user dismisses the system-\nprovided dialog. This operation can be canceled by using the provided cancel\nobject. The application will receive authentication errors through {@link\nAuthenticationCallback}, and button events through the corresponding callback\nset in {@link Builder#setNegativeButton(CharSequence, Executor,\nDialogInterface.OnClickListener)}. It is safe to reuse the {@link\nBiometricPrompt} object, and calling {@link\nBiometricPrompt#authenticate(CancellationSignal, Executor,\nAuthenticationCallback)} while an existing authentication attempt is occurring\nwill stop the previous client and start a new authentication. The interrupted\nclient will receive a cancelled notification through {@link\nAuthenticationCallback#onAuthenticationError(int, CharSequence)}. @throws\nIllegalArgumentException If any of the arguments are null @param cancel An\nobject that can be used to cancel authentication @param executor An executor\nto handle callback events @param callback An object to receive authentication\nevents\n\n",
          "file": "./aosp/core/java/android/hardware/biometrics/BiometricPrompt.java",
          "line": 461
        }
      ]
    },
    "android.permission.READ_PROFILE": {
      "name": "android.permission.READ_PROFILE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.WRITE_PROFILE": {
      "name": "android.permission.WRITE_PROFILE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.READ_SOCIAL_STREAM": {
      "name": "android.permission.READ_SOCIAL_STREAM",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.WRITE_SOCIAL_STREAM": {
      "name": "android.permission.WRITE_SOCIAL_STREAM",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.READ_USER_DICTIONARY": {
      "name": "android.permission.READ_USER_DICTIONARY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.WRITE_USER_DICTIONARY": {
      "name": "android.permission.WRITE_USER_DICTIONARY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.WRITE_SMS": {
      "name": "android.permission.WRITE_SMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "com.android.browser.permission.READ_HISTORY_BOOKMARKS": {
      "name": "com.android.browser.permission.READ_HISTORY_BOOKMARKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "com.android.browser.permission.WRITE_HISTORY_BOOKMARKS": {
      "name": "com.android.browser.permission.WRITE_HISTORY_BOOKMARKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.AUTHENTICATE_ACCOUNTS": {
      "name": "android.permission.AUTHENTICATE_ACCOUNTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.MANAGE_ACCOUNTS": {
      "name": "android.permission.MANAGE_ACCOUNTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.USE_CREDENTIALS": {
      "name": "android.permission.USE_CREDENTIALS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SUBSCRIBED_FEEDS_READ": {
      "name": "android.permission.SUBSCRIBED_FEEDS_READ",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SUBSCRIBED_FEEDS_WRITE": {
      "name": "android.permission.SUBSCRIBED_FEEDS_WRITE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.FLASHLIGHT": {
      "name": "android.permission.FLASHLIGHT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SEND_RESPOND_VIA_MESSAGE": {
      "name": "android.permission.SEND_RESPOND_VIA_MESSAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SEND_SMS_NO_CONFIRMATION": {
      "name": "android.permission.SEND_SMS_NO_CONFIRMATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CARRIER_FILTER_SMS": {
      "name": "android.permission.CARRIER_FILTER_SMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.RECEIVE_EMERGENCY_BROADCAST": {
      "name": "android.permission.RECEIVE_EMERGENCY_BROADCAST",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.RECEIVE_BLUETOOTH_MAP": {
      "name": "android.permission.RECEIVE_BLUETOOTH_MAP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_DIRECTORY_SEARCH": {
      "name": "android.permission.BIND_DIRECTORY_SEARCH",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MODIFY_CELL_BROADCASTS": {
      "name": "android.permission.MODIFY_CELL_BROADCASTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "com.android.alarm.permission.SET_ALARM": {
      "name": "com.android.alarm.permission.SET_ALARM",
      "label": "d\u00e9finir une alarme",
      "label_ptr": "permlab_setAlarm",
      "description": "Permet \u00e0 l'application de r\u00e9gler la sonnerie d'un r\u00e9veil install\u00e9. Cette fonctionnalit\u00e9 n'est pas disponible sur tous les r\u00e9veils.",
      "description_ptr": "permdesc_setAlarm",
      "permission_group": "",
      "protection_level": "normal"
    },
    "com.android.voicemail.permission.WRITE_VOICEMAIL": {
      "name": "com.android.voicemail.permission.WRITE_VOICEMAIL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "com.android.voicemail.permission.READ_VOICEMAIL": {
      "name": "com.android.voicemail.permission.READ_VOICEMAIL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_LOCATION_EXTRA_COMMANDS": {
      "name": "android.permission.ACCESS_LOCATION_EXTRA_COMMANDS",
      "label": "Acc\u00e8s aux commandes de fournisseur de position g\u00e9ographique suppl\u00e9mentaires",
      "label_ptr": "permlab_accessLocationExtraCommands",
      "description": "Permet \u00e0 l'application d'acc\u00e9der \u00e0 des commandes de localisation suppl\u00e9mentaires offertes par le fournisseur. Elle est ainsi susceptible d'interf\u00e9rer avec le bon fonctionnement du GPS ou de toute autre source de localisation.",
      "description_ptr": "permdesc_accessLocationExtraCommands",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.INSTALL_LOCATION_PROVIDER": {
      "name": "android.permission.INSTALL_LOCATION_PROVIDER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.HDMI_CEC": {
      "name": "android.permission.HDMI_CEC",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.hdmi.HdmiControlManager.setStandbyMode",
          "documentation": "Controls standby mode of the system. It will also try to turn on/off the\nconnected devices if necessary. @param isStandbyModeOn target status of the\nsystem's standby mode\n\n",
          "file": "./aosp/core/java/android/hardware/hdmi/HdmiControlManager.java",
          "line": 358
        },
        {
          "method_name": "android.hardware.hdmi.HdmiControlManager.addHotplugEventListener",
          "documentation": "Adds a listener to get informed of {@link HdmiHotplugEvent}.\n\nTo stop getting the notification, use {@link\n#removeHotplugEventListener(HotplugEventListener)}. @param listener {@link\nHotplugEventListener} instance @see\nHdmiControlManager#removeHotplugEventListener(HotplugEventListener)\n\n",
          "file": "./aosp/core/java/android/hardware/hdmi/HdmiControlManager.java",
          "line": 419
        },
        {
          "method_name": "android.hardware.hdmi.HdmiControlManager.removeHotplugEventListener",
          "documentation": "Removes a listener to stop getting informed of {@link HdmiHotplugEvent}.\n@param listener {@link HotplugEventListener} instance to be removed\n\n",
          "file": "./aosp/core/java/android/hardware/hdmi/HdmiControlManager.java",
          "line": 443
        }
      ]
    },
    "android.permission.LOCATION_HARDWARE": {
      "name": "android.permission.LOCATION_HARDWARE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.location.ContextHubClient.sendMessageToNanoApp",
          "documentation": "Sends a message to a nanoapp through the Context Hub Service. This function\nreturns TRANSACTION_SUCCESS if the message has reached the HAL, but does not\nguarantee delivery of the message to the target nanoapp. @param message the\nmessage object to send @return the result of sending the message defined as in\nContextHubTransaction.Result @throws NullPointerException if NanoAppMessage is\nnull @see NanoAppMessage @see ContextHubTransaction.Result\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubClient.java",
          "line": 119
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.getContextHubHandles",
          "documentation": "Get a handle to all the context hubs in the system @return array of context\nhub handles @deprecated Use {@link #getContextHubs()} instead. The use of\nhandles are deprecated in the new APIs.\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 116
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.getContextHubInfo",
          "documentation": "Get more information about a specific hub. @param hubHandle Handle (system-\nwide unique identifier) of a context hub. @return ContextHubInfo Information\nabout the requested context hub. @see ContextHubInfo @deprecated Use {@link\n#getContextHubs()} instead. The use of handles are deprecated in the new APIs.\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 137
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.loadNanoApp",
          "documentation": "Loads a nanoapp at the specified Context Hub. After the nanoapp binary is\nsuccessfully loaded at the specified hub, the nanoapp will be in the enabled\nstate. @param hubInfo the hub to load the nanoapp on @param appBinary The app\nbinary to load @return the ContextHubTransaction of the request @throws\nNullPointerException if hubInfo or NanoAppBinary is null @see NanoAppBinary\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 386
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.unloadNanoApp",
          "documentation": "Unloads a nanoapp at the specified Context Hub. @param hubInfo the hub to\nunload the nanoapp from @param nanoAppId the app to unload @return the\nContextHubTransaction of the request @throws NullPointerException if hubInfo\nis null\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 415
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.getNanoAppInstanceInfo",
          "documentation": "get information about the nano app instance NOTE: The returned\nNanoAppInstanceInfo does _not_ contain correct information for several fields,\nspecifically: - getName() - getPublisher() - getNeededExecMemBytes() -\ngetNeededReadMemBytes() - getNeededWriteMemBytes() For example, say you call\nloadNanoApp() with a NanoApp that has getName() returning \"My Name\". Later, if\nyou call getNanoAppInstanceInfo for that nanoapp, the returned\nNanoAppInstanceInfo's getName() method will claim \"Preloaded app, unknown\",\neven though you would have expected \"My Name\". For now, as the user, you'll\nneed to separately track the above fields if they are of interest to you.\nTODO(b/30943489): Have the returned NanoAppInstanceInfo contain the correct\ninformation. @param nanoAppHandle handle of the nanoapp instance @return\nNanoAppInstanceInfo the NanoAppInstanceInfo of the nanoapp, or null if the\nnanoapp does not exist @see NanoAppInstanceInfo @deprecated Use {@link\n#queryNanoApps(ContextHubInfo)} instead to explicitly query the hub for loaded\nnanoapps.\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 235
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.findNanoAppOnHub",
          "documentation": "Find a specified nano app on the system @param hubHandle handle of hub to\nsearch for nano app @param filter filter specifying the search criteria for\napp @see NanoAppFilter @return int[] Array of handles to any found nano apps\n@deprecated Use {@link #queryNanoApps(ContextHubInfo)} instead to explicitly\nquery the hub for loaded nanoapps.\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 258
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.sendMessage",
          "documentation": "Send a message to a specific nano app instance on a context hub. Note that the\nreturn value of this method only speaks of success up to the point of sending\nthis to the Context Hub. It is not an assurance that the Context Hub\nsuccessfully sent this message on to the nanoapp. If assurance is desired, a\nprotocol should be established between your code and the nanoapp, with the\nnanoapp sending a confirmation message (which will be reported via\nCallback.onMessageReceipt). @param hubHandle handle of the hub to send the\nmessage to @param nanoAppHandle handle of the nano app to send to @param\nmessage Message to be sent @see ContextHubMessage @return int 0 on success, -1\notherwise @deprecated Use {@link\nandroid.hardware.location.ContextHubClient#sendMessageToNanoApp(\nNanoAppMessage)} instead, after creating a {@link\nandroid.hardware.location.ContextHubClient} with {@link\n#createClient(ContextHubInfo, ContextHubClientCallback, Executor)} or {@link\n#createClient(ContextHubInfo, ContextHubClientCallback)}.\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 293
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.getContextHubs",
          "documentation": "Returns the list of ContextHubInfo objects describing the available Context\nHubs. @return the list of ContextHubInfo objects @see ContextHubInfo\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 309
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.enableNanoApp",
          "documentation": "Enables a nanoapp at the specified Context Hub. @param hubInfo the hub to\nenable the nanoapp on @param nanoAppId the app to enable @return the\nContextHubTransaction of the request @throws NullPointerException if hubInfo\nis null\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 443
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.disableNanoApp",
          "documentation": "Disables a nanoapp at the specified Context Hub. @param hubInfo the hub to\ndisable the nanoapp on @param nanoAppId the app to disable @return the\nContextHubTransaction of the request @throws NullPointerException if hubInfo\nis null\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 471
        },
        {
          "method_name": "android.hardware.location.ContextHubManager.queryNanoApps",
          "documentation": "Requests a query for nanoapps loaded at the specified Context Hub. @param\nhubInfo the hub to query a list of nanoapps from @return the\nContextHubTransaction of the request @throws NullPointerException if hubInfo\nis null\n\n",
          "file": "./aosp/core/java/android/hardware/location/ContextHubManager.java",
          "line": 498
        },
        {
          "method_name": "android.location.LocationManager.injectLocation",
          "documentation": "Set the last known location with a new location.\n\nA privileged client can inject a {@link Location} if it has a better estimate\nof what the recent location is. This is especially useful when the device\nboots up and the GPS chipset is in the process of getting the first fix. If\nthe client has cached the location, it can inject the {@link Location}, so if\nan app requests for a {@link Location} from {@link\n#getLastKnownLocation(String)}, the location information is still useful\nbefore getting the first fix.\n\nUseful in products like Auto. @param newLocation newly available {@link\nLocation} object @return true if update was successful, false if not @throws\nSecurityException if no suitable permission is present @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 980
        },
        {
          "method_name": "android.location.LocationManager.getGnssBatchSize",
          "documentation": "Returns the batch size (in number of Location objects) that are supported by\nthe batching interface. @return Maximum number of location objects that can be\nreturned @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2219
        },
        {
          "method_name": "android.location.LocationManager.registerGnssBatchedLocationCallback",
          "documentation": "Start hardware-batching of GNSS locations. This API is primarily used when the\nAP is asleep and the device can batch GNSS locations in the hardware. Note\nthis is designed (as was the fused location interface before it) for a single\nuser SystemApi - requests are not consolidated. Care should be taken when the\nSystem switches users that may have different batching requests, to stop\nhardware batching for one user, and restart it for the next. @param\nperiodNanos Time interval, in nanoseconds, that the GNSS locations are\nrequested within the batch @param wakeOnFifoFull True if the hardware batching\nshould flush the locations in a a callback to the listener, when it's internal\nbuffer is full. If set to false, the oldest location information is, instead,\ndropped when the buffer is full. @param callback The listener on which to\nreturn the batched locations @param handler The handler on which to process\nthe callback @return True if batching was successfully started @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2250
        },
        {
          "method_name": "android.location.LocationManager.flushGnssBatch",
          "documentation": "Flush the batched GNSS locations. All GNSS locations currently ready in the\nbatch are returned via the callback sent in startGnssBatch(), and the buffer\ncontaining the batched locations is cleared. @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2270
        },
        {
          "method_name": "android.location.LocationManager.unregisterGnssBatchedLocationCallback",
          "documentation": "Stop batching locations. This API is primarily used when the AP is asleep and\nthe device can batch locations in the hardware. @param callback the specific\ncallback class to remove from the transport layer @return True if batching was\nsuccessfully started @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 2289
        },
        {
          "method_name": "android.net.wifi.RttManager.getRttCapabilities",
          "documentation": "This method is deprecated. Please use the {@link WifiRttManager} API.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/RttManager.java",
          "line": 323
        },
        {
          "method_name": "android.net.wifi.RttManager.startRanging",
          "documentation": "Request to start an RTT ranging\n\nThis method is deprecated. Please use the {@link\nWifiRttManager#startRanging(RangingRequest, java.util.concurrent.Executor,\nRangingResultCallback)} API. @param params -- RTT request Parameters @param\nlistener -- Call back to inform RTT result @exception throw\nIllegalArgumentException when params are illegal throw IllegalStateException\nwhen RttCapabilities do not exist\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/RttManager.java",
          "line": 944
        },
        {
          "method_name": "android.net.wifi.RttManager.stopRanging",
          "documentation": "This method is deprecated and performs no function. Please use the {@link\nWifiRttManager} API.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/RttManager.java",
          "line": 1025
        },
        {
          "method_name": "android.net.wifi.RttManager.enableResponder",
          "documentation": "Enable Wi-Fi RTT responder mode on the device. The enabling result will be\ndelivered via {@code callback}.\n\nNote calling this method with the same callback when the responder is already\nenabled won't change the responder state, a cached {@link ResponderConfig}\nfrom the last enabling will be returned through the callback.\n\nThis method is deprecated and will throw an {@link\nUnsupportedOperationException} exception. Please use the {@link\nWifiRttManager} API to perform a Wi-Fi Aware peer-to-peer ranging. @param\ncallback Callback for responder enabling/disabling result. @throws\nIllegalArgumentException If {@code callback} is null.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/RttManager.java",
          "line": 1063
        },
        {
          "method_name": "android.net.wifi.RttManager.disableResponder",
          "documentation": "Disable Wi-Fi RTT responder mode on the device. The {@code callback} needs to\nbe the same one used in {@link #enableResponder(ResponderCallback)}.\n\nCalling this method when responder isn't enabled won't have any effect. The\ncallback can be reused for enabling responder after this method is called.\n\nThis method is deprecated and will throw an {@link\nUnsupportedOperationException} exception. Please use the {@link\nWifiRttManager} API to perform a Wi-Fi Aware peer-to-peer ranging. @param\ncallback The same callback used for enabling responder. @throws\nIllegalArgumentException If {@code callback} is null.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/RttManager.java",
          "line": 1083
        },
        {
          "method_name": "android.net.wifi.WifiScanner.startBackgroundScan",
          "documentation": "@param settings specifies various parameters for the scan; for more\ninformation look at {@link ScanSettings} @param workSource WorkSource to blame\nfor power usage @param listener specifies the object to report events to. This\nobject is also treated as a key for this scan, and must also be specified to\ncancel the scan. Multiple scans should also not share this object.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiScanner.java",
          "line": 778
        },
        {
          "method_name": "android.net.wifi.WifiScanner.stopBackgroundScan",
          "documentation": "stop an ongoing wifi scan @param listener specifies which scan to cancel; must\nbe same object as passed in {@link #startBackgroundScan}\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiScanner.java",
          "line": 796
        },
        {
          "method_name": "android.net.wifi.WifiScanner.getScanResults",
          "documentation": "reports currently available scan results on appropriate listeners @return true\nif all scan results were reported correctly\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiScanner.java",
          "line": 808
        },
        {
          "method_name": "android.net.wifi.WifiScanner.startScan",
          "documentation": "starts a single scan and reports results asynchronously @param settings\nspecifies various parameters for the scan; for more information look at {@link\nScanSettings} @param workSource WorkSource to blame for power usage @param\nlistener specifies the object to report events to. This object is also treated\nas a key for this scan, and must also be specified to cancel the scan.\nMultiple scans should also not share this object.\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiScanner.java",
          "line": 837
        },
        {
          "method_name": "android.net.wifi.WifiScanner.stopScan",
          "documentation": "stops an ongoing single shot scan; only useful after {@link #startScan} if\nonResults() hasn't been called on the listener, ignored otherwise @param\nlistener\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiScanner.java",
          "line": 854
        },
        {
          "method_name": "android.net.wifi.rtt.WifiRttManager.startRanging",
          "documentation": "Initiate a request to range to a set of devices specified in the {@link\nRangingRequest}. Results will be returned in the {@link RangingResultCallback}\nset of callbacks. @param workSource A mechanism to specify an alternative\nwork-source for the request. @param request A request specifying a set of\ndevices whose distance measurements are requested. @param executor The\nExecutor on which to run the callback. @param callback A callback for the\nresult of the ranging request. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/rtt/WifiRttManager.java",
          "line": 133
        },
        {
          "method_name": "android.net.wifi.rtt.WifiRttManager.cancelRanging",
          "documentation": "Cancel all ranging requests for the specified work sources. The requests have\nbeen requested using {@link #startRanging(WorkSource, RangingRequest,\nExecutor, RangingResultCallback)}. @param workSource The work-sources of the\nrequesters. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/rtt/WifiRttManager.java",
          "line": 179
        }
      ]
    },
    "android.permission.ACCESS_MOCK_LOCATION": {
      "name": "android.permission.ACCESS_MOCK_LOCATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.INTERNET": {
      "name": "android.permission.INTERNET",
      "label": "b\u00e9n\u00e9ficier d'un acc\u00e8s complet au r\u00e9seau",
      "label_ptr": "permlab_createNetworkSockets",
      "description": "Permet \u00e0 l'application de cr\u00e9er des sockets r\u00e9seau et d'utiliser des protocoles r\u00e9seau personnalis\u00e9s. Le navigateur et d'autres applications permettent d'envoyer des donn\u00e9es sur Internet. Cette autorisation n'est donc pas n\u00e9cessaire pour envoyer des donn\u00e9es sur Internet.",
      "description_ptr": "permdesc_createNetworkSockets",
      "permission_group": "",
      "protection_level": "normal|instant"
    },
    "android.permission.ACCESS_NETWORK_STATE": {
      "name": "android.permission.ACCESS_NETWORK_STATE",
      "label": "afficher les connexions r\u00e9seau",
      "label_ptr": "permlab_accessNetworkState",
      "description": "Permet \u00e0 l'application d'acc\u00e9der \u00e0 des informations sur les connexions r\u00e9seau, comme les r\u00e9seaux existants et connect\u00e9s.",
      "description_ptr": "permdesc_accessNetworkState",
      "permission_group": "",
      "protection_level": "normal|instant",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.getNetworkPreference",
          "documentation": "Retrieves the current preferred network type. @return an integer representing\nthe preferred network type @deprecated Functionality has been removed as it no\nlonger makes sense, with many more than two networks - we'd need an array to\nexpress preference. Instead we use dynamic network properties of the networks\nto describe their precedence.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 934
        },
        {
          "method_name": "android.net.ConnectivityManager.getActiveNetworkInfo",
          "documentation": "Returns details about the currently active default data network. When\nconnected, this network is the default route for outgoing connections. You\nshould always check {@link NetworkInfo#isConnected()} before initiating\nnetwork traffic. This may return {@code null} when there is no default\nnetwork. Note that if the default network is a VPN, this method will return\nthe NetworkInfo for one of its underlying networks instead, or null if the VPN\nagent did not specify any. Apps interested in learning about VPNs should use\n{@link #getNetworkInfo(android.net.Network)} instead. @return a {@link\nNetworkInfo} object for the current default network or {@code null} if no\ndefault network is currently active @deprecated See {@link NetworkInfo}.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 956
        },
        {
          "method_name": "android.net.ConnectivityManager.getActiveNetwork",
          "documentation": "Returns a {@link Network} object corresponding to the currently active default\ndata network. In the event that the current active default data network\ndisconnects, the returned {@code Network} object will no longer be usable.\nThis will return {@code null} when there is no default network. @return a\n{@link Network} object for the current default network or {@code null} if no\ndefault network is currently active\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 976
        },
        {
          "method_name": "android.net.ConnectivityManager.getNetworkInfo",
          "documentation": "Returns connection status information about a particular Network. @param\nnetwork {@link Network} specifying which network in which you're interested.\n@return a {@link NetworkInfo} object for the requested network or {@code null}\nif the {@code Network} is not valid. @deprecated See {@link NetworkInfo}.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1183
        },
        {
          "method_name": "android.net.ConnectivityManager.getAllNetworkInfo",
          "documentation": "Returns connection status information about all network types supported by the\ndevice. @return an array of {@link NetworkInfo} objects. Check each {@link\nNetworkInfo#getType} for which type each applies. @deprecated This method does\nnot support multiple connected networks of the same type. Use {@link\n#getAllNetworks} and {@link #getNetworkInfo(android.net.Network)} instead.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1210
        },
        {
          "method_name": "android.net.ConnectivityManager.getNetworkForType",
          "documentation": "Returns the {@link Network} object currently serving a given type, or null if\nthe given type is not connected. @hide @deprecated This method does not\nsupport multiple connected networks of the same type. Use {@link\n#getAllNetworks} and {@link #getNetworkInfo(android.net.Network)} instead.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1230
        },
        {
          "method_name": "android.net.ConnectivityManager.getAllNetworks",
          "documentation": "Returns an array of all {@link Network} currently tracked by the framework.\n@return an array of {@link Network} objects.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1246
        },
        {
          "method_name": "android.net.ConnectivityManager.getActiveLinkProperties",
          "documentation": "Returns the IP information for the current default network. @return a {@link\nLinkProperties} object describing the IP info for the current default network,\nor {@code null} if there is no current default network. {@hide} @deprecated\nplease use {@link #getLinkProperties(Network)} on the return value of {@link\n#getActiveNetwork()} instead. In particular, this method will return non-null\nLinkProperties even if the app is blocked by policy from using this network.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1283
        },
        {
          "method_name": "android.net.ConnectivityManager.getLinkProperties",
          "documentation": "Get the {@link LinkProperties} for the given {@link Network}. This will return\n{@code null} if the network is unknown. @param network The {@link Network}\nobject identifying the network in question. @return The {@link LinkProperties}\nfor the network, or {@code null}.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1325
        },
        {
          "method_name": "android.net.ConnectivityManager.getNetworkCapabilities",
          "documentation": "Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.\nThis will return {@code null} if the network is unknown. @param network The\n{@link Network} object identifying the network in question. @return The {@link\nandroid.net.NetworkCapabilities} for the network, or {@code null}.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1342
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetherableIfaces",
          "documentation": "Get the set of tetherable, available interfaces. This list is limited by\ndevice configuration and current interface existence. @return an array of 0 or\nmore Strings of tetherable interface names. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2337
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetheredIfaces",
          "documentation": "Get the set of tethered interfaces. @return an array of 0 or more String of\ncurrently tethered interface names. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2354
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetheringErroredIfaces",
          "documentation": "Get the set of interface names which attempted to tether but failed. Re-\nattempting to tether may cause them to reset to the Tethered state.\nAlternatively, causing the interface to be destroyed and recreated may cause\nthem to reset to the available state. {@link\nConnectivityManager#getLastTetherError} can be used to get more information on\nthe cause of the errors. @return an array of 0 or more String indicating the\ninterface names which failed to tether. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2377
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetherableUsbRegexs",
          "documentation": "Get the list of regular expressions that define any tetherable USB network\ninterfaces. If USB tethering is not supported by the device, this list should\nbe empty. @return an array of 0 or more regular expression Strings defining\nwhat interfaces are considered tetherable usb interfaces. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2695
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetherableWifiRegexs",
          "documentation": "Get the list of regular expressions that define any tetherable Wifi network\ninterfaces. If Wifi tethering is not supported by the device, this list should\nbe empty. @return an array of 0 or more regular expression Strings defining\nwhat interfaces are considered tetherable wifi interfaces. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2715
        },
        {
          "method_name": "android.net.ConnectivityManager.getTetherableBluetoothRegexs",
          "documentation": "Get the list of regular expressions that define any tetherable Bluetooth\nnetwork interfaces. If Bluetooth tethering is not supported by the device,\nthis list should be empty. @return an array of 0 or more regular expression\nStrings defining what interfaces are considered tetherable bluetooth\ninterfaces. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2735
        },
        {
          "method_name": "android.net.ConnectivityManager.getLastTetherError",
          "documentation": "Get a more detailed error code after a Tethering or Untethering request\nasynchronously failed. @param iface The name of the interface of interest\n@return error The error code of the last error tethering or untethering the\nnamed interface {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2815
        },
        {
          "method_name": "android.net.ConnectivityManager.isNetworkSupported",
          "documentation": "Returns true if the hardware supports the given network type else it returns\nfalse. This doesn't indicate we have coverage or are authorized onto a\nnetwork, just whether or not the hardware supports it. For example a GSM phone\nwithout a SIM should still return {@code true} for mobile data, but a wifi\nonly tablet would return {@code false}. @param networkType The network type\nwe'd like to check @return {@code true} if supported, else {@code false}\n@deprecated Types are deprecated. Use {@link NetworkCapabilities} instead.\n@hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3046
        },
        {
          "method_name": "android.net.ConnectivityManager.isActiveNetworkMetered",
          "documentation": "Returns if the currently active data network is metered. A network is\nclassified as metered when the user is sensitive to heavy data usage on that\nconnection due to monetary costs, data limitations or battery/performance\nissues. You should check this before doing large data transfers, and warn the\nuser or delay the operation until another network is available. @return {@code\ntrue} if large transfers should be avoided, otherwise {@code false}.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3066
        },
        {
          "method_name": "android.net.ConnectivityManager.registerNetworkCallback",
          "documentation": "Registers a PendingIntent to be sent when a network is available which\nsatisfies the given {@link NetworkRequest}. This function behaves identically\nto the version that takes a NetworkCallback, but instead of {@link\nNetworkCallback} a {@link PendingIntent} is used. This means the request may\noutlive the calling application and get called back when a suitable network is\nfound.\n\nThe operation is an Intent broadcast that goes to a broadcast receiver that\nyou registered with {@link Context#registerReceiver} or through the <receiver>\ntag in an AndroidManifest.xml file\n\nThe operation Intent is delivered with two extras, a {@link Network} typed\nextra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest} typed extra\ncalled {@link #EXTRA_NETWORK_REQUEST} containing the original requests\nparameters.\n\nIf there is already a request for this Intent registered (with the equality of\ntwo Intents defined by {@link Intent#filterEquals}), then it will be removed\nand replaced by this one, effectively releasing the previous {@link\nNetworkRequest}.\n\nThe request may be released normally by calling {@link\n#unregisterNetworkCallback(android.app.PendingIntent)}. @param request {@link\nNetworkRequest} describing this request. @param operation Action to perform\nwhen the network is available (corresponds to the {@link\nNetworkCallback#onAvailable} call. Typically comes from {@link\nPendingIntent#getBroadcast}. Cannot be null.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3918
        },
        {
          "method_name": "android.net.ConnectivityManager.registerDefaultNetworkCallback",
          "documentation": "Registers to receive notifications about changes in the system default\nnetwork. The callbacks will continue to be called until either the application\nexits or {@link #unregisterNetworkCallback(NetworkCallback)} is called. @param\nnetworkCallback The {@link NetworkCallback} that the system will call as the\nsystem default network changes. @param handler {@link Handler} to specify the\nthread upon which the callback will be invoked.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3955
        },
        {
          "method_name": "android.net.ConnectivityManager.getMultipathPreference",
          "documentation": "Provides a hint to the calling application on whether it is desirable to use\nthe multinetwork APIs (e.g., {@link Network#openConnection}, {@link\nNetwork#bindSocket}, etc.) for multipath data transfer on this network when it\nis not the system default network. Applications desiring to use multipath\nnetwork protocols should call this method before each such operation. @param\nnetwork The network on which the application desires to use multipath data. If\n{@code null}, this method will return the a preference that will generally\napply to metered networks. @return a bitwise OR of zero or more of the {@code\nMULTIPATH_PREFERENCE_*} constants.\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 4224
        },
        {
          "method_name": "android.telephony.TelephonyManager.isDataEnabled",
          "documentation": "Returns whether mobile data is enabled or not per user setting. There are\nother factors that could disable mobile data, but they are not considered\nhere. If this object has been created with {@link #createForSubscriptionId},\napplies to the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires one of the following permissions: {@link\nandroid.Manifest.permission#ACCESS_NETWORK_STATE}, {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}).\n\nNote that this does not take into account any data restrictions that may be\npresent on the calling app. Such restrictions may be inspected with {@link\nConnectivityManager#getRestrictBackgroundStatus}. @return true if mobile data\nis enabled.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8146
        },
        {
          "method_name": "android.telephony.TelephonyManager.isDataRoamingEnabled",
          "documentation": "Returns whether mobile data roaming is enabled on the subscription.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires one of the following permissions: {@link\nandroid.Manifest.permission#ACCESS_NETWORK_STATE}, {@link\nandroid.Manifest.permission#READ_PHONE_STATE} or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}). @return {@code true}\nif the data roaming is enabled on the subscription, otherwise return {@code\nfalse}.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8166
        }
      ]
    },
    "android.permission.ACCESS_WIFI_STATE": {
      "name": "android.permission.ACCESS_WIFI_STATE",
      "label": "afficher les connexions Wi-Fi",
      "label_ptr": "permlab_accessWifiState",
      "description": "Permet \u00e0 l'application d'acc\u00e9der \u00e0 des informations sur les r\u00e9seaux Wi-Fi afin de savoir si une connexion Wi-Fi est activ\u00e9e et pour conna\u00eetre le nom des appareils connect\u00e9s au Wi-Fi, par exemple.",
      "description_ptr": "permdesc_accessWifiState",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.net.wifi.WifiManager.getWifiApState",
          "documentation": "Gets the Wi-Fi enabled state. @return One of {@link #WIFI_AP_STATE_DISABLED},\n{@link #WIFI_AP_STATE_DISABLING}, {@link #WIFI_AP_STATE_ENABLED}, {@link\n#WIFI_AP_STATE_ENABLING}, {@link #WIFI_AP_STATE_FAILED} @see\n#isWifiApEnabled() @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2131
        },
        {
          "method_name": "android.net.wifi.WifiManager.isWifiApEnabled",
          "documentation": "Return whether Wi-Fi AP is enabled or disabled. @return {@code true} if Wi-Fi\nAP is enabled @see #getWifiApState() @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2148
        },
        {
          "method_name": "android.net.wifi.WifiManager.getWifiApConfiguration",
          "documentation": "Gets the Wi-Fi AP Configuration. @return AP details in WifiConfiguration @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2160
        },
        {
          "method_name": "android.net.wifi.rtt.WifiRttManager.startRanging",
          "documentation": "Initiate a request to range to a set of devices specified in the {@link\nRangingRequest}. Results will be returned in the {@link RangingResultCallback}\nset of callbacks. @param workSource A mechanism to specify an alternative\nwork-source for the request. @param request A request specifying a set of\ndevices whose distance measurements are requested. @param executor The\nExecutor on which to run the callback. @param callback A callback for the\nresult of the ranging request. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/rtt/WifiRttManager.java",
          "line": 133
        }
      ]
    },
    "android.permission.CHANGE_WIFI_STATE": {
      "name": "android.permission.CHANGE_WIFI_STATE",
      "label": "Activer/d\u00e9sactiver la connexion Wi-Fi",
      "label_ptr": "permlab_changeWifiState",
      "description": "Permet \u00e0 l'application de se connecter \u00e0 des points d'acc\u00e8s\u00a0Wi-Fi, de s'en d\u00e9connecter et de modifier la configuration de l'appareil pour les r\u00e9seaux\u00a0Wi-Fi.",
      "description_ptr": "permdesc_changeWifiState",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.net.wifi.WifiManager.setWifiApConfiguration",
          "documentation": "Sets the Wi-Fi AP Configuration. The AP configuration must either be open or\nWPA2 PSK networks. @return {@code true} if the operation succeeded, {@code\nfalse} otherwise @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2177
        },
        {
          "method_name": "android.net.wifi.rtt.WifiRttManager.startRanging",
          "documentation": "Initiate a request to range to a set of devices specified in the {@link\nRangingRequest}. Results will be returned in the {@link RangingResultCallback}\nset of callbacks. @param workSource A mechanism to specify an alternative\nwork-source for the request. @param request A request specifying a set of\ndevices whose distance measurements are requested. @param executor The\nExecutor on which to run the callback. @param callback A callback for the\nresult of the ranging request. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/rtt/WifiRttManager.java",
          "line": 133
        }
      ]
    },
    "android.permission.MANAGE_IPSEC_TUNNELS": {
      "name": "android.permission.MANAGE_IPSEC_TUNNELS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|appop",
      "methods": [
        {
          "method_name": "android.net.IpSecManager.createIpSecTunnelInterface",
          "documentation": "Create a new IpSecTunnelInterface as a local endpoint for tunneled IPsec\ntraffic.\n\nAn application that creates tunnels is responsible for cleaning up the tunnel\nwhen the underlying network goes away, and the onLost() callback is received.\n@param localAddress The local addres of the tunnel @param remoteAddress The\nlocal addres of the tunnel @param underlyingNetwork the {@link Network} that\nwill carry traffic for this tunnel. This network should almost certainly be a\nnetwork such as WiFi with an L2 address. @return a new {@link\nIpSecManager#IpSecTunnelInterface} with the specified properties @throws\nIOException indicating that the socket could not be opened or bound @throws\nResourceUnavailableException indicating that too many encapsulation sockets\nare open @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecManager.java",
          "line": 885
        },
        {
          "method_name": "android.net.IpSecManager.applyTunnelModeTransform",
          "documentation": "Apply an active Tunnel Mode IPsec Transform to a {@link IpSecTunnelInterface},\nwhich will tunnel all traffic for the given direction through the underlying\nnetwork's interface with IPsec (applies an outer IP header and IPsec Header to\nall traffic, and expects an additional IP header and IPsec Header on all\ninbound traffic).\n\nApplications should probably not use this API directly. @param tunnel The\n{@link IpSecManager#IpSecTunnelInterface} that will use the supplied\ntransform. @param direction the direction, {@link DIRECTION_OUT} or {@link\n#DIRECTION_IN} in which the transform will be used. @param transform an {@link\nIpSecTransform} created in tunnel mode @throws IOException indicating that the\ntransform could not be applied due to a lower layer failure. @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecManager.java",
          "line": 914
        },
        {
          "method_name": "android.net.IpSecTransform.startNattKeepalive",
          "documentation": "Start a NAT-T keepalive session for the current transform. For a transform\nthat is using UDP encapsulated IPv4, NAT-T offloading provides a power\nefficient mechanism of sending NAT-T packets at a specified interval. @param\nuserCallback a {@link #NattKeepaliveCallback} to receive asynchronous status\ninformation about the requested NAT-T keepalive session. @param\nintervalSeconds the interval between NAT-T keepalives being sent. The the\nallowed range is between 20 and 3600 seconds. @param handler a handler on\nwhich to post callbacks when received. @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecTransform.java",
          "line": 291
        },
        {
          "method_name": "android.net.IpSecTransform.stopNattKeepalive",
          "documentation": "Stop an ongoing NAT-T keepalive session. Calling this API will request that an\nongoing NAT-T keepalive session be terminated. If this API is not called when\na Transform is closed, the underlying NAT-T session will be terminated\nautomatically. @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecTransform.java",
          "line": 333
        }
      ]
    },
    "android.permission.MANAGE_TEST_NETWORKS": {
      "name": "android.permission.MANAGE_TEST_NETWORKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_WIFI_CREDENTIAL": {
      "name": "android.permission.READ_WIFI_CREDENTIAL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.wifi.WifiManager.getPrivilegedConfiguredNetworks",
          "documentation": "\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 1042
        }
      ]
    },
    "android.permission.TETHER_PRIVILEGED": {
      "name": "android.permission.TETHER_PRIVILEGED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.isTetheringSupported",
          "documentation": "Check if the device allows for tethering. It may be disabled via {@code\nro.tether.denied} system property, Settings.TETHER_SUPPORTED or due to device\nconfiguration.\n\nIf this app does not have permission to use this API, it will always return\nfalse rather than throw an exception.\n\nIf the device has a hotspot provisioning app, the caller is required to hold\nthe {@link android.Manifest.permission.TETHER_PRIVILEGED} permission.\n\nOtherwise, this method requires the caller to hold the ability to modify\nsystem settings as determined by {@link\nandroid.provider.Settings.System#canWrite}.\n\n@return a boolean - {@code true} indicating Tethering is supported. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2484
        },
        {
          "method_name": "android.net.ConnectivityManager.startTethering",
          "documentation": "Runs tether provisioning for the given type if needed and then starts\ntethering if the check succeeds. If no carrier provisioning is required for\ntethering, tethering is enabled immediately. If provisioning fails, tethering\nwill not be enabled. It also schedules tether provisioning re-checks if\nappropriate. @param type The type of tethering to start. Must be one of {@link\nConnectivityManager.TETHERING_WIFI}, {@link\nConnectivityManager.TETHERING_USB}, or {@link\nConnectivityManager.TETHERING_BLUETOOTH}. @param showProvisioningUi a boolean\nindicating to show the provisioning app UI if there is one. This should be\ntrue the first time this function is called and also any time the user can see\nthis UI. It gives users information from their carrier about the check failing\nand how they can sign up for tethering if possible. @param callback an {@link\nOnStartTetheringCallback} which will be called to notify the caller of the\nresult of trying to tether. @param handler {@link Handler} to specify the\nthread upon which the callback will be invoked. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2548
        },
        {
          "method_name": "android.net.ConnectivityManager.stopTethering",
          "documentation": "Stops tethering for the given type. Also cancels any provisioning rechecks for\nthat type if applicable. @param type The type of tethering to stop. Must be\none of {@link ConnectivityManager.TETHERING_WIFI}, {@link\nConnectivityManager.TETHERING_USB}, or {@link\nConnectivityManager.TETHERING_BLUETOOTH}. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2585
        },
        {
          "method_name": "android.net.ConnectivityManager.registerTetheringEventCallback",
          "documentation": "Start listening to tethering change events. Any new added callback will\nreceive the last tethering status right away. If callback is registered when\ntethering has no upstream or disabled, {@link\nOnTetheringEventCallback#onUpstreamChanged} will immediately be called with a\nnull argument. The same callback object cannot be registered twice. @param\nexecutor the executor on which callback will be invoked. @param callback the\ncallback to be called when tethering has change events. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2630
        },
        {
          "method_name": "android.net.ConnectivityManager.unregisterTetheringEventCallback",
          "documentation": "Remove tethering event callback previously registered with {@link\n#registerTetheringEventCallback}. @param callback previously registered\ncallback. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2667
        },
        {
          "method_name": "android.net.ConnectivityManager.getLatestTetheringEntitlementResult",
          "documentation": "Get the last value of the entitlement check on this downstream. If the cached\nvalue is {@link #TETHER_ERROR_NO_ERROR} or showEntitlementUi argument is\nfalse, it just return the cached value. Otherwise, a UI-based entitlement\ncheck would be performed. It is not guaranteed that the UI-based entitlement\ncheck will complete in any specific time period and may in fact never\ncomplete. Any successful entitlement check the platform performs for any\nreason will update the cached value. @param type the downstream type of\ntethering. Must be one of {@link #TETHERING_WIFI}, {@link #TETHERING_USB}, or\n{@link #TETHERING_BLUETOOTH}. @param showEntitlementUi a boolean indicating\nwhether to run UI-based entitlement check. @param executor the executor on\nwhich callback will be invoked. @param listener an {@link\nOnTetheringEntitlementResultListener} which will be called to notify the\ncaller of the result of entitlement check. The listener may be called zero or\none time. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2872
        }
      ]
    },
    "android.permission.RECEIVE_WIFI_CREDENTIAL_CHANGE": {
      "name": "android.permission.RECEIVE_WIFI_CREDENTIAL_CHANGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.OVERRIDE_WIFI_CONFIG": {
      "name": "android.permission.OVERRIDE_WIFI_CONFIG",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_WIMAX_STATE": {
      "name": "android.permission.ACCESS_WIMAX_STATE",
      "label": "se connecter au r\u00e9seau WiMAX et s'en d\u00e9connecter",
      "label_ptr": "permlab_accessWimaxState",
      "description": "Permet \u00e0 l'application de d\u00e9terminer si le WiMAX est activ\u00e9 et d'obtenir des informations sur tous les r\u00e9seaux WiMAX connect\u00e9s.",
      "description_ptr": "permdesc_accessWimaxState",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.CHANGE_WIMAX_STATE": {
      "name": "android.permission.CHANGE_WIMAX_STATE",
      "label": "modifier l'\u00e9tat du WiMAX",
      "label_ptr": "permlab_changeWimaxState",
      "description": "Permet \u00e0 l'application de connecter le t\u00e9l\u00e9phone aux r\u00e9seaux WiMAX et de l'en d\u00e9connecter.",
      "description_ptr": "permdesc_changeWimaxState",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SCORE_NETWORKS": {
      "name": "android.permission.SCORE_NETWORKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.NetworkScoreManager.getActiveScorerPackage",
          "documentation": "Obtain the package name of the current active network scorer.\n\nAt any time, only one scorer application will receive {@link\n#ACTION_SCORE_NETWORKS} broadcasts and be allowed to call {@link\n#updateScores}. Applications may use this method to determine the current\nscorer and offer the user the ability to select a different scorer via the\n{@link #ACTION_CHANGE_ACTIVE} intent. @return the full package name of the\ncurrent active scorer, or null if there is no active scorer. @throws\nSecurityException if the caller doesn't hold either {@link\npermission#SCORE_NETWORKS} or {@link permission#REQUEST_NETWORK_SCORES}\npermissions.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 234
        },
        {
          "method_name": "android.net.NetworkScoreManager.updateScores",
          "documentation": "Update network scores.\n\nThis may be called at any time to re-score active networks. Scores will\ngenerally be updated quickly, but if this method is called too frequently, the\nscores may be held and applied at a later time. @param networks the networks\nwhich have been scored by the scorer. @return whether the update was\nsuccessful. @throws SecurityException if the caller is not the active scorer.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 288
        },
        {
          "method_name": "android.net.NetworkScoreManager.clearScores",
          "documentation": "Clear network scores.\n\nShould be called when all scores need to be invalidated, i.e. because the\nscoring algorithm has changed and old scores can no longer be compared to\nfuture scores.\n\nNote that scores will be cleared automatically when the active scorer changes,\nas scores from one scorer cannot be compared to those from another scorer.\n@return whether the clear was successful. @throws SecurityException if the\ncaller is not the active scorer or if the caller doesn't hold the {@link\npermission#REQUEST_NETWORK_SCORES} permission.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 311
        },
        {
          "method_name": "android.net.NetworkScoreManager.setActiveScorer",
          "documentation": "Set the active scorer to a new package and clear existing scores.\n\nShould never be called directly without obtaining user consent. This can be\ndone by using the {@link #ACTION_CHANGE_ACTIVE} broadcast, or using a custom\nconfiguration activity. @return true if the operation succeeded, or false if\nthe new package is not a valid scorer. @throws SecurityException if the caller\ndoesn't hold either {@link permission#SCORE_NETWORKS} or {@link\npermission#REQUEST_NETWORK_SCORES} permissions. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 333
        },
        {
          "method_name": "android.net.NetworkScoreManager.disableScoring",
          "documentation": "Turn off network scoring.\n\nMay only be called by the current scorer app, or the system. @throws\nSecurityException if the caller is not the active scorer or if the caller\ndoesn't hold the {@link permission#REQUEST_NETWORK_SCORES} permission.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 351
        }
      ]
    },
    "android.permission.REQUEST_NETWORK_SCORES": {
      "name": "android.permission.REQUEST_NETWORK_SCORES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|setup",
      "methods": [
        {
          "method_name": "android.net.NetworkScoreManager.getActiveScorerPackage",
          "documentation": "Obtain the package name of the current active network scorer.\n\nAt any time, only one scorer application will receive {@link\n#ACTION_SCORE_NETWORKS} broadcasts and be allowed to call {@link\n#updateScores}. Applications may use this method to determine the current\nscorer and offer the user the ability to select a different scorer via the\n{@link #ACTION_CHANGE_ACTIVE} intent. @return the full package name of the\ncurrent active scorer, or null if there is no active scorer. @throws\nSecurityException if the caller doesn't hold either {@link\npermission#SCORE_NETWORKS} or {@link permission#REQUEST_NETWORK_SCORES}\npermissions.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 234
        },
        {
          "method_name": "android.net.NetworkScoreManager.getActiveScorer",
          "documentation": "Returns metadata about the active scorer or `null` if there is no active\nscorer. @throws SecurityException if the caller does not hold the {@link\npermission#REQUEST_NETWORK_SCORES} permission. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 251
        },
        {
          "method_name": "android.net.NetworkScoreManager.getAllValidScorers",
          "documentation": "Returns the list of available scorer apps. The list will be empty if there are\nno valid scorers. @throws SecurityException if the caller does not hold the\n{@link permission#REQUEST_NETWORK_SCORES} permission. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 268
        },
        {
          "method_name": "android.net.NetworkScoreManager.clearScores",
          "documentation": "Clear network scores.\n\nShould be called when all scores need to be invalidated, i.e. because the\nscoring algorithm has changed and old scores can no longer be compared to\nfuture scores.\n\nNote that scores will be cleared automatically when the active scorer changes,\nas scores from one scorer cannot be compared to those from another scorer.\n@return whether the clear was successful. @throws SecurityException if the\ncaller is not the active scorer or if the caller doesn't hold the {@link\npermission#REQUEST_NETWORK_SCORES} permission.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 311
        },
        {
          "method_name": "android.net.NetworkScoreManager.setActiveScorer",
          "documentation": "Set the active scorer to a new package and clear existing scores.\n\nShould never be called directly without obtaining user consent. This can be\ndone by using the {@link #ACTION_CHANGE_ACTIVE} broadcast, or using a custom\nconfiguration activity. @return true if the operation succeeded, or false if\nthe new package is not a valid scorer. @throws SecurityException if the caller\ndoesn't hold either {@link permission#SCORE_NETWORKS} or {@link\npermission#REQUEST_NETWORK_SCORES} permissions. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 333
        },
        {
          "method_name": "android.net.NetworkScoreManager.disableScoring",
          "documentation": "Turn off network scoring.\n\nMay only be called by the current scorer app, or the system. @throws\nSecurityException if the caller is not the active scorer or if the caller\ndoesn't hold the {@link permission#REQUEST_NETWORK_SCORES} permission.\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 351
        },
        {
          "method_name": "android.net.NetworkScoreManager.requestScores",
          "documentation": "Request scoring for networks. @return true if the broadcast was sent, or false\nif there is no active scorer. @throws SecurityException if the caller does not\nhold the {@link permission#REQUEST_NETWORK_SCORES} permission. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 368
        },
        {
          "method_name": "android.net.NetworkScoreManager.registerNetworkScoreCache",
          "documentation": "Register a network score cache. @param networkType the type of network this\ncache can handle. See {@link NetworkKey#type} @param scoreCache implementation\nof {@link INetworkScoreCache} to store the scores @param filterType the {@link\nCacheUpdateFilter} to apply @throws SecurityException if the caller does not\nhold the {@link permission#REQUEST_NETWORK_SCORES} permission. @throws\nIllegalArgumentException if a score cache is already registered for this type.\n@hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 405
        },
        {
          "method_name": "android.net.NetworkScoreManager.unregisterNetworkScoreCache",
          "documentation": "Unregister a network score cache. @param networkType the type of network this\ncache can handle. See {@link NetworkKey#type}. @param scoreCache\nimplementation of {@link INetworkScoreCache} to store the scores. @throws\nSecurityException if the caller does not hold the {@link\npermission#REQUEST_NETWORK_SCORES} permission. @throws\nIllegalArgumentException if a score cache is already registered for this type.\n@hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 425
        },
        {
          "method_name": "android.net.NetworkScoreManager.isCallerActiveScorer",
          "documentation": "Determine whether the application with the given UID is the enabled scorer.\n@param callingUid the UID to check @return true if the provided UID is the\nactive scorer, false otherwise. @throws SecurityException if the caller does\nnot hold the {@link permission#REQUEST_NETWORK_SCORES} permission. @hide\n\n",
          "file": "./aosp/core/java/android/net/NetworkScoreManager.java",
          "line": 443
        }
      ]
    },
    "android.permission.NETWORK_STACK": {
      "name": "android.permission.NETWORK_STACK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.setAirplaneMode",
          "documentation": "Set the value for enabling/disabling airplane mode @param enable whether to\nenable airplane mode or not @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3151
        },
        {
          "method_name": "android.net.ConnectivityManager.setAcceptPartialConnectivity",
          "documentation": "Informs the system whether it should consider the network as validated even if\nit only has partial connectivity. If {@code accept} is true, then the network\nwill be considered as validated even if connectivity is only partial. If\n{@code always} is true, then the choice is remembered, so that the next time\nthe user connects to this network, the system will switch to it. @param\nnetwork The network to accept. @param accept Whether to consider the network\nas validated even if it has partial connectivity. @param always Whether to\nremember this choice in the future. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 4086
        },
        {
          "method_name": "android.net.ConnectivityManager.shouldAvoidBadWifi",
          "documentation": "Determine whether the device is configured to avoid bad wifi. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 4157
        }
      ]
    },
    "android.permission.NETWORK_SETTINGS": {
      "name": "android.permission.NETWORK_SETTINGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.setAirplaneMode",
          "documentation": "Set the value for enabling/disabling airplane mode @param enable whether to\nenable airplane mode or not @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3151
        },
        {
          "method_name": "android.net.ConnectivityManager.setAcceptUnvalidated",
          "documentation": "Informs the system whether it should switch to {@code network} regardless of\nwhether it is validated or not. If {@code accept} is true, and the network was\nexplicitly selected by the user (e.g., by selecting a Wi-Fi network in the\nSettings app), then the network will become the system default network\nregardless of any other network that's currently connected. If {@code always}\nis true, then the choice is remembered, so that the next time the user\nconnects to this network, the system will switch to it. @param network The\nnetwork to accept. @param accept Whether to accept the network even if\nunvalidated. @param always Whether to remember this choice in the future.\n@hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 4063
        },
        {
          "method_name": "android.net.ConnectivityManager.setAvoidUnvalidated",
          "documentation": "Informs the system to penalize {@code network}'s score when it becomes\nunvalidated. This is only meaningful if the system is configured not to\npenalize such networks, e.g., if the {@code config_networkAvoidBadWifi}\nconfiguration variable is set to 0 and the {@code NETWORK_AVOID_BAD_WIFI\nsetting is unset}. @param network The network to accept. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 4105
        },
        {
          "method_name": "android.net.wifi.WifiManager.notifyUserOfApBandConversion",
          "documentation": "Method that triggers a notification to the user about a conversion to their\nsaved AP config. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2191
        },
        {
          "method_name": "android.net.wifi.WifiManager.registerSoftApCallback",
          "documentation": "Registers a callback for Soft AP. See {@link SoftApCallback}. Caller will\nreceive the current soft AP state and number of connected devices immediately\nafter a successful call to this API via callback. Note that receiving an\nimmediate WIFI_AP_STATE_FAILED value for soft AP state indicates that the\nlatest attempt to start soft AP has failed. Caller can unregister a previously\nregistered callback using {@link unregisterSoftApCallback}\n\nApplications should have the {@link\nandroid.Manifest.permission#NETWORK_SETTINGS NETWORK_SETTINGS} permission.\nCallers without the permission will trigger a {@link\njava.lang.SecurityException}.\n\n@param callback Callback for soft AP events @param handler The Handler on\nwhose thread to execute the callbacks of the {@code callback} object. If null,\nthen the application's main thread will be used. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2513
        },
        {
          "method_name": "android.net.wifi.WifiManager.unregisterSoftApCallback",
          "documentation": "Allow callers to unregister a previously registered callback. After calling\nthis method, applications will no longer receive soft AP events. @param\ncallback Callback to unregister for soft AP events @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 2537
        },
        {
          "method_name": "android.net.wifi.WifiManager.enableVerboseLogging",
          "documentation": "Set wifi verbose log. Called from developer settings. @hide\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 3582
        }
      ]
    },
    "android.permission.NETWORK_SETUP_WIZARD": {
      "name": "android.permission.NETWORK_SETUP_WIZARD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|setup",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.setAirplaneMode",
          "documentation": "Set the value for enabling/disabling airplane mode @param enable whether to\nenable airplane mode or not @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 3151
        }
      ]
    },
    "android.permission.ACCESS_LOWPAN_STATE": {
      "name": "android.permission.ACCESS_LOWPAN_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CHANGE_LOWPAN_STATE": {
      "name": "android.permission.CHANGE_LOWPAN_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.READ_LOWPAN_CREDENTIAL": {
      "name": "android.permission.READ_LOWPAN_CREDENTIAL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_LOWPAN_INTERFACES": {
      "name": "android.permission.MANAGE_LOWPAN_INTERFACES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_WIFI_WHEN_PERMISSION_REVIEW_REQUIRED": {
      "name": "android.permission.MANAGE_WIFI_WHEN_PERMISSION_REVIEW_REQUIRED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.NETWORK_BYPASS_PRIVATE_DNS": {
      "name": "android.permission.NETWORK_BYPASS_PRIVATE_DNS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BLUETOOTH": {
      "name": "android.permission.BLUETOOTH",
      "label": "Associer \u00e0 appareils Bluetooth",
      "label_ptr": "permlab_bluetooth",
      "description": "Permet \u00e0 l'application d'acc\u00e9der \u00e0 la configuration du Bluetooth sur le t\u00e9l\u00e9phone, et d'\u00e9tablir et accepter des connexions avec les appareils associ\u00e9s.",
      "description_ptr": "permdesc_bluetooth",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.bluetooth.BluetoothA2dp.getActiveDevice",
          "documentation": "Get the connected device that is active.\n\nRequires {@link android.Manifest.permission#BLUETOOTH} permission. @return the\nconnected device that is active or null if no device is active @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothA2dp.java",
          "line": 423
        },
        {
          "method_name": "android.bluetooth.BluetoothA2dp.getPriority",
          "documentation": "Get the priority of the profile.\n\nThe priority can be any of: {@link #PRIORITY_AUTO_CONNECT}, {@link\n#PRIORITY_OFF}, {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED} @param\ndevice Bluetooth device @return priority of the device @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothA2dp.java",
          "line": 486
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.isEnabled",
          "documentation": "Return true if Bluetooth is currently enabled and ready for use.\n\nEquivalent to: `getBluetoothState() == STATE_ON` @return true if the local\nadapter is turned on\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 832
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getState",
          "documentation": "Get the current state of the local Bluetooth adapter.\n\nPossible return values are {@link #STATE_OFF}, {@link #STATE_TURNING_ON},\n{@link #STATE_ON}, {@link #STATE_TURNING_OFF}. @return current state of\nBluetooth adapter\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 984
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getLeState",
          "documentation": "Get the current state of the local Bluetooth adapter\n\nThis returns current internal state of Adapter including LE ON/OFF\n\nPossible return values are {@link #STATE_OFF}, {@link #STATE_BLE_TURNING_ON},\n{@link #STATE_BLE_ON}, {@link #STATE_TURNING_ON}, {@link #STATE_ON}, {@link\n#STATE_TURNING_OFF}, {@link #STATE_BLE_TURNING_OFF}. @return current state of\nBluetooth adapter @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1033
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getAddress",
          "documentation": "Returns the hardware address of the local Bluetooth adapter.\n\nFor example, \"00:11:22:AA:BB:CC\". @return Bluetooth hardware address as string\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1161
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getScanMode",
          "documentation": "Get the current Bluetooth scan mode of the local Bluetooth adapter.\n\nThe Bluetooth scan mode determines if the local adapter is connectable and/or\ndiscoverable from remote Bluetooth devices.\n\nPossible values are: {@link #SCAN_MODE_NONE}, {@link #SCAN_MODE_CONNECTABLE},\n{@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return {@link\n#SCAN_MODE_NONE}. After turning on Bluetooth, wait for {@link\n#ACTION_STATE_CHANGED} with {@link #STATE_ON} to get the updated value.\n@return scan mode\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1443
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.isDiscovering",
          "documentation": "Return true if the local Bluetooth adapter is currently in the device\ndiscovery process.\n\nDevice discovery is a heavyweight procedure. New connections to remote\nBluetooth devices should not be attempted while discovery is in progress, and\nexisting connections will experience limited bandwidth and high latency. Use\n{@link #cancelDiscovery()} to cancel an ongoing discovery.\n\nApplications can also register for {@link #ACTION_DISCOVERY_STARTED} or {@link\n#ACTION_DISCOVERY_FINISHED} to be notified when discovery starts or completes.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return false. After\nturning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED} with {@link\n#STATE_ON} to get the updated value. @return true if discovering\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1693
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getMaxConnectedAudioDevices",
          "documentation": "Get the maximum number of connected audio devices. @return the maximum number\nof connected audio devices @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1928
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getBondedDevices",
          "documentation": "Return the set of {@link BluetoothDevice} objects that are bonded (paired) to\nthe local adapter.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return an empty\nset. After turning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED} with\n{@link #STATE_ON} to get the updated value. @return unmodifiable set of {@link\nBluetoothDevice}, or null on error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2032
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getProfileConnectionState",
          "documentation": "Get the current connection state of a profile. This function can be used to\ncheck whether the local Bluetooth adapter is connected to any remote device\nfor a specific profile. Profile can be one of {@link\nBluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.\n\nReturn value can be one of {@link BluetoothProfile#STATE_DISCONNECTED}, {@link\nBluetoothProfile#STATE_CONNECTING}, {@link BluetoothProfile#STATE_CONNECTED},\n{@link BluetoothProfile#STATE_DISCONNECTING}\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2129
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingRfcommWithServiceRecord",
          "documentation": "Create a listening, secure RFCOMM Bluetooth socket with Service Record.\n\nA remote device connecting to this socket will be authenticated and\ncommunication on this socket will be encrypted.\n\nUse {@link BluetoothServerSocket#accept} to retrieve incoming connections from\na listening {@link BluetoothServerSocket}.\n\nThe system will assign an unused RFCOMM channel to listen on.\n\nThe system will also register a Service Discovery Protocol (SDP) record with\nthe local SDP server containing the specified UUID, service name, and auto-\nassigned channel. Remote Bluetooth devices can use the same UUID to query our\nSDP server and discover which channel to connect to. This SDP record will be\nremoved when this socket is closed, or if this application closes\nunexpectedly.\n\nUse {@link BluetoothDevice#createRfcommSocketToServiceRecord} to connect to\nthis socket from another device using the same {@link UUID}. @param name\nservice name for SDP record @param uuid uuid for SDP record @return a\nlistening RFCOMM BluetoothServerSocket @throws IOException on error, for\nexample Bluetooth not available, or insufficient permissions, or channel in\nuse.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2227
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingInsecureRfcommWithServiceRecord",
          "documentation": "Create a listening, insecure RFCOMM Bluetooth socket with Service Record.\n\nThe link key is not required to be authenticated, i.e the communication may be\nvulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices, the link\nwill be encrypted, as encryption is mandartory. For legacy devices (pre\nBluetooth 2.1 devices) the link will not be encrypted. Use {@link\n#listenUsingRfcommWithServiceRecord}, if an encrypted and authenticated\ncommunication channel is desired.\n\nUse {@link BluetoothServerSocket#accept} to retrieve incoming connections from\na listening {@link BluetoothServerSocket}.\n\nThe system will assign an unused RFCOMM channel to listen on.\n\nThe system will also register a Service Discovery Protocol (SDP) record with\nthe local SDP server containing the specified UUID, service name, and auto-\nassigned channel. Remote Bluetooth devices can use the same UUID to query our\nSDP server and discover which channel to connect to. This SDP record will be\nremoved when this socket is closed, or if this application closes\nunexpectedly.\n\nUse {@link BluetoothDevice#createRfcommSocketToServiceRecord} to connect to\nthis socket from another device using the same {@link UUID}. @param name\nservice name for SDP record @param uuid uuid for SDP record @return a\nlistening RFCOMM BluetoothServerSocket @throws IOException on error, for\nexample Bluetooth not available, or insufficient permissions, or channel in\nuse.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2259
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingL2capChannel",
          "documentation": "Create a secure L2CAP Connection-oriented Channel (CoC) {@link\nBluetoothServerSocket} and assign a dynamic protocol/service multiplexer (PSM)\nvalue. This socket can be used to listen for incoming connections. The\nsupported Bluetooth transport is LE only.\n\nA remote device connecting to this socket will be authenticated and\ncommunication on this socket will be encrypted.\n\nUse {@link BluetoothServerSocket#accept} to retrieve incoming connections from\na listening {@link BluetoothServerSocket}.\n\nThe system will assign a dynamic PSM value. This PSM value can be read from\nthe {@link BluetoothServerSocket#getPsm()} and this value will be released\nwhen this server socket is closed, Bluetooth is turned off, or the application\nexits unexpectedly.\n\nThe mechanism of disclosing the assigned dynamic PSM value to the initiating\npeer is defined and performed by the application.\n\nUse {@link BluetoothDevice#createL2capChannel(int)} to connect to this server\nsocket from another Android device that is given the PSM value. @return an\nL2CAP CoC BluetoothServerSocket @throws IOException on error, for example\nBluetooth not available, or insufficient permissions, or unable to start this\nCoC\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3065
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingL2capCoc",
          "documentation": "TODO: Remove this hidden method once all the SL4A and other tests are updated\nto use the new API name, listenUsingL2capChannel. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3094
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingInsecureL2capChannel",
          "documentation": "Create an insecure L2CAP Connection-oriented Channel (CoC) {@link\nBluetoothServerSocket} and assign a dynamic PSM value. This socket can be used\nto listen for incoming connections. The supported Bluetooth transport is LE\nonly.\n\nThe link key is not required to be authenticated, i.e the communication may be\nvulnerable to man-in-the-middle attacks. Use {@link #listenUsingL2capChannel},\nif an encrypted and authenticated communication channel is desired.\n\nUse {@link BluetoothServerSocket#accept} to retrieve incoming connections from\na listening {@link BluetoothServerSocket}.\n\nThe system will assign a dynamic protocol/service multiplexer (PSM) value.\nThis PSM value can be read from the {@link BluetoothServerSocket#getPsm()} and\nthis value will be released when this server socket is closed, Bluetooth is\nturned off, or the application exits unexpectedly.\n\nThe mechanism of disclosing the assigned dynamic PSM value to the initiating\npeer is defined and performed by the application.\n\nUse {@link BluetoothDevice#createInsecureL2capChannel(int)} to connect to this\nserver socket from another Android device that is given the PSM value. @return\nan L2CAP CoC BluetoothServerSocket @throws IOException on error, for example\nBluetooth not available, or insufficient permissions, or unable to start this\nCoC\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3123
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.listenUsingInsecureL2capCoc",
          "documentation": "TODO: Remove this hidden method once all the SL4A and other tests are updated\nto use the new API name, listenUsingInsecureL2capChannel. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3152
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getName",
          "documentation": "Get the friendly Bluetooth name of the remote device.\n\nThe local adapter will automatically retrieve remote names when performing a\ndevice scan, and will cache them. This method just returns the name for this\ndevice from the cache. @return the Bluetooth name, or null if there was a\nproblem.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1008
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getType",
          "documentation": "Get the Bluetooth device type of the remote device. @return the device type\n{@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link\n#DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1033
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getBatteryLevel",
          "documentation": "Get the most recent identified battery level of this Bluetooth device\n\nRequires {@link android.Manifest.permission#BLUETOOTH} @return Battery level\nin percents from 0 to 100, or {@link #BATTERY_LEVEL_UNKNOWN} if Bluetooth is\ndisabled, or device is disconnected, or does not have any battery reporting\nservice, or return value is invalid @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1123
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getBondState",
          "documentation": "Get the bond state of the remote device.\n\nPossible values for the bond state are: {@link #BOND_NONE}, {@link\n#BOND_BONDING}, {@link #BOND_BONDED}. @return the bond state\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1336
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.isConnected",
          "documentation": "Returns whether there is an open connection to this device.\n\nRequires {@link android.Manifest.permission#BLUETOOTH}. @return True if there\nis at least one open connection to this device. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1359
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.isEncrypted",
          "documentation": "Returns whether there is an open connection to this device that has been\nencrypted.\n\nRequires {@link android.Manifest.permission#BLUETOOTH}. @return True if there\nis at least one encrypted connection to this device. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1383
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getBluetoothClass",
          "documentation": "Get the Bluetooth class of the remote device. @return Bluetooth class object,\nor null on error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1403
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getUuids",
          "documentation": "Returns the supported features (UUIDs) of the remote device.\n\nThis method does not start a service discovery procedure to retrieve the UUIDs\nfrom the remote device. Instead, the local cached copy of the service UUIDs\nare returned.\n\nUse {@link #fetchUuidsWithSdp} if fresh UUIDs are desired. @return the\nsupported features (UUIDs) of the remote device, or null on error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1430
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.fetchUuidsWithSdp",
          "documentation": "Perform a service discovery on the remote device to get the UUIDs supported.\n\nThis API is asynchronous and {@link #ACTION_UUID} intent is sent, with the\nUUIDs supported by the remote end. If there is an error in getting the SDP\nrecords or if the process takes a long time, {@link #ACTION_UUID} intent is\nsent with the UUIDs that is currently present in the cache. Clients should use\nthe {@link #getUuids} to get UUIDs if service discovery is not to be\nperformed. @return False if the sanity check fails, True if the process of\ninitiating an ACL connection to the remote device was started.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1458
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createRfcommSocketToServiceRecord",
          "documentation": "Create an RFCOMM {@link BluetoothSocket} ready to start a secure outgoing\nconnection to this remote device using SDP lookup of uuid.\n\nThis is designed to be used with {@link\nBluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer Bluetooth\napplications.\n\nUse {@link BluetoothSocket#connect} to initiate the outgoing connection. This\nwill also perform an SDP lookup of the given uuid to determine which channel\nto connect to.\n\nThe remote device will be authenticated and communication on this socket will\nbe encrypted.\n\nUse this socket only if an authenticated socket link is possible.\nAuthentication refers to the authentication of the link key to prevent man-in-\nthe-middle type of attacks. For example, for Bluetooth 2.1 devices, if any of\nthe devices does not have an input and output capability or just has the\nability to display a numeric key, a secure socket connection is not possible.\nIn such a case, use {@link #createInsecureRfcommSocketToServiceRecord}. For\nmore details, refer to the Security Model section 5.2 (vol 3) of Bluetooth\nCore Specification version 2.1 + EDR.\n\nHint: If you are connecting to a Bluetooth serial board then try using the\nwell-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are\nconnecting to an Android peer then please generate your own unique UUID.\n@param uuid service record uuid to lookup RFCOMM channel @return a RFCOMM\nBluetoothServerSocket ready for an outgoing connection @throws IOException on\nerror, for example Bluetooth not available, or insufficient permissions\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1917
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createInsecureRfcommSocketToServiceRecord",
          "documentation": "Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure\noutgoing connection to this remote device using SDP lookup of uuid.\n\nThe communication channel will not have an authenticated link key i.e it will\nbe subject to man-in-the-middle attacks. For Bluetooth 2.1 devices, the link\nkey will be encrypted, as encryption is mandatory. For legacy devices (pre\nBluetooth 2.1 devices) the link key will be not be encrypted. Use {@link\n#createRfcommSocketToServiceRecord} if an encrypted and authenticated\ncommunication channel is desired.\n\nThis is designed to be used with {@link\nBluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer\nBluetooth applications.\n\nUse {@link BluetoothSocket#connect} to initiate the outgoing connection. This\nwill also perform an SDP lookup of the given uuid to determine which channel\nto connect to.\n\nThe remote device will be authenticated and communication on this socket will\nbe encrypted.\n\nHint: If you are connecting to a Bluetooth serial board then try using the\nwell-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are\nconnecting to an Android peer then please generate your own unique UUID.\n@param uuid service record uuid to lookup RFCOMM channel @return a RFCOMM\nBluetoothServerSocket ready for an outgoing connection @throws IOException on\nerror, for example Bluetooth not available, or insufficient permissions\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1955
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createL2capChannel",
          "documentation": "Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link\nBluetoothSocket} that can be used to start a secure outgoing connection to the\nremote device with the same dynamic protocol/service multiplexer (PSM) value.\nThe supported Bluetooth transport is LE only.\n\nThis is designed to be used with {@link\nBluetoothAdapter#listenUsingL2capChannel()} for peer-peer Bluetooth\napplications.\n\nUse {@link BluetoothSocket#connect} to initiate the outgoing connection.\n\nApplication using this API is responsible for obtaining PSM value from remote\ndevice.\n\nThe remote device will be authenticated and communication on this socket will\nbe encrypted.\n\nUse this socket if an authenticated socket link is possible. Authentication\nrefers to the authentication of the link key to prevent man-in-the-middle type\nof attacks. @param psm dynamic PSM value from remote device @return a CoC\n#BluetoothSocket ready for an outgoing connection @throws IOException on\nerror, for example Bluetooth not available, or insufficient permissions\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2195
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createL2capCocSocket",
          "documentation": "TODO: Remove this hidden method once all the SL4A and other tests are updated\nto use the new API name, createL2capChannel. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2211
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createInsecureL2capChannel",
          "documentation": "Create a Bluetooth L2CAP Connection-oriented Channel (CoC) {@link\nBluetoothSocket} that can be used to start a secure outgoing connection to the\nremote device with the same dynamic protocol/service multiplexer (PSM) value.\nThe supported Bluetooth transport is LE only.\n\nThis is designed to be used with {@link\nBluetoothAdapter#listenUsingInsecureL2capChannel()} for peer-peer Bluetooth\napplications.\n\nUse {@link BluetoothSocket#connect} to initiate the outgoing connection.\n\nApplication using this API is responsible for obtaining PSM value from remote\ndevice.\n\nThe communication channel may not have an authenticated link key, i.e. it may\nbe subject to man-in-the-middle attacks. Use {@link #createL2capChannel(int)}\nif an encrypted and authenticated communication channel is possible. @param\npsm dynamic PSM value from remote device @return a CoC #BluetoothSocket ready\nfor an outgoing connection @throws IOException on error, for example Bluetooth\nnot available, or insufficient permissions\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2234
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.createInsecureL2capCocSocket",
          "documentation": "TODO: Remove this hidden method once all the SL4A and other tests are updated\nto use the new API name, createInsecureL2capChannel. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2252
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.getActiveDevice",
          "documentation": "Get the connected device that is active.\n\nRequires {@link android.Manifest.permission#BLUETOOTH} permission. @return the\nconnected device that is active or null if no device is active. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 1101
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.isInbandRingingEnabled",
          "documentation": "Check if in-band ringing is currently enabled. In-band ringing could be\ndisabled during an active connection. @return true if in-band ringing is\nenabled, false if in-band ringing is disabled @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 1127
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getActiveDevices",
          "documentation": "Get the connected physical Hearing Aid devices that are active\n\nRequires {@link android.Manifest.permission#BLUETOOTH} permission. @return the\nlist of active devices. The first element is the left active device; the\nsecond element is the right active device. If either or both side is not\nactive, it will be null on that position. Returns empty list on error. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 335
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getPriority",
          "documentation": "Get the priority of the profile.\n\nThe priority can be any of: {@link #PRIORITY_AUTO_CONNECT}, {@link\n#PRIORITY_OFF}, {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED} @param\ndevice Bluetooth device @return priority of the device @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 397
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getVolume",
          "documentation": "Get the volume of the device.\n\nThe volume is between -128 dB (mute) to 0 dB. @return volume of the hearing\naid device. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 444
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.adjustVolume",
          "documentation": "Tells remote device to adjust volume. Uses the following values:\n\n  * {@link AudioManager#ADJUST_LOWER}\n  * {@link AudioManager#ADJUST_RAISE}\n  * {@link AudioManager#ADJUST_MUTE}\n  * {@link AudioManager#ADJUST_UNMUTE}\n\n@param direction One of the supported adjust values. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 474
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getHiSyncId",
          "documentation": "Get the CustomerId of the device. @param device Bluetooth device @return the\nCustomerId of the device @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 524
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getDeviceSide",
          "documentation": "Get the side of the device. @param device Bluetooth device. @return SIDE_LEFT\nor SIDE_RIGHT @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 552
        },
        {
          "method_name": "android.bluetooth.BluetoothHearingAid.getDeviceMode",
          "documentation": "Get the mode of the device. @param device Bluetooth device @return\nMODE_MONAURAL or MODE_BINAURAL @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHearingAid.java",
          "line": 578
        },
        {
          "method_name": "android.bluetooth.BluetoothManager.getConnectionState",
          "documentation": "Get the current connection state of the profile to the remote device.\n\nThis is not specific to any application configuration but represents the\nconnection state of the local Bluetooth adapter for certain profile. This can\nbe used by applications like status bar which would just like to know the\nstate of Bluetooth. @param device Remote bluetooth device. @param profile GATT\nor GATT_SERVER @return State of the profile connection. One of {@link\nBluetoothProfile#STATE_CONNECTED}, {@link BluetoothProfile#STATE_CONNECTING},\n{@link BluetoothProfile#STATE_DISCONNECTED}, {@link\nBluetoothProfile#STATE_DISCONNECTING}\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothManager.java",
          "line": 97
        },
        {
          "method_name": "android.bluetooth.BluetoothManager.getConnectedDevices",
          "documentation": "Get connected devices for the specified profile.\n\nReturn the set of devices which are in state {@link\nBluetoothProfile#STATE_CONNECTED}\n\nThis is not specific to any application configuration but represents the\nconnection state of Bluetooth for this profile. This can be used by\napplications like status bar which would just like to know the state of\nBluetooth. @param profile GATT or GATT_SERVER @return List of devices. The\nlist will be empty on error.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothManager.java",
          "line": 124
        },
        {
          "method_name": "android.bluetooth.BluetoothManager.getDevicesMatchingConnectionStates",
          "documentation": "Get a list of devices that match any of the given connection states.\n\nIf none of the devices match any of the given states, an empty list will be\nreturned.\n\nThis is not specific to any application configuration but represents the\nconnection state of the local Bluetooth adapter for this profile. This can be\nused by applications like status bar which would just like to know the state\nof the local adapter. @param profile GATT or GATT_SERVER @param states Array\nof states. States can be one of {@link BluetoothProfile#STATE_CONNECTED},\n{@link BluetoothProfile#STATE_CONNECTING}, {@link\nBluetoothProfile#STATE_DISCONNECTED}, {@link\nBluetoothProfile#STATE_DISCONNECTING}, @return List of devices. The list will\nbe empty on error.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothManager.java",
          "line": 165
        },
        {
          "method_name": "android.bluetooth.BluetoothProfile.getConnectedDevices",
          "documentation": "Get connected devices for this specific profile.\n\nReturn the set of devices which are in state {@link #STATE_CONNECTED} @return\nList of devices. The list will be empty on error.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothProfile.java",
          "line": 255
        },
        {
          "method_name": "android.bluetooth.BluetoothProfile.getDevicesMatchingConnectionStates",
          "documentation": "Get a list of devices that match any of the given connection states.\n\nIf none of the devices match any of the given states, an empty list will be\nreturned. @param states Array of states. States can be one of {@link\n#STATE_CONNECTED}, {@link #STATE_CONNECTING}, {@link #STATE_DISCONNECTED},\n{@link #STATE_DISCONNECTING}, @return List of devices. The list will be empty\non error.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothProfile.java",
          "line": 269
        },
        {
          "method_name": "android.bluetooth.BluetoothProfile.getConnectionState",
          "documentation": "Get the current connection state of the profile @param device Remote bluetooth\ndevice. @return State of the profile connection. One of {@link\n#STATE_CONNECTED}, {@link #STATE_CONNECTING}, {@link #STATE_DISCONNECTED},\n{@link #STATE_DISCONNECTING}\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothProfile.java",
          "line": 279
        }
      ]
    },
    "android.permission.SUSPEND_APPS": {
      "name": "android.permission.SUSPEND_APPS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.setPackagesSuspended",
          "documentation": "Puts the package in a suspended state, where attempts at starting activities\nare denied.\n\nIt doesn't remove the data or the actual package file. The application's\nnotifications will be hidden, any of its started activities will be stopped\nand it will not be able to show toasts or system alert windows or ring the\ndevice.\n\nWhen the user tries to launch a suspended app, a system dialog with the given\n{@code dialogMessage} will be shown instead. Since the message is supplied to\nthe system as a {@link String}, the caller needs to take care of localization\nas needed. The dialog message can optionally contain a placeholder for the\nname of the suspended app. The system uses {@link String#format(Locale,\nString, Object...) String.format} to insert the app name into the message, so\nan example format string could be {@code \"The app %1$s is currently\nsuspended\"}. This makes it easier for callers to provide a single message\nwhich works for all the packages being suspended in a single call.\n\nThe package must already be installed. If the package is uninstalled while\nsuspended the package will no longer be suspended.\n\nOptionally, the suspending app can provide extra information in the form of\n{@link PersistableBundle} objects to be shared with the apps being suspended\nand the launcher to support customization that they might need to handle the\nsuspended state.\n\nThe caller must hold {@link Manifest.permission#SUSPEND_APPS} or {@link\nManifest.permission#MANAGE_USERS} to use this api.\n\n@param packageNames The names of the packages to set the suspended status.\n@param suspended If set to {@code true} than the packages will be suspended,\nif set to {@code false}, the packages will be unsuspended. @param appExtras An\noptional {@link PersistableBundle} that the suspending app can provide which\nwill be shared with the apps being suspended. Ignored if {@code suspended} is\nfalse. @param launcherExtras An optional {@link PersistableBundle} that the\nsuspending app can provide which will be shared with the launcher. Ignored if\n{@code suspended} is false. @param dialogMessage The message to be displayed\nto the user, when they try to launch a suspended app. @return an array of\npackage names for which the suspended status could not be set as requested in\nthis method. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5698
        }
      ]
    },
    "android.permission.BLUETOOTH_ADMIN": {
      "name": "android.permission.BLUETOOTH_ADMIN",
      "label": "Acc\u00e9der aux param\u00e8tres Bluetooth",
      "label_ptr": "permlab_bluetoothAdmin",
      "description": "Permet \u00e0 l'application de configurer le t\u00e9l\u00e9phone Bluetooth local, d'identifier des appareils distants et de les associer au t\u00e9l\u00e9phone.",
      "description_ptr": "permdesc_bluetoothAdmin",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.bluetooth.BluetoothAdapter.enable",
          "documentation": "Turn on the local Bluetooth adapter--do not use without explicit user action\nto turn on Bluetooth.\n\nThis powers on the underlying Bluetooth hardware, and starts all Bluetooth\nsystem services.\n\n**Bluetooth should never be enabled without direct user consent**. If you want\nto turn on Bluetooth in order to create a wireless connection, you should use\nthe {@link #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that\nrequests user permission to turn on Bluetooth. The {@link #enable()} method is\nprovided only for applications that include a user interface for changing\nsystem settings, such as a \"power manager\" app.\n\nThis is an asynchronous call: it will return immediately, and clients should\nlisten for {@link #ACTION_STATE_CHANGED} to be notified of subsequent adapter\nstate changes. If this call returns true, then the adapter state will\nimmediately transition from {@link #STATE_OFF} to {@link #STATE_TURNING_ON},\nand some time later transition to either {@link #STATE_OFF} or {@link\n#STATE_ON}. If this call returns false then there was an immediate problem\nthat will prevent the adapter from being turned on - such as Airplane mode, or\nthe adapter is already turned on. @return true to indicate adapter startup has\nbegun, or false on immediate error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1088
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.setName",
          "documentation": "Set the friendly Bluetooth name of the local Bluetooth adapter.\n\nThis name is visible to remote Bluetooth devices.\n\nValid Bluetooth names are a maximum of 248 bytes using UTF-8 encoding,\nalthough many remote devices can only display the first 40 characters, and\nsome may be limited to just 20.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return false. After\nturning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED} with {@link\n#STATE_ON} to get the updated value. @param name a valid Bluetooth name\n@return true if the name was set, false otherwise\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1252
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getBluetoothClass",
          "documentation": "Returns the {@link BluetoothClass} Bluetooth Class of Device (CoD) of the\nlocal Bluetooth adapter. @return {@link BluetoothClass} Bluetooth CoD of local\nBluetooth device. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1278
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getIoCapability",
          "documentation": "Returns the Input/Output capability of the device for classic Bluetooth.\n@return Input/Output capability of the device. One of {@link\n#IO_CAPABILITY_OUT}, {@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN},\n{@link #IO_CAPABILITY_NONE}, {@link #IO_CAPABILITY_KBDISP} or {@link\n#IO_CAPABILITY_UNKNOWN}. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1335
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.getLeIoCapability",
          "documentation": "Returns the Input/Output capability of the device for BLE operations. @return\nInput/Output capability of the device. One of {@link #IO_CAPABILITY_OUT},\n{@link #IO_CAPABILITY_IO}, {@link #IO_CAPABILITY_IN}, {@link\n#IO_CAPABILITY_NONE}, {@link #IO_CAPABILITY_KBDISP} or {@link\n#IO_CAPABILITY_UNKNOWN}. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1386
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.startDiscovery",
          "documentation": "Start the remote device discovery process.\n\nThe discovery process usually involves an inquiry scan of about 12 seconds,\nfollowed by a page scan of each new device to retrieve its Bluetooth name.\n\nThis is an asynchronous call, it will return immediately. Register for {@link\n#ACTION_DISCOVERY_STARTED} and {@link #ACTION_DISCOVERY_FINISHED} intents to\ndetermine exactly when the discovery starts and completes. Register for {@link\nBluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices are\nfound.\n\nDevice discovery is a heavyweight procedure. New connections to remote\nBluetooth devices should not be attempted while discovery is in progress, and\nexisting connections will experience limited bandwidth and high latency. Use\n{@link #cancelDiscovery()} to cancel an ongoing discovery. Discovery is not\nmanaged by the Activity, but is run as a system service, so an application\nshould always call {@link BluetoothAdapter#cancelDiscovery()} even if it did\nnot directly request a discovery, just to be sure.\n\nDevice discovery will only find remote devices that are currently\n_discoverable_ (inquiry scan enabled). Many Bluetooth devices are not\ndiscoverable by default, and need to be entered into a special mode.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return false. After\nturning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED} with {@link\n#STATE_ON} to get the updated value. @return true on success, false on error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1623
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.cancelDiscovery",
          "documentation": "Cancel the current device discovery process.\n\nBecause discovery is a heavyweight procedure for the Bluetooth adapter, this\nmethod should always be called before attempting to connect to a remote device\nwith {@link android.bluetooth.BluetoothSocket#connect()}. Discovery is not\nmanaged by the Activity, but is run as a system service, so an application\nshould always call cancel discovery even if it did not directly request a\ndiscovery, just to be sure.\n\nIf Bluetooth state is not {@link #STATE_ON}, this API will return false. After\nturning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED} with {@link\n#STATE_ON} to get the updated value. @return true on success, false on error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1657
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.enableNoAutoConnect",
          "documentation": "Enable the Bluetooth Adapter, but don't auto-connect devices and don't persist\nstate. Only for use by system applications. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2728
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.startLeScan",
          "documentation": "Starts a scan for Bluetooth LE devices, looking for devices that advertise\ngiven services.\n\nDevices which advertise all specified services are reported using the {@link\nLeScanCallback#onLeScan} callback. @param serviceUuids Array of services to\nlook for @param callback the callback LE scan results are delivered @return\ntrue, if the scan was started successfully @deprecated use {@link\nBluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)} instead.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 2927
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.stopLeScan",
          "documentation": "Stops an ongoing Bluetooth LE device scan. @param callback used to identify\nwhich scan to stop must be the same handle used to start the scan @deprecated\nUse {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3024
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.cancelBondProcess",
          "documentation": "Cancel an in-progress bonding request started with {@link #createBond}.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN}. @return true on\nsuccess, false on error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1280
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.removeBond",
          "documentation": "Remove bond (pairing) with the remote device.\n\nDelete the link key associated with the remote device, and immediately\nterminate connections to that device that require authentication and\nencryption.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN}. @return true on\nsuccess, false on error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1309
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.connect",
          "documentation": "Initiate connection to a profile of the remote bluetooth device.\n\nCurrently, the system supports only 1 connection to the headset/handsfree\nprofile. The API will automatically disconnect connected devices before\nconnecting.\n\nThis API returns false in scenarios like the profile on the device is already\nconnected or Bluetooth is not turned on. When this API returns true, it is\nguaranteed that connection state intent for the profile will be broadcasted\nwith the state. Users can get the connection state of the profile from this\nintent.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n@param device Remote Bluetooth Device @return false on immediate error, true\notherwise @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 442
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.disconnect",
          "documentation": "Initiate disconnection from a profile\n\nThis API will return false in scenarios like the profile on the Bluetooth\ndevice is not in connected state etc. When this API returns, true, it is\nguaranteed that the connection state change intent will be broadcasted with\nthe state. Users can get the disconnection state of the profile from this\nintent.\n\nIf the disconnection is initiated by a remote device, the state will\ntransition from {@link #STATE_CONNECTED} to {@link #STATE_DISCONNECTED}. If\nthe disconnect is initiated by the host (local) device the state will\ntransition from {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING}\nto state {@link #STATE_DISCONNECTED}. The transition to {@link\n#STATE_DISCONNECTING} can be used to distinguish between the two scenarios.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n@param device Remote Bluetooth Device @return false on immediate error, true\notherwise @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 484
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.setPriority",
          "documentation": "Set priority of the profile\n\nThe device should already be paired. Priority can be one of {@link\nBluetoothProfile#PRIORITY_ON} or {@link BluetoothProfile#PRIORITY_OFF},\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n@param device Paired bluetooth device @param priority @return true if priority\nis set, false on error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 573
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.startScoUsingVirtualVoiceCall",
          "documentation": "Initiates a SCO channel connection as a virtual voice call to the current\nactive device Active handsfree device will be notified of incoming call and\nconnected call.\n\nUsers can listen to {@link #ACTION_AUDIO_STATE_CHANGED}. If this function\nreturns true, this intent will be broadcasted with {@link #EXTRA_STATE} set to\n{@link #STATE_AUDIO_CONNECTING}.\n\n{@link #EXTRA_STATE} will transition from {@link #STATE_AUDIO_CONNECTING} to\n{@link #STATE_AUDIO_CONNECTED} when audio connection is established and to\n{@link #STATE_AUDIO_DISCONNECTED} in case of failure to establish the audio\nconnection. @return true if successful, false if one of the following case\napplies - SCO audio is not idle (connecting or connected) - virtual call has\nalready started - there is no active device - a Telecom managed call is going\non - binder is dead or Bluetooth is disabled or other error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 917
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.stopScoUsingVirtualVoiceCall",
          "documentation": "Terminates an ongoing SCO connection and the associated virtual call.\n\nUsers can listen to {@link #ACTION_AUDIO_STATE_CHANGED}. If this function\nreturns true, this intent will be broadcasted with {@link #EXTRA_STATE} set to\n{@link #STATE_AUDIO_DISCONNECTED}. @return true if successful, false if one of\nthe following case applies - virtual voice call is not started or has ended -\nbinder is dead or Bluetooth is disabled or other error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 947
        },
        {
          "method_name": "android.bluetooth.BluetoothHeadset.setActiveDevice",
          "documentation": "Select a connected device as active. The active device selection is per\nprofile. An active device's purpose is profile-specific. For example, in HFP\nand HSP profiles, it is the device used for phone call audio. If a remote\ndevice is not connected, it cannot be selected as active.\n\nThis API returns false in scenarios like the profile on the device is not\nconnected or Bluetooth is not turned on. When this API returns true, it is\nguaranteed that the {@link #ACTION_ACTIVE_DEVICE_CHANGED} intent will be\nbroadcasted with the active device.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n@param device Remote Bluetooth Device, could be null if phone call audio\nshould not be streamed to a headset @return false on immediate error, true\notherwise @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothHeadset.java",
          "line": 1071
        },
        {
          "method_name": "android.bluetooth.le.BluetoothLeScanner.startScanFromSource",
          "documentation": "Start Bluetooth LE scan. Same as {@link #startScan(List, ScanSettings,\nScanCallback)} but allows the caller to specify on behalf of which\napplication(s) the work is being done. @param filters {@link ScanFilter}s for\nfinding exact BLE devices. @param settings Settings for the scan. @param\nworkSource {@link WorkSource} identifying the application(s) for which to\nblame for the scan. @param callback Callback used to deliver scan results.\n@hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/le/BluetoothLeScanner.java",
          "line": 201
        },
        {
          "method_name": "android.bluetooth.le.BluetoothLeScanner.stopScan",
          "documentation": "Stops an ongoing Bluetooth LE scan started using a PendingIntent. When\ncreating the PendingIntent parameter, please do not use the\nFLAG_CANCEL_CURRENT flag. Otherwise, the stop scan may have no effect. @param\ncallbackIntent The PendingIntent that was used to start the scan. @see\n#startScan(List, ScanSettings, PendingIntent)\n\n",
          "file": "./aosp/core/java/android/bluetooth/le/BluetoothLeScanner.java",
          "line": 286
        }
      ]
    },
    "android.permission.BLUETOOTH_PRIVILEGED": {
      "name": "android.permission.BLUETOOTH_PRIVILEGED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.bluetooth.BluetoothAdapter.setBluetoothClass",
          "documentation": "Sets the {@link BluetoothClass} Bluetooth Class of Device (CoD) of the local\nBluetooth adapter.\n\nNote: This value persists across system reboot. @param bluetoothClass {@link\nBluetoothClass} to set the local Bluetooth adapter to. @return true if\nsuccessful, false if unsuccessful. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1307
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.setIoCapability",
          "documentation": "Sets the Input/Output capability of the device for classic Bluetooth.\n\nChanging the Input/Output capability of a device only takes effect on\nrestarting the Bluetooth stack. You would need to restart the stack using\n{@link BluetoothAdapter#disable()} and {@link BluetoothAdapter#enable()} to\nsee the changes. @param capability Input/Output capability of the device. One\nof {@link #IO_CAPABILITY_OUT}, {@link #IO_CAPABILITY_IO}, {@link\n#IO_CAPABILITY_IN}, {@link #IO_CAPABILITY_NONE} or {@link\n#IO_CAPABILITY_KBDISP}. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1362
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.setLeIoCapability",
          "documentation": "Sets the Input/Output capability of the device for BLE operations.\n\nChanging the Input/Output capability of a device only takes effect on\nrestarting the Bluetooth stack. You would need to restart the stack using\n{@link BluetoothAdapter#disable()} and {@link BluetoothAdapter#enable()} to\nsee the changes. @param capability Input/Output capability of the device. One\nof {@link #IO_CAPABILITY_OUT}, {@link #IO_CAPABILITY_IO}, {@link\n#IO_CAPABILITY_IN}, {@link #IO_CAPABILITY_NONE} or {@link\n#IO_CAPABILITY_KBDISP}. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 1413
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.addOnMetadataChangedListener",
          "documentation": "Register a {@link #OnMetadataChangedListener} to receive update about metadata\nchanges for this {@link BluetoothDevice}. Registration must be done when\nBluetooth is ON and will last until {@link\n#removeOnMetadataChangedListener(BluetoothDevice)} is called, even when\nBluetooth restarted in the middle. All input parameters should not be null or\n{@link NullPointerException} will be triggered. The same {@link\nBluetoothDevice} and {@link #OnMetadataChangedListener} pair can only be\nregistered once, double registration would cause {@link\nIllegalArgumentException}. @param device {@link BluetoothDevice} that will be\nregistered @param executor the executor for listener callback @param listener\n{@link #OnMetadataChangedListener} that will receive asynchronous callbacks\n@return true on success, false on error @throws NullPointerException If one of\n{@code listener}, {@code device} or {@code executor} is null. @throws\nIllegalArgumentException The same {@link #OnMetadataChangedListener} and\n{@link BluetoothDevice} are registered twice. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3181
        },
        {
          "method_name": "android.bluetooth.BluetoothAdapter.removeOnMetadataChangedListener",
          "documentation": "Unregister a {@link #OnMetadataChangedListener} from a registered {@link\nBluetoothDevice}. Unregistration can be done when Bluetooth is either ON or\nOFF. {@link #addOnMetadataChangedListener(OnMetadataChangedListener,\nBluetoothDevice, Executor)} must be called before unregisteration. @param\ndevice {@link BluetoothDevice} that will be unregistered. It should not be\nnull or {@link NullPointerException} will be triggered. @param listener {@link\nOnMetadataChangedListener} that will be unregistered. It should not be null or\n{@link NullPointerException} will be triggered. @return true on success, false\non error @throws NullPointerException If {@code listener} or {@code device} is\nnull. @throws IllegalArgumentException If {@code device} has not been\nregistered before. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothAdapter.java",
          "line": 3254
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.setPairingConfirmation",
          "documentation": "Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.\n@return true confirmation has been sent out false for error\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1544
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.setSilenceMode",
          "documentation": "Sets whether the {@link BluetoothDevice} enters silence mode. Audio will not\nbe routed to the {@link BluetoothDevice} if set to {@code true}. When the\n{@link BluetoothDevice} enters silence mode, and the {@link BluetoothDevice}\nis an active device (for A2DP or HFP), the active device for that profile will\nbe set to null. If the {@link BluetoothDevice} exits silence mode while the\nA2DP or HFP active device is null, the {@link BluetoothDevice} will be set as\nthe active device for that profile. If the {@link BluetoothDevice} is\ndisconnected, it exits silence mode. If the {@link BluetoothDevice} is set as\nthe active device for A2DP or HFP, while silence mode is enabled, then the\ndevice will exit silence mode. If the {@link BluetoothDevice} is in silence\nmode, AVRCP position change event and HFP AG indicators will be disabled. If\nthe {@link BluetoothDevice} is not connected with A2DP or HFP, it cannot enter\nsilence mode.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}. @param\nsilence true to enter silence mode, false to exit @return true on success,\nfalse on error. @throws IllegalStateException if Bluetooth is not turned ON.\n@hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1652
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.isInSilenceMode",
          "documentation": "Check whether the {@link BluetoothDevice} is in silence mode\n\nRequires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}. @return\ntrue on device in silence mode, otherwise false. @throws IllegalStateException\nif Bluetooth is not turned ON. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1676
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.setPhonebookAccessPermission",
          "documentation": "Sets whether the phonebook access is allowed to this device.\n\nRequires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}. @param\nvalue Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link\n#ACCESS_REJECTED}. @return Whether the value has been successfully set. @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 1700
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.setMetadata",
          "documentation": "Set a keyed metadata of this {@link BluetoothDevice} to a {@link String}\nvalue. Only bonded devices's metadata will be persisted across Bluetooth\nrestart. Metadata will be removed when the device's bond state is moved to\n{@link #BOND_NONE}. @param key must be within the list of\nBluetoothDevice.METADATA_* @param value a byte array data to set for key. Must\nbe less than {@link BluetoothAdapter#METADATA_MAX_LENGTH} characters in length\n@return true on success, false on error @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2273
        },
        {
          "method_name": "android.bluetooth.BluetoothDevice.getMetadata",
          "documentation": "Get a keyed metadata for this {@link BluetoothDevice} as {@link String} @param\nkey must be within the list of BluetoothDevice.METADATA_* @return Metadata of\nthe key as byte array, null on error or not found @hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/BluetoothDevice.java",
          "line": 2301
        }
      ]
    },
    "android.permission.BLUETOOTH_MAP": {
      "name": "android.permission.BLUETOOTH_MAP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BLUETOOTH_STACK": {
      "name": "android.permission.BLUETOOTH_STACK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.NFC": {
      "name": "android.permission.NFC",
      "label": "contr\u00f4ler la communication en champ proche",
      "label_ptr": "permlab_nfc",
      "description": "Permet \u00e0 l'application de communiquer avec des tags, des cartes et des lecteurs compatibles avec la technologie\u00a0NFC (communication en champ proche).",
      "description_ptr": "permdesc_nfc",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.nfc.cardemulation.CardEmulation.unsetOffHostForService",
          "documentation": "Unsets the off-host Secure Element for the given service.\n\nNote that this will only remove Secure Element that was dynamically set using\nthe {@link #setOffHostForService(ComponentName, String)} and resets it to a\nvalue that was statically assigned using manifest.\n\nNote that you can only unset off-host SE for a service that is running under\nthe same UID as the caller of this API. Typically this means you need to call\nthis from the same package as the service itself, though UIDs can also be\nshared between packages using shared UIDs. @param service The component name\nof the service @return whether the registration was successful.\n\n",
          "file": "./aosp/core/java/android/nfc/cardemulation/CardEmulation.java",
          "line": 366
        },
        {
          "method_name": "android.nfc.cardemulation.CardEmulation.setOffHostForService",
          "documentation": "Sets the off-host Secure Element for the given service.\n\nIf off-host SE was initially set (either statically through the manifest, or\ndynamically by using this API), it will be replaced with this one. All AIDs\nregistered by this service will be re-routed to this Secure Element if\nsuccessful. AIDs that was statically assigned using manifest will re-route to\noff-host SE that stated in manifest after NFC toggle.\n\nNote that you can only set off-host SE for a service that is running under the\nsame UID as the caller of this API. Typically this means you need to call this\nfrom the same package as the service itself, though UIDs can also be shared\nbetween packages using shared UIDs.\n\nRegisteration will be successful only if the Secure Element exists on the\ndevice. @param service The component name of the service @param\noffHostSecureElement Secure Element to register the AID to. Only accept\nstrings with prefix SIM or prefix eSE. Ref: GSMA TS.26 - NFC Handset\nRequirements TS26_NFC_REQ_069: For UICC, Secure Element Name SHALL be\nSIM[smartcard slot] (e.g. SIM/SIM1, SIM2\u2026 SIMn). TS26_NFC_REQ_070: For\nembedded SE, Secure Element Name SHALL be eSE[number] (e.g. eSE/eSE1, eSE2,\netc.). @return whether the registration was successful.\n\n",
          "file": "./aosp/core/java/android/nfc/cardemulation/CardEmulation.java",
          "line": 424
        }
      ]
    },
    "android.permission.NFC_TRANSACTION_EVENT": {
      "name": "android.permission.NFC_TRANSACTION_EVENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.CONNECTIVITY_INTERNAL": {
      "name": "android.permission.CONNECTIVITY_INTERNAL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.setGlobalProxy",
          "documentation": "Set a network-independent global http proxy. This is not normally what you\nwant for typical HTTP proxies - they are general network dependent. However if\nyou're doing something unusual like general internal filtering this may be\nuseful. On a private network where the proxy is not accessible, you may break\nHTTP using this. @param p A {@link ProxyInfo} object defining the new global\nHTTP proxy. A {@code null} value will clear the global HTTP proxy. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2971
        }
      ]
    },
    "android.permission.CONNECTIVITY_USE_RESTRICTED_NETWORKS": {
      "name": "android.permission.CONNECTIVITY_USE_RESTRICTED_NETWORKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.NETWORK_SIGNAL_STRENGTH_WAKEUP": {
      "name": "android.permission.NETWORK_SIGNAL_STRENGTH_WAKEUP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.PACKET_KEEPALIVE_OFFLOAD": {
      "name": "android.permission.PACKET_KEEPALIVE_OFFLOAD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.createNattKeepalive",
          "documentation": "Request that keepalives be started on a IPsec NAT-T socket file descriptor.\nDirectly called by system apps which don't use IpSecService to create {@link\nUdpEncapsulationSocket}. @param network The {@link Network} the socket is on.\n@param pfd The {@link ParcelFileDescriptor} that needs to be kept alive. The\nprovided {@link ParcelFileDescriptor} must be bound to a port and the\nkeepalives will be sent from that port. @param source The source address of\nthe {@link UdpEncapsulationSocket}. @param destination The destination address\nof the {@link UdpEncapsulationSocket}. The keepalive packets will always be\nsent to port 4500 of the given {@code destination}. @param executor The\nexecutor on which callback will be invoked. The provided {@link Executor} must\nrun callback sequentially, otherwise the order of callbacks cannot be\nguaranteed. @param callback A {@link SocketKeepalive.Callback}. Used for\nnotifications about keepalive changes. Must be extended by applications that\nuse this API. @return A {@link SocketKeepalive} object that can be used to\ncontrol the keepalive on the given socket. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1972
        },
        {
          "method_name": "android.net.ConnectivityManager.createSocketKeepalive",
          "documentation": "Request that keepalives be started on a TCP socket. The socket must be\nestablished. @param network The {@link Network} the socket is on. @param\nsocket The socket that needs to be kept alive. @param executor The executor on\nwhich callback will be invoked. This implementation assumes the provided\n{@link Executor} runs the callbacks in sequence with no concurrency. Failing\nthis, no guarantee of correctness can be made. It is the responsibility of the\ncaller to ensure the executor provides this guarantee. A simple way of\ncreating such an executor is with the standard tool {@code\nExecutors.newSingleThreadExecutor}. @param callback A {@link\nSocketKeepalive.Callback}. Used for notifications about keepalive changes.\nMust be extended by applications that use this API. @return A {@link\nSocketKeepalive} object that can be used to control the keepalive on the given\nsocket. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2012
        },
        {
          "method_name": "android.net.IpSecTransform.startNattKeepalive",
          "documentation": "Start a NAT-T keepalive session for the current transform. For a transform\nthat is using UDP encapsulated IPv4, NAT-T offloading provides a power\nefficient mechanism of sending NAT-T packets at a specified interval. @param\nuserCallback a {@link #NattKeepaliveCallback} to receive asynchronous status\ninformation about the requested NAT-T keepalive session. @param\nintervalSeconds the interval between NAT-T keepalives being sent. The the\nallowed range is between 20 and 3600 seconds. @param handler a handler on\nwhich to post callbacks when received. @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecTransform.java",
          "line": 291
        },
        {
          "method_name": "android.net.IpSecTransform.stopNattKeepalive",
          "documentation": "Stop an ongoing NAT-T keepalive session. Calling this API will request that an\nongoing NAT-T keepalive session be terminated. If this API is not called when\na Transform is closed, the underlying NAT-T session will be terminated\nautomatically. @hide\n\n",
          "file": "./aosp/core/java/android/net/IpSecTransform.java",
          "line": 333
        }
      ]
    },
    "android.permission.RECEIVE_DATA_ACTIVITY_CHANGE": {
      "name": "android.permission.RECEIVE_DATA_ACTIVITY_CHANGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.LOOP_RADIO": {
      "name": "android.permission.LOOP_RADIO",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.NFC_HANDOVER_STATUS": {
      "name": "android.permission.NFC_HANDOVER_STATUS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_BLUETOOTH_WHEN_PERMISSION_REVIEW_REQUIRED": {
      "name": "android.permission.MANAGE_BLUETOOTH_WHEN_PERMISSION_REVIEW_REQUIRED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.GET_ACCOUNTS": {
      "name": "android.permission.GET_ACCOUNTS",
      "label": "rechercher des comptes sur l'appareil",
      "label_ptr": "permlab_getAccounts",
      "description": "Permet \u00e0 l'application d'obtenir la liste des comptes connus par le t\u00e9l\u00e9phone. Il peut s'agir de n'importe quel compte cr\u00e9\u00e9 par les applications que vous avez install\u00e9es.",
      "description_ptr": "permdesc_getAccounts",
      "permission_group": "android.permission-group.CONTACTS",
      "protection_level": "dangerous"
    },
    "android.permission.ACCOUNT_MANAGER": {
      "name": "android.permission.ACCOUNT_MANAGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CHANGE_WIFI_MULTICAST_STATE": {
      "name": "android.permission.CHANGE_WIFI_MULTICAST_STATE",
      "label": "autoriser la r\u00e9ception de donn\u00e9es en Wi-Fi multidiffusion",
      "label_ptr": "permlab_changeWifiMulticastState",
      "description": "Permet \u00e0 l'application de recevoir des paquets envoy\u00e9s \u00e0 tous les appareils (et pas seulement \u00e0 votre t\u00e9l\u00e9phone) d'un r\u00e9seau Wi-Fi qui utilise des adresses de multidiffusion. Cette autorisation entra\u00eene une consommation d'\u00e9nergie sup\u00e9rieure au mode de diffusion simple.",
      "description_ptr": "permdesc_changeWifiMulticastState",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.VIBRATE": {
      "name": "android.permission.VIBRATE",
      "label": "contr\u00f4ler le vibreur",
      "label_ptr": "permlab_vibrate",
      "description": "Permet \u00e0 l'application de contr\u00f4ler le vibreur.",
      "description_ptr": "permdesc_vibrate",
      "permission_group": "",
      "protection_level": "normal|instant",
      "methods": [
        {
          "method_name": "android.os.Vibrator.vibrate",
          "documentation": "Like {@link #vibrate(VibrationEffect, AudioAttributes)}, but allowing the\ncaller to specify that the vibration is owned by someone else. @hide\n\n",
          "file": "./aosp/core/java/android/os/Vibrator.java",
          "line": 262
        },
        {
          "method_name": "android.os.Vibrator.cancel",
          "documentation": "Turn the vibrator off.\n\n",
          "file": "./aosp/core/java/android/os/Vibrator.java",
          "line": 269
        }
      ]
    },
    "android.permission.WAKE_LOCK": {
      "name": "android.permission.WAKE_LOCK",
      "label": "emp\u00eacher le t\u00e9l\u00e9phone de passer en mode veille",
      "label_ptr": "permlab_wakeLock",
      "description": "Permet \u00e0 l'application d'emp\u00eacher le t\u00e9l\u00e9phone de passer en mode veille.",
      "description_ptr": "permdesc_wakeLock",
      "permission_group": "",
      "protection_level": "normal|instant"
    },
    "android.permission.TRANSMIT_IR": {
      "name": "android.permission.TRANSMIT_IR",
      "label": "transmettre des signaux infrarouges",
      "label_ptr": "permlab_transmitIr",
      "description": "Permet \u00e0 l'application d'utiliser l'\u00e9metteur infrarouge du t\u00e9l\u00e9phone.",
      "description_ptr": "permdesc_transmitIr",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.MODIFY_AUDIO_SETTINGS": {
      "name": "android.permission.MODIFY_AUDIO_SETTINGS",
      "label": "modifier vos param\u00e8tres audio",
      "label_ptr": "permlab_modifyAudioSettings",
      "description": "Permet \u00e0 l'application de modifier les param\u00e8tres audio g\u00e9n\u00e9raux, tels que le volume et la sortie audio utilis\u00e9e.",
      "description_ptr": "permdesc_modifyAudioSettings",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.MANAGE_USB": {
      "name": "android.permission.MANAGE_USB",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.usb.UsbManager.grantPermission",
          "documentation": "Grants permission to specified package for USB device without showing system\ndialog. Only system components can call this function, as it requires the\nMANAGE_USB permission. @param device to request permissions for @param\npackageName of package to grant permissions {@hide}\n\n",
          "file": "./aosp/core/java/android/hardware/usb/UsbManager.java",
          "line": 631
        }
      ]
    },
    "android.permission.ACCESS_MTP": {
      "name": "android.permission.ACCESS_MTP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.HARDWARE_TEST": {
      "name": "android.permission.HARDWARE_TEST",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_DYNAMIC_ANDROID": {
      "name": "android.permission.MANAGE_DYNAMIC_ANDROID",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.os.DynamicAndroidManager.startInstallation",
          "documentation": "Start DynamicAndroid installation. This call may take an unbounded amount of\ntime. The caller may use another thread to call the getStartProgress() to get\nthe progress. @param systemSize system size in bytes @param userdataSize\nuserdata size in bytes @return {@code true} if the call succeeds. {@code\nfalse} either the device does not contain enough space or a DynamicAndroid is\ncurrently in use where the {@link #isInUse} would be true.\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 95
        },
        {
          "method_name": "android.os.DynamicAndroidManager.getInstallationProgress",
          "documentation": "Query the progress of the current installation operation. This can be called\nwhile the installation is in progress. @return GsiProgress GsiProgress { int\nstatus; long bytes_processed; long total_bytes; } The status field can be\nIGsiService.STATUS_NO_OPERATION, IGsiService.STATUS_WORKING or\nIGsiService.STATUS_COMPLETE.\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 116
        },
        {
          "method_name": "android.os.DynamicAndroidManager.abort",
          "documentation": "Abort the installation process. Note this method must be called in a thread\nother than the one calling the startInstallation method as the\nstartInstallation method will not return until it is finished. @return {@code\ntrue} if the call succeeds. {@code false} if there is no installation\ncurrently.\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 133
        },
        {
          "method_name": "android.os.DynamicAndroidManager.isInUse",
          "documentation": "\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 143
        },
        {
          "method_name": "android.os.DynamicAndroidManager.isInstalled",
          "documentation": "\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 153
        },
        {
          "method_name": "android.os.DynamicAndroidManager.remove",
          "documentation": "Remove DynamicAndroid installation if present @return {@code true} if the call\nsucceeds. {@code false} if there is no installed image.\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 167
        },
        {
          "method_name": "android.os.DynamicAndroidManager.toggle",
          "documentation": "Enable DynamicAndroid when it's not enabled, otherwise, disable it. @return\n{@code true} if the call succeeds. {@code false} if there is no installed\nimage.\n\n",
          "file": "./aosp/core/java/android/os/DynamicAndroidManager.java",
          "line": 181
        }
      ]
    },
    "android.permission.ACCESS_BROADCAST_RADIO": {
      "name": "android.permission.ACCESS_BROADCAST_RADIO",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.radio.RadioManager.listModules",
          "documentation": "Returns a list of descriptors for all broadcast radio modules present on the\ndevice. @param modules An List of {@link ModuleProperties} where the list will\nbe returned. @return\n\n  * {@link #STATUS_OK} in case of success, \n  * {@link #STATUS_ERROR} in case of unspecified error, \n  * {@link #STATUS_NO_INIT} if the native service cannot be reached, \n  * {@link #STATUS_BAD_VALUE} if modules is null, \n  * {@link #STATUS_DEAD_OBJECT} if the binder transaction to the native service fails, \n\n",
          "file": "./aosp/core/java/android/hardware/radio/RadioManager.java",
          "line": 1711
        },
        {
          "method_name": "android.hardware.radio.RadioManager.openTuner",
          "documentation": "Open an interface to control a tuner on a given broadcast radio module.\nOptionally selects and applies the configuration passed as \"config\" argument.\n@param moduleId radio module identifier {@link ModuleProperties#getId()}.\nMandatory. @param config desired band and configuration to apply when enabling\nthe hardware module. optional, can be null. @param withAudio {@code true} to\nrequest a tuner with an audio source. This tuner is intended for live\nlistening or recording or a radio program. If {@code false}, the tuner can\nonly be used to retrieve program informations. @param callback {@link\nRadioTuner.Callback} interface. Mandatory. @param handler the Handler on which\nthe callbacks will be received. Can be null if default handler is OK. @return\na valid {@link RadioTuner} interface in case of success or null in case of\nerror.\n\n",
          "file": "./aosp/core/java/android/hardware/radio/RadioManager.java",
          "line": 1752
        },
        {
          "method_name": "android.hardware.radio.RadioManager.addAnnouncementListener",
          "documentation": "Adds new announcement listener with executor. @param executor the executor\n@param enabledAnnouncementTypes a set of announcement types to listen to\n@param listener announcement listener\n\n",
          "file": "./aosp/core/java/android/hardware/radio/RadioManager.java",
          "line": 1799
        },
        {
          "method_name": "android.hardware.radio.RadioManager.removeAnnouncementListener",
          "documentation": "Removes previously registered announcement listener. @param listener\nannouncement listener, previously registered with {@link\naddAnnouncementListener}\n\n",
          "file": "./aosp/core/java/android/hardware/radio/RadioManager.java",
          "line": 1830
        }
      ]
    },
    "android.permission.ACCESS_FM_RADIO": {
      "name": "android.permission.ACCESS_FM_RADIO",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.NET_ADMIN": {
      "name": "android.permission.NET_ADMIN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.REMOTE_AUDIO_PLAYBACK": {
      "name": "android.permission.REMOTE_AUDIO_PLAYBACK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.TV_INPUT_HARDWARE": {
      "name": "android.permission.TV_INPUT_HARDWARE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvInputManager.getHardwareList",
          "documentation": "Returns a list of TvInputHardwareInfo objects representing available hardware.\n@hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1569
        },
        {
          "method_name": "android.media.tv.TvInputManager.acquireTvInputHardware",
          "documentation": "Acquires {@link Hardware} object for the given device ID.\n\nA subsequent call to this method on the same {@code deviceId} will release the\ncurrently acquired Hardware. @param deviceId The device ID to acquire Hardware\nfor. @param callback A callback to receive updates on Hardware. @param info\nThe TV input which will use the acquired Hardware. @return Hardware on\nsuccess, {@code null} otherwise. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1613
        },
        {
          "method_name": "android.media.tv.TvInputManager.releaseTvInputHardware",
          "documentation": "Releases previously acquired hardware object. @param deviceId The device ID\nthis Hardware was acquired for @param hardware Hardware to release. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1643
        }
      ]
    },
    "android.permission.CAPTURE_TV_INPUT": {
      "name": "android.permission.CAPTURE_TV_INPUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvInputManager.getAvailableTvStreamConfigList",
          "documentation": "Returns the TvStreamConfig list of the given TV input. If you are using {@link\nHardware} object from {@link #acquireTvInputHardware}, you should get the list\nof available streams from {@link HardwareCallback#onStreamConfigChanged}\nmethod, not from here. This method is designed to be used with {@link\n#captureFrame} in capture scenarios specifically and not suitable for any\nother use. @param inputId The ID of the TV input. @return List of {@link\nTvStreamConfig} which is available for capturing of the given TV input. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1520
        },
        {
          "method_name": "android.media.tv.TvInputManager.captureFrame",
          "documentation": "Take a snapshot of the given TV input into the provided Surface. @param\ninputId The ID of the TV input. @param surface the {@link Surface} to which\nthe snapshot is captured. @param config the {@link TvStreamConfig} which is\nused for capturing. @return true when the {@link Surface} is ready to be\ncaptured. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1539
        },
        {
          "method_name": "android.media.tv.TvInputManager.isSingleSessionActive",
          "documentation": "Returns true if there is only a single TV input session. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1554
        }
      ]
    },
    "android.permission.DVB_DEVICE": {
      "name": "android.permission.DVB_DEVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_CARRIER_OEM_UNLOCK_STATE": {
      "name": "android.permission.MANAGE_CARRIER_OEM_UNLOCK_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.service.oemlock.OemLockManager.setOemUnlockAllowedByCarrier",
          "documentation": "Sets whether the carrier has allowed this device to be OEM unlocked. Depending\non the implementation, the validity of the request might need to be proved.\nThis can be acheived by passing a signature that the system will use to verify\nthe request is legitimate. All actors involved must agree for OEM unlock to be\npossible. @param allowed Whether the device should be allowed to be unlocked.\n@param signature Optional proof of request validity, {@code null} for none.\n@throws IllegalArgumentException if a signature is required but was not\nprovided. @throws SecurityException if the wrong signature was provided. @see\n#isOemUnlockAllowedByCarrier()\n\n",
          "file": "./aosp/core/java/android/service/oemlock/OemLockManager.java",
          "line": 63
        },
        {
          "method_name": "android.service.oemlock.OemLockManager.isOemUnlockAllowedByCarrier",
          "documentation": "Returns whether the carrier has allowed this device to be OEM unlocked.\n@return Whether OEM unlock is allowed by the carrier, or true if no OEM lock\nis present. @see #setOemUnlockAllowedByCarrier(boolean, byte[])\n\n",
          "file": "./aosp/core/java/android/service/oemlock/OemLockManager.java",
          "line": 78
        }
      ]
    },
    "android.permission.MANAGE_USER_OEM_UNLOCK_STATE": {
      "name": "android.permission.MANAGE_USER_OEM_UNLOCK_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.service.oemlock.OemLockManager.setOemUnlockAllowedByUser",
          "documentation": "Sets whether the user has allowed this device to be unlocked. All actors\ninvolved must agree for OEM unlock to be possible. @param allowed Whether the\ndevice should be allowed to be unlocked. @throws SecurityException if the user\nis not allowed to unlock the device. @see #isOemUnlockAllowedByUser()\n\n",
          "file": "./aosp/core/java/android/service/oemlock/OemLockManager.java",
          "line": 97
        },
        {
          "method_name": "android.service.oemlock.OemLockManager.isOemUnlockAllowedByUser",
          "documentation": "Returns whether, or not, the user has allowed this device to be OEM unlocked.\n@return Whether OEM unlock is allowed by the user, or true if no OEM lock is\npresent. @see #setOemUnlockAllowedByUser(boolean)\n\n",
          "file": "./aosp/core/java/android/service/oemlock/OemLockManager.java",
          "line": 112
        }
      ]
    },
    "android.permission.READ_OEM_UNLOCK_STATE": {
      "name": "android.permission.READ_OEM_UNLOCK_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.getOemUnlockEnabled",
          "documentation": "Returns whether or not \"OEM unlock\" is enabled or disabled on this device.\n@deprecated use {@link OemLockManager#isOemUnlockAllowedByUser()} instead.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 180
        },
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.getFlashLockState",
          "documentation": "Retrieves available information about this device's flash lock state. @return\n{@link #FLASH_LOCK_LOCKED} if device bootloader is locked, {@link\n#FLASH_LOCK_UNLOCKED} if device bootloader is unlocked, or {@link\n#FLASH_LOCK_UNKNOWN} if this information cannot be ascertained on this device.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 200
        }
      ]
    },
    "android.permission.OEM_UNLOCK_STATE": {
      "name": "android.permission.OEM_UNLOCK_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.wipe",
          "documentation": "Zeroes the previously written block in its entirety. Calling this method will\nerase all data written to the persistent data partition. It will also prevent\nany further {@link #write} operation until reboot, in order to prevent a\npotential race condition. See b/30352311.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 149
        },
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.setOemUnlockEnabled",
          "documentation": "Writes a byte enabling or disabling the ability to \"OEM unlock\" the device.\n@deprecated use {@link OemLockManager#setOemUnlockAllowedByUser(boolean)}\ninstead.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 163
        },
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.getOemUnlockEnabled",
          "documentation": "Returns whether or not \"OEM unlock\" is enabled or disabled on this device.\n@deprecated use {@link OemLockManager#isOemUnlockAllowedByUser()} instead.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 180
        },
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.getFlashLockState",
          "documentation": "Retrieves available information about this device's flash lock state. @return\n{@link #FLASH_LOCK_LOCKED} if device bootloader is locked, {@link\n#FLASH_LOCK_UNLOCKED} if device bootloader is unlocked, or {@link\n#FLASH_LOCK_UNKNOWN} if this information cannot be ascertained on this device.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 200
        }
      ]
    },
    "android.permission.ACCESS_PDB_STATE": {
      "name": "android.permission.ACCESS_PDB_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.service.persistentdata.PersistentDataBlockManager.getDataBlockSize",
          "documentation": "Retrieves the size of the block currently written to the persistent partition.\nReturn -1 on error.\n\n",
          "file": "./aosp/core/java/android/service/persistentdata/PersistentDataBlockManager.java",
          "line": 120
        }
      ]
    },
    "android.permission.TEST_BLACKLISTED_PASSWORD": {
      "name": "android.permission.TEST_BLACKLISTED_PASSWORD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.NOTIFY_PENDING_SYSTEM_UPDATE": {
      "name": "android.permission.NOTIFY_PENDING_SYSTEM_UPDATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.admin.DevicePolicyManager.notifyPendingSystemUpdate",
          "documentation": "Called by the system update service to notify device and profile owners of\npending system updates. This method should be used instead of {@link\n#notifyPendingSystemUpdate(long)} when it is known whether the pending system\nupdate is a security patch. @param updateReceivedTime The time as given by\n{@link System#currentTimeMillis()} indicating when the current pending update\nwas first available. {@code -1} if no update is available. @param\nisSecurityPatch {@code true} if this system update is purely a security patch;\n{@code false} if not. @see #notifyPendingSystemUpdate(long) @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 7920
        }
      ]
    },
    "android.permission.CAMERA_DISABLE_TRANSMIT_LED": {
      "name": "android.permission.CAMERA_DISABLE_TRANSMIT_LED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CAMERA_SEND_SYSTEM_EVENTS": {
      "name": "android.permission.CAMERA_SEND_SYSTEM_EVENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MODIFY_PHONE_STATE": {
      "name": "android.permission.MODIFY_PHONE_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.telecom.TelecomManager.setUserSelectedOutgoingPhoneAccount",
          "documentation": "Sets the user-chosen default {@link PhoneAccountHandle} for making outgoing\nphone calls. @param accountHandle The {@link PhoneAccountHandle} which will be\nused by default for making outgoing voice calls. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 840
        },
        {
          "method_name": "android.telecom.TelecomManager.setDefaultDialer",
          "documentation": "Used to set the default dialer package. @param packageName to set the default\ndialer to. @result {@code true} if the default dialer was successfully\nchanged, {@code false} if the specified package does not correspond to an\ninstalled dialer, or is already the default dialer. Requires permission:\n{@link android.Manifest.permission#MODIFY_PHONE_STATE} Requires permission:\n{@link android.Manifest.permission#WRITE_SECURE_SETTINGS} @hide @deprecated\nUse RoleManager instead.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1250
        },
        {
          "method_name": "android.telecom.TelecomManager.acceptRingingCall",
          "documentation": "If there is a ringing incoming call, this method accepts the call on behalf of\nthe user, with the specified video state. Requires permission: {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE} or {@link\nandroid.Manifest.permission#ANSWER_PHONE_CALLS} @param videoState The desired\nvideo state to answer the call with. @deprecated Companion apps for wearable\ndevices should use the {@link InCallService} API instead.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1509
        },
        {
          "method_name": "android.telecom.TelecomManager.silenceRinger",
          "documentation": "Silences the ringer if a ringing call exists. Requires permission: {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE}\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1526
        },
        {
          "method_name": "android.telecom.TelecomManager.handleMmi",
          "documentation": "Processes the specified dial string as an MMI code. MMI codes are any sequence\nof characters entered into the dialpad that contain a \"*\" or \"#\". Some of\nthese sequences launch special behavior through handled by Telephony.\n\nRequires that the method-caller be set as the system dialer app.\n\nRequires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n@param accountHandle The handle for the account the MMI code should apply to.\n@param dialString The digits to dial. @return True if the digits were\nprocessed as an MMI code, false otherwise.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1691
        },
        {
          "method_name": "android.telecom.TelecomManager.getAdnUriForPhoneAccount",
          "documentation": "Requires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n@param accountHandle The handle for the account to derive an adn query URI for\nor {@code null} to return a URI which will use the default account. @return\nThe URI (with the content:// scheme) specific to the specified {@link\nPhoneAccount} for the the content retrieve.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1713
        },
        {
          "method_name": "android.telecom.TelecomManager.cancelMissedCallsNotification",
          "documentation": "Removes the missed-call notification if one is present.\n\nRequires that the method-caller be set as the system dialer app.\n\nRequires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1734
        },
        {
          "method_name": "android.telecom.TelecomManager.enablePhoneAccount",
          "documentation": "Enables and disables specified phone account. @param handle Handle to the\nphone account. @param isEnabled Enable state of the phone account. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1839
        },
        {
          "method_name": "android.telecom.TelecomManager.isInEmergencyCall",
          "documentation": "Determines if there is an ongoing emergency call. This can be either an\noutgoing emergency call, as identified by the dialed number, or because a call\nwas identified by the network as an emergency call. @return {@code true} if\nthere is an ongoing emergency call, {@code false} otherwise. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 2023
        },
        {
          "method_name": "android.telephony.AnomalyReporter.initialize",
          "documentation": "Initialize the AnomalyReporter with the current context. This method must be\ninvoked before any calls to reportAnomaly() will succeed. This method should\nonly be invoked at most once. @param context a Context object used to\ninitialize this singleton AnomalyReporter in the current process.\n\n",
          "file": "./aosp/telephony/java/android/telephony/AnomalyReporter.java",
          "line": 115
        },
        {
          "method_name": "android.telephony.CarrierConfigManager.overrideConfig",
          "documentation": "Overrides the carrier config of the provided subscription ID with the provided\nvalues. Any further queries to carrier config from any process will return the\noverridden values after this method returns. The overrides are effective for\nthe lifetime of the phone process until the user passes in {@code null} for\n{@code overrideValues}. This removes all previous overrides and sets the\ncarrier config back to production values. May throw an {@link\nIllegalArgumentException} if {@code overrideValues} contains invalid values\nfor the specified config keys. NOTE: This API is meant for testing purposes\nonly. @param subscriptionId The subscription ID for which the override should\nbe done. @param overrideValues Key-value pairs of the values that are to be\noverridden. If set to {@code null}, this will remove all previous overrides\nand set the carrier configuration back to production values. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/CarrierConfigManager.java",
          "line": 3275
        },
        {
          "method_name": "android.telephony.CarrierConfigManager.updateConfigForPhoneId",
          "documentation": "Request the carrier config loader to update the cofig for phoneId.\n\nDepending on simState, the config may be cleared or loaded from config app.\nThis is only used by SubscriptionInfoUpdater.\n\n@hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/CarrierConfigManager.java",
          "line": 3375
        },
        {
          "method_name": "android.telephony.SubscriptionManager.setDefaultSmsSubId",
          "documentation": "Set the subscription which will be used by default for SMS, with the\nsubscription which the supplied subscription ID corresponds to; or throw a\nRuntimeException if the supplied subscription ID is not usable (check with\n{@link #isUsableSubscriptionId(int)}). @param subscriptionId the supplied\nsubscription ID @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 1921
        },
        {
          "method_name": "android.telephony.SubscriptionManager.setDefaultDataSubId",
          "documentation": "Set the subscription which will be used by default for data, with the\nsubscription which the supplied subscription ID corresponds to; or throw a\nRuntimeException if the supplied subscription ID is not usable (check with\n{@link #isUsableSubscriptionId(int)}). @param subscriptionId the supplied\nsubscription ID @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 1985
        },
        {
          "method_name": "android.telephony.SubscriptionManager.setPreferredDataSubscriptionId",
          "documentation": "Set which subscription is preferred for cellular data. It's also usually the\nsubscription we set up internet connection on. PreferredData overwrites user\nsetting of default data subscription. And it's used by\nAlternativeNetworkService or carrier apps to switch primary and CBRS\nsubscription dynamically in multi-SIM devices. @param subId which subscription\nis preferred to for cellular data. If it's {@link\nSubscriptionManager#DEFAULT_SUBSCRIPTION_ID}, it means it's unset and {@link\nSubscriptionManager#getDefaultDataSubscriptionId()} is used to determine which\nmodem is preferred. @param needValidation whether Telephony will wait until\nthe network is validated by connectivity service before switching data to it.\nMore details see {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED}. @param\nexecutor The executor of where the callback will execute. @param callback\nCallback will be triggered once it succeeds or failed. Pass null if don't care\nabout the result. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2640
        },
        {
          "method_name": "android.telephony.SubscriptionManager.setOpportunistic",
          "documentation": "Set whether a subscription is opportunistic, that is, whether the network it\nconnects to has limited coverage. For example, CBRS. Setting a subscription\nopportunistic has following impacts: 1) Even if it's active, it will be\ndormant most of the time. The modem will not try to scan or camp until it\nknows an available network is nearby to save power. 2) Telephony relies on\nsystem app or carrier input to notify nearby available networks. See {@link\nTelephonyManager#updateAvailableNetworks(List, Executor, Consumer)} for more\ninformation. 3) In multi-SIM devices, when the network is nearby and camped,\nsystem may automatically switch internet data between it and default data\nsubscription, based on carrier recommendation and its signal strength and\nmetered-ness, etc. Caller will either have {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE} or carrier privilege\npermission of the subscription. @param opportunistic whether it\u2019s\nopportunistic subscription. @param subId the unique SubscriptionInfo index in\ndatabase @return {@code true} if the operation is succeed, {@code false}\notherwise.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2764
        },
        {
          "method_name": "android.telephony.SubscriptionManager.createSubscriptionGroup",
          "documentation": "Inform SubscriptionManager that subscriptions in the list are bundled as a\ngroup. It can be multiple primary (non-opportunistic) subscriptions, or one or\nmore primary plus one or more opportunistic subscriptions. This API will\nalways create a new immutable group and assign group UUID to all the\nsubscriptions, regardless whether they are in a group already or not. Grouped\nsubscriptions will have below behaviors: 1) They will share the same user\nsettings. 2) The opportunistic subscriptions in the group is considered\ninvisible and will not return from {@link #getActiveSubscriptionInfoList()},\nunless caller has carrier privilege permission of the subscriptions. 3) The\nopportunistic subscriptions in the group can't be active by itself. If all\nother non-opportunistic ones are deactivated (unplugged or disabled in\nSettings), the opportunistic ones will be deactivated automatically. Caller\nwill either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\npermission or had carrier privilege permission on the subscriptions: {@link\nTelephonyManager#hasCarrierPrivileges()} or {@link\n#canManageSubscription(SubscriptionInfo)} @throws SecurityException if the\ncaller doesn't meet the requirements outlined above. @throws\nIllegalArgumentException if any of the subscriptions in the list doesn't\nexist. @throws IllegalStateException if Telephony service is in bad state.\n@param subIdList list of subId that will be in the same group @return\ngroupUUID a UUID assigned to the subscription group.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2804
        },
        {
          "method_name": "android.telephony.SubscriptionManager.addSubscriptionsIntoGroup",
          "documentation": "Add a list of subscriptions into a group. See {@link\n#createSubscriptionGroup(List)} for more details. Caller will either have\n{@link android.Manifest.permission#MODIFY_PHONE_STATE} permission or had\ncarrier privilege permission on the subscriptions: {@link\nTelephonyManager#hasCarrierPrivileges()} or {@link\n#canManageSubscription(SubscriptionInfo)} @throws SecurityException if the\ncaller doesn't meet the requirements outlined above. @throws\nIllegalArgumentException if the some subscriptions in the list doesn't exist,\nor the groupUuid doesn't exist. @throws IllegalStateException if Telephony\nservice is in bad state. @param subIdList list of subId that need adding into\nthe group @param groupUuid the groupUuid the subscriptions are being added to.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2853
        },
        {
          "method_name": "android.telephony.SubscriptionManager.removeSubscriptionsFromGroup",
          "documentation": "Remove a list of subscriptions from their subscription group. See {@link\n#createSubscriptionGroup(List)} for more details. Caller will either have\n{@link android.Manifest.permission#MODIFY_PHONE_STATE} permission or had\ncarrier privilege permission on the subscriptions: {@link\nTelephonyManager#hasCarrierPrivileges()} or {@link\n#canManageSubscription(SubscriptionInfo)} @throws SecurityException if the\ncaller doesn't meet the requirements outlined above. @throws\nIllegalArgumentException if the some subscriptions in the list doesn't belong\nthe specified group. @throws IllegalStateException if Telephony service is in\nbad state. @param subIdList list of subId that need removing from their\ngroups.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2905
        },
        {
          "method_name": "android.telephony.SubscriptionManager.setSubscriptionEnabled",
          "documentation": "Enables or disables a subscription. This is currently used in the settings\npage.\n\nPermissions android.Manifest.permission.MODIFY_PHONE_STATE is required @param\nenable whether user is turning it on or off. @param subscriptionId\nSubscription to be enabled or disabled. It could be a eSIM or pSIM\nsubscription. @return whether the operation is successful. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 3064
        },
        {
          "method_name": "android.telephony.TelephonyManager.refreshUiccProfile",
          "documentation": "Test method to reload the UICC profile. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3384
        },
        {
          "method_name": "android.telephony.TelephonyManager.switchSlots",
          "documentation": "Map logicalSlot to physicalSlot, and activate the physicalSlot if it is\ninactive. For example, passing the physicalSlots array [1, 0] means mapping\nthe first item 1, which is physical slot index 1, to the logical slot 0; and\nmapping the second item 0, which is physical slot index 0, to the logical slot\n1. The index of the array means the index of the logical slots. @param\nphysicalSlots The content of the array represents the physical slot index. The\narray size should be same as {@link #getUiccSlotsInfo()}. @return boolean\nReturn true if the switch succeeds, false if the switch fails. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3407
        },
        {
          "method_name": "android.telephony.TelephonyManager.setVoiceActivationState",
          "documentation": "Sets the voice activation state for the given subscriber.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param subId The subscription id. @param\nactivationState The voice activation state of the given subscriber. @see\n#SIM_ACTIVATION_STATE_UNKNOWN @see #SIM_ACTIVATION_STATE_ACTIVATING @see\n#SIM_ACTIVATION_STATE_ACTIVATED @see #SIM_ACTIVATION_STATE_DEACTIVATED @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4328
        },
        {
          "method_name": "android.telephony.TelephonyManager.setDataActivationState",
          "documentation": "Sets the data activation state for the given subscriber.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param subId The subscription id. @param\nactivationState The data activation state of the given subscriber. @see\n#SIM_ACTIVATION_STATE_UNKNOWN @see #SIM_ACTIVATION_STATE_ACTIVATING @see\n#SIM_ACTIVATION_STATE_ACTIVATED @see #SIM_ACTIVATION_STATE_DEACTIVATED @see\n#SIM_ACTIVATION_STATE_RESTRICTED @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4376
        },
        {
          "method_name": "android.telephony.TelephonyManager.requestCellInfoUpdate",
          "documentation": "Requests all available cell information from the current subscription for\nobserved camped/registered, serving, and neighboring cells.\n\nAny available results from this request will be provided by calls to {@link\nandroid.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}\nfor each active subscription. @param workSource the requestor to whom the\npower consumption for this should be attributed. @param executor the executor\non which callback will be invoked. @param callback a callback to receive\nCellInfo. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5223
        },
        {
          "method_name": "android.telephony.TelephonyManager.iccOpenLogicalChannelBySlot",
          "documentation": "Opens a logical channel to the ICC card using the physical slot index. Use\nthis method when no subscriptions are available on the SIM and the operation\nmust be performed using the physical slot index. This operation wraps two APDU\ninstructions:\n\n  * MANAGE CHANNEL to open a logical channel\n  * SELECT the given {@code AID} using the given {@code p2}\n\nPer Open Mobile API Specification v3.2 section 6.2.7.h, only p2 values of\n0x00, 0x04, 0x08, and 0x0C are guaranteed to be supported. If the SELECT\ncommand's status word is not '9000', '62xx', or '63xx', the status word will\nbe considered an error and the channel shall not be opened. Input parameters\nequivalent to TS 27.007 AT+CCHO command.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param slotIndex the physical slot index of the ICC card\n@param aid Application id. See ETSI 102.221 and 101.220. @param p2 P2\nparameter (described in ISO 7816-4). @return an IccOpenLogicalChannelResponse\nobject. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5348
        },
        {
          "method_name": "android.telephony.TelephonyManager.iccCloseLogicalChannelBySlot",
          "documentation": "Closes a previously opened logical channel to the ICC card using the physical\nslot index. Use this method when no subscriptions are available on the SIM and\nthe operation must be performed using the physical slot index. Input\nparameters equivalent to TS 27.007 AT+CCHC command.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param slotIndex the physical slot index of the ICC card\n@param channel is the channel id to be closed as returned by a successful\niccOpenLogicalChannel. @return true if the channel was closed successfully.\n@hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5448
        },
        {
          "method_name": "android.telephony.TelephonyManager.iccTransmitApduLogicalChannelBySlot",
          "documentation": "Transmit an APDU to the ICC card over a logical channel using the physical\nslot index. Use this method when no subscriptions are available on the SIM and\nthe operation must be performed using the physical slot index. Input\nparameters equivalent to TS 27.007 AT+CGLA command.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param slotIndex the physical slot index of the ICC card\n@param channel is the channel id to be closed as returned by a successful\niccOpenLogicalChannel. @param cla Class of the APDU command. @param\ninstruction Instruction of the APDU command. @param p1 P1 value of the APDU\ncommand. @param p2 P2 value of the APDU command. @param p3 P3 value of the\nAPDU command. If p3 is negative a 4 byte APDU is sent to the SIM. @param data\nData to be sent with the APDU. @return The APDU response from the ICC card\nwith the status appended at the end, or null if there is an issue connecting\nto the Telephony service. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5531
        },
        {
          "method_name": "android.telephony.TelephonyManager.iccTransmitApduBasicChannelBySlot",
          "documentation": "Transmit an APDU to the ICC card over the basic channel using the physical\nslot index. Use this method when no subscriptions are available on the SIM and\nthe operation must be performed using the physical slot index. Input\nparameters equivalent to TS 27.007 AT+CSIM command.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param slotIndex the physical slot index of the ICC card\nto target @param cla Class of the APDU command. @param instruction Instruction\nof the APDU command. @param p1 P1 value of the APDU command. @param p2 P2\nvalue of the APDU command. @param p3 P3 value of the APDU command. If p3 is\nnegative a 4 byte APDU is sent to the SIM. @param data Data to be sent with\nthe APDU. @return The APDU response from the ICC card with the status appended\nat the end. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5634
        },
        {
          "method_name": "android.telephony.TelephonyManager.resetRadioConfig",
          "documentation": "Rollback modem configurations to factory default except some config which are\nin whitelist. Used for device configuration by some carriers.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @return {@code true} on success; {@code false} on any\nfailure. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5933
        },
        {
          "method_name": "android.telephony.TelephonyManager.rebootRadio",
          "documentation": "Generate a radio modem reset. Used for device configuration by some carriers.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @return {@code true} on success; {@code false} on any\nfailure. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 5960
        },
        {
          "method_name": "android.telephony.TelephonyManager.requestNumberVerification",
          "documentation": "Request that the next incoming call from a number matching {@code range} be\nintercepted. This API is intended for OEMs to provide a service for apps to\nverify the device's phone number. When called, the Telephony stack will store\nthe provided {@link PhoneNumberRange} and intercept the next incoming call\nfrom a number that lies within the range, within a timeout specified by {@code\ntimeoutMillis}. If such a phone call is received, the caller will be notified\nvia {@link NumberVerificationCallback#onCallReceived(String)} on the provided\n{@link Executor}. If verification fails for any reason, the caller will be\nnotified via {@link NumberVerificationCallback#onVerificationFailed(int)} on\nthe provided {@link Executor}. In addition to the {@link\nManifest.permission#MODIFY_PHONE_STATE} permission, callers of this API must\nalso be listed in the device configuration as an authorized app in {@code\npackages/services/Telephony/res/values/config.xml} under the {@code\nconfig_number_verification_package_name} key. @hide @param range The range of\nphone numbers the caller expects a phone call from. @param timeoutMillis The\namount of time to wait for such a call, or the value of {@link\n#getMaxNumberVerificationTimeoutMillis()}, whichever is lesser. @param\nexecutor The {@link Executor} that callbacks should be executed on. @param\ncallback The callback to use for delivering results.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6079
        },
        {
          "method_name": "android.telephony.TelephonyManager.setNetworkSelectionModeAutomatic",
          "documentation": "Sets the network selection mode to automatic.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}).\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6982
        },
        {
          "method_name": "android.telephony.TelephonyManager.getAvailableNetworks",
          "documentation": "Perform a radio scan and return the list of available networks.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nNote that this scan can take a long time (sometimes minutes) to happen.\n\nRequires Permissions: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\nor that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}) and {@link\nandroid.Manifest.permission#ACCESS_COARSE_LOCATION}. @return {@link\nCellNetworkScanResult} with the status {@link\nCellNetworkScanResult#STATUS_SUCCESS} and a list of {@link\ncom.android.internal.telephony.OperatorInfo} if it's available. Otherwise, the\nfailure caused will be included in the result. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7019
        },
        {
          "method_name": "android.telephony.TelephonyManager.requestNetworkScan",
          "documentation": "@deprecated Use {@link #requestNetworkScan(NetworkScanRequest, Executor,\nTelephonyScanManager.NetworkScanCallback)} @removed\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7092
        },
        {
          "method_name": "android.telephony.TelephonyManager.setNetworkSelectionModeManual",
          "documentation": "Ask the radio to connect to the input network and change selection mode to\nmanual.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param operatorInfo included the PLMN id, long name,\nshort name of the operator to attach to. @param persistSelection whether the\nselection will persist until reboot. If true, only allows attaching to the\nselected PLMN until reboot; otherwise, attach to the chosen PLMN and resume\nnormal network selection next time. @return {@code true} on success; {@code\ntrue} on any failure. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7141
        },
        {
          "method_name": "android.telephony.TelephonyManager.setPreferredNetworkTypeBitmask",
          "documentation": "Set the preferred network type bitmask.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param networkTypeBitmask The bitmask of preferred\nnetwork types. @return true on success; false on any failure. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7250
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaMdn",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7491
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCdmaMin",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7514
        },
        {
          "method_name": "android.telephony.TelephonyManager.answerRingingCall",
          "documentation": "@removed Use {@link android.telecom.TelecomManager#acceptRingingCall} instead\n@hide @removed\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7646
        },
        {
          "method_name": "android.telephony.TelephonyManager.supplyPin",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7730
        },
        {
          "method_name": "android.telephony.TelephonyManager.supplyPuk",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7744
        },
        {
          "method_name": "android.telephony.TelephonyManager.supplyPinReportResult",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7758
        },
        {
          "method_name": "android.telephony.TelephonyManager.supplyPukReportResult",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7772
        },
        {
          "method_name": "android.telephony.TelephonyManager.handlePinMmi",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7892
        },
        {
          "method_name": "android.telephony.TelephonyManager.handlePinMmiForSubscriber",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7906
        },
        {
          "method_name": "android.telephony.TelephonyManager.toggleRadioOnOff",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7920
        },
        {
          "method_name": "android.telephony.TelephonyManager.setRadio",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7933
        },
        {
          "method_name": "android.telephony.TelephonyManager.setRadioPower",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7947
        },
        {
          "method_name": "android.telephony.TelephonyManager.enableDataConnectivity",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8028
        },
        {
          "method_name": "android.telephony.TelephonyManager.disableDataConnectivity",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8042
        },
        {
          "method_name": "android.telephony.TelephonyManager.setDataEnabled",
          "documentation": "@hide @deprecated use {@link #setDataEnabled(boolean)} instead.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8105
        },
        {
          "method_name": "android.telephony.TelephonyManager.isDataEnabled",
          "documentation": "Returns whether mobile data is enabled or not per user setting. There are\nother factors that could disable mobile data, but they are not considered\nhere. If this object has been created with {@link #createForSubscriptionId},\napplies to the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires one of the following permissions: {@link\nandroid.Manifest.permission#ACCESS_NETWORK_STATE}, {@link\nandroid.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}).\n\nNote that this does not take into account any data restrictions that may be\npresent on the calling app. Such restrictions may be inspected with {@link\nConnectivityManager#getRestrictBackgroundStatus}. @return true if mobile data\nis enabled.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8146
        },
        {
          "method_name": "android.telephony.TelephonyManager.setCdmaRoamingMode",
          "documentation": "Sets the roaming mode for CDMA phone to the given mode {@code mode}.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()} @param mode should be one of\n{@link #CDMA_ROAMING_MODE_RADIO_DEFAULT}, {@link #CDMA_ROAMING_MODE_HOME},\n{@link #CDMA_ROAMING_MODE_AFFILIATED}, {@link #CDMA_ROAMING_MODE_ANY}. @return\n{@code true} if successed. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8220
        },
        {
          "method_name": "android.telephony.TelephonyManager.setCdmaSubscriptionMode",
          "documentation": "Sets the subscription mode for CDMA phone to the given mode {@code mode}.\n@param mode CDMA subscription mode @return {@code true} if successed. @see\nPhone#CDMA_SUBSCRIPTION_UNKNOWN @see Phone#CDMA_SUBSCRIPTION_RUIM_SIM @see\nPhone#CDMA_SUBSCRIPTION_NV @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8246
        },
        {
          "method_name": "android.telephony.TelephonyManager.setDataRoamingEnabled",
          "documentation": "Enables/Disables the data roaming on the subscription.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE} or\nthat the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @param isEnabled {@code true} to enable mobile data\nroaming, otherwise disable it. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8274
        },
        {
          "method_name": "android.telephony.TelephonyManager.enableVideoCalling",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8330
        },
        {
          "method_name": "android.telephony.TelephonyManager.setSimPowerState",
          "documentation": "Set SIM card power state. @param state State of SIM (power down, power up,\npass through) @see #CARD_POWER_DOWN @see #CARD_POWER_UP @see\n#CARD_POWER_UP_PASS_THROUGH Callers should monitor for {@link\nTelephonyIntents#ACTION_SIM_STATE_CHANGED} broadcasts to determine success or\nfailure and timeout if needed.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} {@hide}\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8691
        },
        {
          "method_name": "android.telephony.TelephonyManager.setSimPowerStateForSlot",
          "documentation": "Set SIM card power state. @param slotIndex SIM slot id @param state State of\nSIM (power down, power up, pass through) @see #CARD_POWER_DOWN @see\n#CARD_POWER_UP @see #CARD_POWER_UP_PASS_THROUGH Callers should monitor for\n{@link TelephonyIntents#ACTION_SIM_STATE_CHANGED} broadcasts to determine\nsuccess or failure and timeout if needed.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} {@hide}\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8713
        },
        {
          "method_name": "android.telephony.TelephonyManager.getTelephonyHistograms",
          "documentation": "Get snapshot of Telephony histograms @return List of Telephony histograms\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} Or the calling app has carrier privileges. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9575
        },
        {
          "method_name": "android.telephony.TelephonyManager.setAllowedCarriers",
          "documentation": "Set the allowed carrier list for slotIndex Require system privileges. In the\nfuture we may add this to carrier APIs.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n\nThis method works only on devices with {@link\nandroid.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n@deprecated use setCarrierRestrictionRules instead @return The number of\ncarriers set successfully. Should be length of carrierList on success; -1 if\ncarrierList null or on error. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9605
        },
        {
          "method_name": "android.telephony.TelephonyManager.setCarrierRestrictionRules",
          "documentation": "Set the allowed carrier list and the excluded carrier list indicating the\npriority between the two lists. Requires system privileges.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n\nThis method works only on devices with {@link\nandroid.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n@return {@link #SET_CARRIER_RESTRICTION_SUCCESS} in case of success. {@link\n#SET_CARRIER_RESTRICTION_NOT_SUPPORTED} if the modem does not support the\nconfiguration. {@link #SET_CARRIER_RESTRICTION_ERROR} in all other error\ncases. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9679
        },
        {
          "method_name": "android.telephony.TelephonyManager.setCarrierDataEnabled",
          "documentation": "Used to enable or disable carrier data by the system based on carrier\nsignalling or carrier privileged apps. Different from {@link\n#setDataEnabled(boolean)} which is linked to user settings, carrier data\non/off won't affect user settings but will bypass the settings and turns off\ndata internally if set to {@code false}.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultDataSubscriptionId()}\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param enabled control enable or disable carrier data.\n@hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9768
        },
        {
          "method_name": "android.telephony.TelephonyManager.setRadioIndicationUpdateMode",
          "documentation": "Sets radio indication update mode. This can be used to control the behavior of\nindication update from modem to Android frameworks. For example, by default\nseveral indication updates are turned off when screen is off, but in some\nspecial cases (e.g. carkit is connected but screen is off) we want to turn on\nthose indications even when the screen is off.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} @param filters Indication filters. Should be a bitmask of\nINDICATION_FILTER_XXX. @see #INDICATION_FILTER_SIGNAL_STRENGTH @see\n#INDICATION_FILTER_FULL_NETWORK_STATE @see\n#INDICATION_FILTER_DATA_CALL_DORMANCY_CHANGED @param updateMode The voice\nactivation state @see #INDICATION_UPDATE_MODE_NORMAL @see\n#INDICATION_UPDATE_MODE_IGNORE_SCREEN_OFF @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10072
        },
        {
          "method_name": "android.telephony.TelephonyManager.setOpportunisticNetworkState",
          "documentation": "Enable or disable OpportunisticNetworkService. This method should be called to\nenable or disable OpportunisticNetwork service on the device.\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} @param enable enable(True) or disable(False) @return\nreturns true if successfully set. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10165
        },
        {
          "method_name": "android.telephony.TelephonyManager.enableModemForSlot",
          "documentation": "Enable or disable a logical modem stack. When a logical modem is disabled, the\ncorresponding SIM will still be visible to the user but its mapping modem will\nnot have any radio activity. For example, we will disable a modem when user or\nsystem believes the corresponding SIM is temporarily not needed (e.g. out of\ncoverage), and will enable it back on when needed. Requires that the calling\napp has permission {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE}. @param slotIndex which corresponding modem will operate\non. @param enable whether to enable or disable the modem stack. @return\nwhether the operation is successful. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10765
        },
        {
          "method_name": "android.telephony.TelephonyManager.setMultiSimCarrierRestriction",
          "documentation": "Indicate if the user is allowed to use multiple SIM cards at the same time to\nregister on the network (e.g. Dual Standby or Dual Active) when the device\nsupports it, or if the usage is restricted. This API is used to prevent usage\nof multiple SIM card, based on policies of the carrier.\n\nNote: the API does not prevent access to the SIM cards for operations that\ndon't require access to the network. @param isMultiSimCarrierRestricted true\nif usage of multiple SIMs is restricted, false otherwise. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10812
        },
        {
          "method_name": "android.telephony.TelephonyManager.switchMultiSimConfig",
          "documentation": "Switch configs to enable multi-sim or switch back to single-sim\n\nRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\nMODIFY_PHONE_STATE} or that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}). Note: with only carrier privileges, it is not allowed\nto switch from multi-sim to single-sim @param numOfSims number of live SIMs we\nwant to switch to @throws android.os.RemoteException\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10913
        },
        {
          "method_name": "android.telephony.TelephonyManager.setDataAllowedDuringVoiceCall",
          "documentation": "Set allowing mobile data during voice call. @param allow {@code true} if\nallowing using data during voice call, {@code false} if disallowed @return\n{@code false} if the setting is changed. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 11036
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setAdvancedCallingSettingEnabled",
          "documentation": "Modify the user\u2019s setting for \u201cAdvanced Calling\u201d or \"Enhanced 4G LTE\", which\nis used to enable MmTel IMS features, depending on the carrier configuration\nfor the current subscription. If this setting is enabled, IMS voice and video\ntelephony over IWLAN/LTE will be enabled as long as the carrier has\nprovisioned these services for the specified subscription. Other IMS services\n(SMS/UT) are not affected by this user setting and depend on carrier\nrequirements. Modifying this value may also trigger an IMS registration or\nderegistration, depending on whether or not the new value is enabled or\ndisabled. Note: If the carrier configuration for advanced calling is not\neditable or hidden, this method will do nothing and will instead always use\nthe default value. @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL\n@see android.telephony.CarrierConfigManager#KEY_EDITABLE_ENHANCED_4G_LTE_BOOL\n@see android.telephony.CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL @see\nandroid.telephony.CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL\n@see android.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_AVAILABLE_BOOL\n@see #isAdvancedCallingSettingEnabled()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 531
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVtSettingEnabled",
          "documentation": "Change the user's setting for Video Telephony and enable the Video Telephony\ncapability. @see #isVtSettingEnabled()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 617
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVoWiFiSettingEnabled",
          "documentation": "Sets the user's setting for whether or not Voice over WiFi is enabled. @param\nisEnabled true if the user's setting for Voice over WiFi is enabled, false\notherwise= @see #isVoWiFiSettingEnabled()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 645
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVoWiFiRoamingSettingEnabled",
          "documentation": "Change the user's setting for Voice over WiFi while roaming. @param isEnabled\ntrue if the user's setting for Voice over WiFi while roaming is enabled, false\notherwise. @see #isVoWiFiRoamingSettingEnabled()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 675
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVoWiFiNonPersistent",
          "documentation": "Overrides the Voice over WiFi capability to true for IMS, but do not persist\nthe setting. Typically used during the Voice over WiFi registration process\nfor some carriers. @param isCapable true if the IMS stack should try to\nregister for IMS over IWLAN, false otherwise. @param mode the Voice over WiFi\nmode preference to set, which can be one of the following: - {@link\n#WIFI_MODE_WIFI_ONLY} - {@link #WIFI_MODE_CELLULAR_PREFERRED} - {@link\n#WIFI_MODE_WIFI_PREFERRED} @see #setVoWiFiSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 697
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVoWiFiModeSetting",
          "documentation": "Set the user's preference for Voice over WiFi calling mode. @param mode The\nuser's preference for the technology to register for IMS over, can be one of\nthe following: - {@link #WIFI_MODE_WIFI_ONLY} - {@link\n#WIFI_MODE_CELLULAR_PREFERRED} - {@link #WIFI_MODE_WIFI_PREFERRED} @see\n#getVoWiFiModeSetting()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 733
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setVoWiFiRoamingModeSetting",
          "documentation": "Set the user's preference for Voice over WiFi mode while the device is roaming\non another network. @param mode The user's preference for the technology to\nregister for IMS over when roaming on another network, can be one of the\nfollowing: - {@link #WIFI_MODE_WIFI_ONLY} - {@link\n#WIFI_MODE_CELLULAR_PREFERRED} - {@link #WIFI_MODE_WIFI_PREFERRED} @see\n#getVoWiFiRoamingModeSetting()\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 774
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.setRttCapabilitySetting",
          "documentation": "Sets the capability of RTT for IMS calls placed on this subscription. Note:\nThis does not affect the value of {@link\nandroid.provider.Settings.Secure#RTT_CALLING_MODE}, which is the global user\nsetting for RTT. That value is enabled/disabled separately by the user through\nthe Accessibility settings. @param isEnabled if true RTT should be enabled\nduring calls made on this subscription.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 793
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.setProvisioningIntValue",
          "documentation": "Set the integer value associated with the provided key. This operation is\nblocking and should not be performed on the UI thread. Use {@link\n#setProvisioningStringValue(int, String)} with proper namespacing (to be\ndefined per OEM or carrier) when possible instead to avoid key collision if\nneeded. @param key An integer that represents the provisioning key, which is\ndefined by the OEM. @param value a integer value for the provided key. @return\nthe result of setting the configuration value.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 310
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.setProvisioningStringValue",
          "documentation": "Set the String value associated with the provided key. This operation is\nblocking and should not be performed on the UI thread. @param key A String\nthat represents the provisioning key, which is defined by the OEM and should\nbe appropriately namespaced to avoid collision. @param value a String value\nfor the provided key. @return the result of setting the configuration value.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 330
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.setProvisioningStatusForCapability",
          "documentation": "Set the provisioning status for the IMS MmTel capability using the specified\nsubscription. Provisioning may or may not be required, depending on the\ncarrier configuration. If provisioning is not required for the carrier\nassociated with this subscription or the device does not support the\ncapability/technology combination specified, this operation will be a no-op.\n@see CarrierConfigManager#KEY_CARRIER_UT_PROVISIONING_REQUIRED_BOOL @see\nCarrierConfigManager#KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL @param\nisProvisioned true if the device is provisioned for UT over IMS, false\notherwise.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 353
        }
      ]
    },
    "android.permission.READ_PRECISE_PHONE_STATE": {
      "name": "android.permission.READ_PRECISE_PHONE_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.telephony.PhoneStateListener.onPreciseCallStateChanged",
          "documentation": "Callback invoked when precise device call state changes on the registered\nsubscription. Note, the registration subId comes from {@link TelephonyManager}\nobject which registers PhoneStateListener by {@link\nTelephonyManager#listen(PhoneStateListener, int)}. If this TelephonyManager\nobject was created with {@link TelephonyManager#createForSubscriptionId(int)},\nthen the callback applies to the subId. Otherwise, this callback applies to\n{@link SubscriptionManager#getDefaultSubscriptionId()}. @param callState\n{@link PreciseCallState} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/PhoneStateListener.java",
          "line": 648
        },
        {
          "method_name": "android.telephony.PhoneStateListener.onCallDisconnectCauseChanged",
          "documentation": "Callback invoked when call disconnect cause changes on the registered\nsubscription. Note, the registration subId comes from {@link TelephonyManager}\nobject which registers PhoneStateListener by {@link\nTelephonyManager#listen(PhoneStateListener, int)}. If this TelephonyManager\nobject was created with {@link TelephonyManager#createForSubscriptionId(int)},\nthen the callback applies to the subId. Otherwise, this callback applies to\n{@link SubscriptionManager#getDefaultSubscriptionId()}. @param disconnectCause\n{@link DisconnectCause}. @param preciseDisconnectCause {@link\nPreciseDisconnectCause}. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/PhoneStateListener.java",
          "line": 668
        },
        {
          "method_name": "android.telephony.PhoneStateListener.onImsCallDisconnectCauseChanged",
          "documentation": "Callback invoked when Ims call disconnect cause changes on the registered\nsubscription. Note, the registration subId comes from {@link TelephonyManager}\nobject which registers PhoneStateListener by {@link\nTelephonyManager#listen(PhoneStateListener, int)}. If this TelephonyManager\nobject was created with {@link TelephonyManager#createForSubscriptionId(int)},\nthen the callback applies to the subId. Otherwise, this callback applies to\n{@link SubscriptionManager#getDefaultSubscriptionId()}. @param imsReasonInfo\n{@link ImsReasonInfo} contains details on why IMS call failed. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/PhoneStateListener.java",
          "line": 687
        },
        {
          "method_name": "android.telephony.PhoneStateListener.onPreciseDataConnectionStateChanged",
          "documentation": "Callback invoked when data connection state changes with precise information\non the registered subscription. Note, the registration subId comes from {@link\nTelephonyManager} object which registers PhoneStateListener by {@link\nTelephonyManager#listen(PhoneStateListener, int)}. If this TelephonyManager\nobject was created with {@link TelephonyManager#createForSubscriptionId(int)},\nthen the callback applies to the subId. Otherwise, this callback applies to\n{@link SubscriptionManager#getDefaultSubscriptionId()}. @param\ndataConnectionState {@link PreciseDataConnectionState} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/PhoneStateListener.java",
          "line": 707
        }
      ]
    },
    "android.permission.READ_PRIVILEGED_PHONE_STATE": {
      "name": "android.permission.READ_PRIVILEGED_PHONE_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.security.keystore.AttestationUtils.attestDeviceIds",
          "documentation": "Performs attestation of the device's identifiers. This method returns a\ncertificate chain whose first element contains the requested device\nidentifiers in an extension. The device's manufacturer, model, brand, device\nand product are always also included in the attestation. If the device\nsupports attestation in secure hardware, the chain will be rooted at a\ntrustworthy CA key. Otherwise, the chain will be rooted at an untrusted\ncertificate. See [ Key\nAttestation](https://developer.android.com/training/articles/security-key-\nattestation.html) for the format of the certificate extension.\n\nAttestation will only be successful when all of the following are true: 1) The\ndevice has been set up to support device identifier attestation at the\nfactory. 2) The user has not permanently disabled device identifier\nattestation. 3) You have permission to access the device identifiers you are\nrequesting attestation for.\n\nFor privacy reasons, you cannot distinguish between (1) and (2). If\nattestation is unsuccessful, the device may not support it in general or the\nuser may have permanently disabled it. @param context the context to use for\nretrieving device identifiers. @param idTypes the types of device identifiers\nto attest. @param attestationChallenge a blob to include in the certificate\nalongside the device identifiers. @return a certificate chain containing the\nrequested device identifiers in the first element @exception SecurityException\nif you are not permitted to obtain an attestation of the device's identifiers.\n@exception DeviceIdAttestationException if the attestation operation fails.\n\n",
          "file": "./aosp/keystore/java/android/security/keystore/AttestationUtils.java",
          "line": 248
        },
        {
          "method_name": "android.telecom.TelecomManager.getPhoneAccountsSupportingScheme",
          "documentation": "Returns a list of the {@link PhoneAccountHandle}s which can be used to make\nand receive phone calls which support the specified URI scheme.\n\nFor example, invoking with {@code \"tel\"} will find all {@link\nPhoneAccountHandle}s which support telephone calls (e.g. URIs such as {@code\ntel:555-555-1212}). Invoking with {@code \"sip\"} will find all {@link\nPhoneAccountHandle}s which support SIP calls (e.g. URIs such as {@code\nsip:example@sipexample.com}). @param uriScheme The URI scheme. @return A list\nof {@code PhoneAccountHandle} objects supporting the URI scheme. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 947
        },
        {
          "method_name": "android.telecom.TelecomManager.isRinging",
          "documentation": "Returns whether there currently exists is a ringing incoming-call. @return\n{@code true} if there is a managed or self-managed ringing call. @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1427
        },
        {
          "method_name": "android.telecom.TelecomManager.isTtySupported",
          "documentation": "Returns whether TTY is supported on this device.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1543
        },
        {
          "method_name": "android.telecom.TelecomManager.getCurrentTtyMode",
          "documentation": "Returns the current TTY mode of the device. For TTY to be on the user must\nenable it in settings and have a wired headset plugged in. Valid modes are: -\n{@link TelecomManager#TTY_MODE_OFF} - {@link TelecomManager#TTY_MODE_FULL} -\n{@link TelecomManager#TTY_MODE_HCO} - {@link TelecomManager#TTY_MODE_VCO}\n@hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1567
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getPreferredDataSubscriptionId",
          "documentation": "Get which subscription is preferred for cellular data. It's also usually the\nsubscription we set up internet connection on. PreferredData overwrites user\nsetting of default data subscription. And it's used by\nAlternativeNetworkService or carrier apps to switch primary and CBRS\nsubscription dynamically in multi-SIM devices. @return preferred subscription\nid for cellular data. {@link DEFAULT_SUBSCRIPTION_ID} if there's no prefered\nsubscription. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2680
        },
        {
          "method_name": "android.telephony.SubscriptionManager.isSubscriptionEnabled",
          "documentation": "DO NOT USE. This API is designed for features that are not finished at this\npoint. Do not call this API. @hide TODO b/135547512: further clean up\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 3088
        },
        {
          "method_name": "android.telephony.SubscriptionManager.getEnabledSubscriptionId",
          "documentation": "DO NOT USE. This API is designed for features that are not finished at this\npoint. Do not call this API. @hide TODO b/135547512: further clean up\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 3109
        },
        {
          "method_name": "android.telephony.TelephonyManager.getUiccCardsInfo",
          "documentation": "Gets information about currently inserted UICCs and eUICCs.\n\nRequires that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}).\n\nIf the caller has carrier priviliges on any active subscription, then they\nhave permission to get simple information like the card ID ({@link\nUiccCardInfo#getCardId()}), whether the card is an eUICC ({@link\nUiccCardInfo#isEuicc()}), and the slot index where the card is inserted\n({@link UiccCardInfo#getSlotIndex()}).\n\nTo get private information such as the EID ({@link UiccCardInfo#getEid()}) or\nICCID ({@link UiccCardInfo#getIccId()}), the caller must have carrier\npriviliges on that specific UICC or eUICC card.\n\nSee {@link UiccCardInfo} for more details on the kind of information\navailable. @return a list of UiccCardInfo objects, representing information on\nthe currently inserted UICCs and eUICCs. Each UiccCardInfo in the list will\nhave private information filtered out if the caller does not have adequate\npermissions for that card.\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3341
        },
        {
          "method_name": "android.telephony.TelephonyManager.getUiccSlotsInfo",
          "documentation": "Gets all the UICC slots. The objects in the array can be null if the slot info\nis not available, which is possible between phone process starting and getting\nslot info from modem. @return UiccSlotInfo array. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3365
        },
        {
          "method_name": "android.telephony.TelephonyManager.getLogicalToPhysicalSlotMapping",
          "documentation": "Get the mapping from logical slots to physical slots. The key of the map is\nthe logical slot id and the value is the physical slots id mapped to this\nlogical slot id. @return a map indicates the mapping from logical slots to\nphysical slots. The size of the map should be {@link #getPhoneCount()} if\nsuccess, otherwise return an empty map. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3431
        },
        {
          "method_name": "android.telephony.TelephonyManager.getVoiceActivationState",
          "documentation": "Returns the voice activation state for the given subscriber.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} or that the calling app has carrier privileges\n(see {@link #hasCarrierPrivileges}). @param subId The subscription id. @return\nvoiceActivationState for the given subscriber @see\n#SIM_ACTIVATION_STATE_UNKNOWN @see #SIM_ACTIVATION_STATE_ACTIVATING @see\n#SIM_ACTIVATION_STATE_ACTIVATED @see #SIM_ACTIVATION_STATE_DEACTIVATED @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4423
        },
        {
          "method_name": "android.telephony.TelephonyManager.getDataActivationState",
          "documentation": "Returns the data activation state for the given subscriber.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} or that the calling app has carrier privileges\n(see {@link #hasCarrierPrivileges}). @param subId The subscription id. @return\ndataActivationState for the given subscriber @see\n#SIM_ACTIVATION_STATE_UNKNOWN @see #SIM_ACTIVATION_STATE_ACTIVATING @see\n#SIM_ACTIVATION_STATE_ACTIVATED @see #SIM_ACTIVATION_STATE_DEACTIVATED @see\n#SIM_ACTIVATION_STATE_RESTRICTED @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4473
        },
        {
          "method_name": "android.telephony.TelephonyManager.getIsimDomain",
          "documentation": "Returns the IMS home network domain name that was loaded from the ISIM {@see\n#APPTYPE_ISIM}. @return the IMS domain name. Returns {@code null} if ISIM\nhasn't been loaded or IMS domain hasn't been loaded or isn't present on the\nISIM.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 4613
        },
        {
          "method_name": "android.telephony.TelephonyManager.getIsimIst",
          "documentation": "Returns the IMS Service Table (IST) that was loaded from the ISIM. See 3GPP TS\n31.103 (Section 4.2.7) for the definition and more information on this table.\n@return IMS Service Table or null if not present or not loaded @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6332
        },
        {
          "method_name": "android.telephony.TelephonyManager.getPreferredNetworkType",
          "documentation": "Get the preferred network type. Used for device configuration by some CDMA\noperators.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} app has carrier privileges (see {@link\n#hasCarrierPrivileges}). @return the preferred network type, defined in\nRILConstants.java. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6929
        },
        {
          "method_name": "android.telephony.TelephonyManager.getPreferredNetworkTypeBitmask",
          "documentation": "Get the preferred network type bitmask.\n\nIf this object has been created with {@link #createForSubscriptionId}, applies\nto the given subId. Otherwise, applies to {@link\nSubscriptionManager#getDefaultSubscriptionId()}\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} or that the calling app has carrier privileges\n(see {@link #hasCarrierPrivileges}). @return The bitmask of preferred network\ntypes. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 6957
        },
        {
          "method_name": "android.telephony.TelephonyManager.isInEmergencySmsMode",
          "documentation": "Query Telephony to see if there has recently been an emergency SMS sent to the\nnetwork by the user and we are still within the time interval after the\nemergency SMS was sent that we are considered in Emergency SMS mode.\n\nThis mode is used by other applications to allow them to perform special\nfunctionality, such as allow the GNSS service to provide user location to the\ncarrier network for emergency when an emergency SMS is sent. This interval is\nset by {@link CarrierConfigManager#KEY_EMERGENCY_SMS_MODE_TIMER_MS_INT}. If\nthe carrier does not support this mode, this function will always return\nfalse. @return true if this device is in emergency SMS mode, false otherwise.\n@hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7196
        },
        {
          "method_name": "android.telephony.TelephonyManager.isOffhook",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isInCall} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7671
        },
        {
          "method_name": "android.telephony.TelephonyManager.isRinging",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isRinging} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7686
        },
        {
          "method_name": "android.telephony.TelephonyManager.isIdle",
          "documentation": "@deprecated Use {@link android.telecom.TelecomManager#isInCall} instead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7701
        },
        {
          "method_name": "android.telephony.TelephonyManager.isRadioOn",
          "documentation": "@deprecated Use {@link android.telephony.TelephonyManager#getServiceState}\ninstead @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 7716
        },
        {
          "method_name": "android.telephony.TelephonyManager.getRadioPowerState",
          "documentation": "@return current modem radio state.\n\nRequires permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or {@link\nandroid.Manifest.permission#READ_PHONE_STATE} or that the calling app has\ncarrier privileges (see {@link #hasCarrierPrivileges}). @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8000
        },
        {
          "method_name": "android.telephony.TelephonyManager.isVideoCallingEnabled",
          "documentation": "\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 8346
        },
        {
          "method_name": "android.telephony.TelephonyManager.getSimLocale",
          "documentation": "Returns a locale based on the country and language from the SIM. Returns\n{@code null} if no locale could be derived from subscriptions.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} @see Locale#toLanguageTag() @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9090
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCarrierIdFromMccMnc",
          "documentation": "Returns carrier id based on MCCMNC (returned by {@link #getSimOperator()})\nonly. This is used for fallback when configurations/logic for exact carrier id\n{@link #getSimCarrierId()} are not found. Android carrier id table\n[here](https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/carrier_list.textpb)\ncan be updated out-of-band, its possible a MVNO (Mobile Virtual Network\nOperator) carrier was not fully recognized and assigned to its MNO (Mobile\nNetwork Operator) carrier id by default. After carrier id table update, a new\ncarrier id was assigned. If apps don't take the update with the new id, it\nmight be helpful to always fallback by using carrier id based on MCCMNC if\nthere is no match. @return matching carrier id from passing MCCMNC. Return\n{@link #UNKNOWN_CARRIER_ID} if the subscription is unavailable or the carrier\ncannot be identified. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9429
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCertsFromCarrierPrivilegeAccessRules",
          "documentation": "Return a list of certs in hex string from loaded carrier privileges access\nrules. @return a list of certificate in hex string. return {@code null} if\nthere is no certs or privilege rules are not loaded yet.\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9452
        },
        {
          "method_name": "android.telephony.TelephonyManager.getAllowedCarriers",
          "documentation": "Get the allowed carrier list for slotIndex. Requires system privileges.\n\nThis method returns valid data on devices with {@link\nandroid.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n@deprecated Apps should use {@link getCarriersRestrictionRules} to retrieve\nthe list of allowed and excliuded carriers, as the result of this API is valid\nonly when the excluded list is empty. This API could return an empty list,\neven if some restrictions are present. @return List of {@link\nandroid.telephony.CarrierIdentifier}; empty list means all carriers are\nallowed. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9711
        },
        {
          "method_name": "android.telephony.TelephonyManager.getCarrierRestrictionRules",
          "documentation": "Get the allowed carrier list and the excluded carrier list indicating the\npriority between the two lists. Require system privileges. In the future we\nmay add this to carrier APIs.\n\nThis method returns valid data on devices with {@link\nandroid.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.\n@return {@link CarrierRestrictionRules} which contains the allowed carrier\nlist and the excluded carrier list with the priority between the two lists.\nReturns {@code null} in case of error. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 9737
        },
        {
          "method_name": "android.telephony.TelephonyManager.isOpportunisticNetworkEnabled",
          "documentation": "is OpportunisticNetworkService enabled This method should be called to\ndetermine if the OpportunisticNetworkService is enabled\n\nRequires Permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE\nREAD_PRIVILEGED_PHONE_STATE} @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10192
        },
        {
          "method_name": "android.telephony.TelephonyManager.getSupportedRadioAccessFamily",
          "documentation": "@return Modem supported radio access family bitmask\n\nRequires permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or that the calling\napp has carrier privileges (see {@link #hasCarrierPrivileges}). @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10368
        },
        {
          "method_name": "android.telephony.TelephonyManager.isPotentialEmergencyNumber",
          "documentation": "Checks if the supplied number is an emergency number based on current locale,\nsim, default, modem and network.\n\nSpecifically, this method will return {@code true} if the specified number is\nan emergency number,or* if the number simply starts with the same digits as\nany current emergency number.\n\nThe subscriptions which the identification would be based on, are all the\nactive subscriptions, no matter which subscription could be used to create\nTelephonyManager.\n\nRequires permission: {@link\nandroid.Manifest.permission#READ_PRIVILEGED_PHONE_STATE} or that the calling\napp has carrier privileges (see {@link #hasCarrierPrivileges}). @param number\n- the number to look up @return {@code true} if the given number is an\nemergency number or it simply starts with the same digits of any current\nemergency number based on current locale, sim, modem and network; {@code\nfalse} if it is not; or throw an SecurityException if the caller does not have\nthe required permission/privileges @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10547
        },
        {
          "method_name": "android.telephony.TelephonyManager.getPreferredOpportunisticDataSubscription",
          "documentation": "Get preferred opportunistic data subscription Id\n\nRequires that the calling app has carrier privileges (see {@link\n#hasCarrierPrivileges}), or has either READ_PRIVILEGED_PHONE_STATE or {@link\nandroid.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} permission.\n@return subId preferred opportunistic subscription id or {@link\nSubscriptionManager#DEFAULT_SUBSCRIPTION_ID} if there are no preferred\nsubscription id\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10685
        },
        {
          "method_name": "android.telephony.TelephonyManager.isRebootRequiredForModemConfigChange",
          "documentation": "Get whether reboot is required or not after making changes to modem\nconfigurations. The modem configuration change refers to switching from single\nSIM configuration to DSDS or the other way around. @Return {@code true} if\nreboot is required after making changes to modem configurations, otherwise\nreturn {@code false}. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 10935
        },
        {
          "method_name": "android.telephony.TelephonyManager.isDataAllowedInVoiceCall",
          "documentation": "Check whether data is allowed during voice call. Note this is for dual sim\ndevice that data might be disabled on non-default data subscription but\nexplicitly turned on by settings. @return {@code true} if data is allowed\nduring voice call. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 11059
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.registerImsRegistrationCallback",
          "documentation": "Registers a {@link RegistrationCallback} with the system, which will provide\nregistration updates for the subscription specified in {@link\n#createForSubscriptionId(int)}. Use {@link\nSubscriptionManager.OnSubscriptionsChangedListener} to listen to Subscription\nchanged events and call {@link\n#unregisterImsRegistrationCallback(RegistrationCallback)} to clean up. When\nthe callback is registered, it will initiate the callback c to be called with\nthe current registration state. @param executor The executor the callback\nevents should be run on. @param c The {@link RegistrationCallback} to be\nadded. @see #unregisterImsRegistrationCallback(RegistrationCallback) @throws\nIllegalArgumentException if the subscription associated with this callback is\nnot active (SIM is not inserted, ESIM inactive) or invalid, or a null {@link\nExecutor} or {@link CapabilityCallback} callback. @throws ImsException if the\nsubscription associated with this callback is valid, but the {@link\nImsService} associated with the subscription is not available. This can happen\nif the service crashed, for example. See {@link ImsException#getCode()} for a\nmore detailed reason.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 363
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.unregisterImsRegistrationCallback",
          "documentation": "Removes an existing {@link RegistrationCallback}. When the subscription\nassociated with this callback is removed (SIM removed, ESIM swap, etc...),\nthis callback will automatically be removed. If this method is called for an\ninactive subscription, it will result in a no-op. @param c The {@link\nRegistrationCallback} to be removed. @see\nSubscriptionManager.OnSubscriptionsChangedListener @see\n#registerImsRegistrationCallback(Executor, RegistrationCallback) @throws\nIllegalArgumentException if the subscription ID associated with this callback\nis invalid.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 397
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.registerMmTelCapabilityCallback",
          "documentation": "Registers a {@link CapabilityCallback} with the system, which will provide\nMmTel service availability updates for the subscription specified in {@link\n#createForSubscriptionId(int)}. The method {@link #isAvailable(int, int)} can\nalso be used to query this information at any time. Use {@link\nSubscriptionManager.OnSubscriptionsChangedListener} to listen to subscription\nchanged events and call {@link\n#unregisterImsRegistrationCallback(RegistrationCallback)} to clean up. When\nthe callback is registered, it will initiate the callback c to be called with\nthe current capabilities. @param executor The executor the callback events\nshould be run on. @param c The MmTel {@link CapabilityCallback} to be\nregistered. @see #unregisterMmTelCapabilityCallback(CapabilityCallback)\n@throws IllegalArgumentException if the subscription associated with this\ncallback is not active (SIM is not inserted, ESIM inactive) or invalid, or a\nnull {@link Executor} or {@link CapabilityCallback} callback. @throws\nImsException if the subscription associated with this callback is valid, but\nthe {@link ImsService} associated with the subscription is not available. This\ncan happen if the service crashed, for example. See {@link\nImsException#getCode()} for a more detailed reason.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 433
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.unregisterMmTelCapabilityCallback",
          "documentation": "Removes an existing MmTel {@link CapabilityCallback}. When the subscription\nassociated with this callback is removed (SIM removed, ESIM swap, etc...),\nthis callback will automatically be removed. If this method is called for an\ninactive subscription, it will result in a no-op. @param c The MmTel {@link\nCapabilityCallback} to be removed. @see\n#registerMmTelCapabilityCallback(Executor, CapabilityCallback) @throws\nIllegalArgumentException if the subscription ID associated with this callback\nis invalid.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 467
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isAdvancedCallingSettingEnabled",
          "documentation": "Query the user\u2019s setting for \u201cAdvanced Calling\u201d or \"Enhanced 4G LTE\", which is\nused to enable MmTel IMS features, depending on the carrier configuration for\nthe current subscription. If this setting is enabled, IMS voice and video\ntelephony over IWLAN/LTE will be enabled as long as the carrier has\nprovisioned these services for the specified subscription. Other IMS services\n(SMS/UT) are not affected by this user setting and depend on carrier\nrequirements. Modifying this value may also trigger an IMS registration or\nderegistration, depending on whether or not the new value is enabled or\ndisabled. Note: If the carrier configuration for advanced calling is not\neditable or hidden, this method will do nothing and will instead always use\nthe default value. @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL\n@see android.telephony.CarrierConfigManager#KEY_EDITABLE_ENHANCED_4G_LTE_BOOL\n@see android.telephony.CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL @see\nandroid.telephony.CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL\n@see android.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_AVAILABLE_BOOL\n@see #setAdvancedCallingSettingEnabled(boolean) @return true if the user's\nsetting for advanced calling is enabled, false otherwise.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 501
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isCapable",
          "documentation": "Query the IMS MmTel capability for a given registration technology. This does\nnot necessarily mean that we are registered and the capability is available,\nbut rather the subscription is capable of this service over IMS. @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_AVAILABLE_BOOL @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_VT_AVAILABLE_BOOL @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_IMS_GBA_REQUIRED_BOOL @see\n#isAvailable(int, int) @param imsRegTech The IMS registration technology, can\nbe one of the following: {@link\nImsRegistrationImplBase#REGISTRATION_TECH_LTE}, {@link\nImsRegistrationImplBase#REGISTRATION_TECH_IWLAN} @param capability The IMS\nMmTel capability to query, can be one of the following: {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_VOICE}, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_VIDEO, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_UT}, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_SMS} @return {@code true} if\nthe MmTel IMS capability is capable for this subscription, false otherwise.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 562
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isAvailable",
          "documentation": "Query the availability of an IMS MmTel capability for a given registration\ntechnology. If a capability is available, IMS is registered and the service is\ncurrently available over IMS. @see #isCapable(int, int) @param imsRegTech The\nIMS registration technology, can be one of the following: {@link\nImsRegistrationImplBase#REGISTRATION_TECH_LTE}, {@link\nImsRegistrationImplBase#REGISTRATION_TECH_IWLAN} @param capability The IMS\nMmTel capability to query, can be one of the following: {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_VOICE}, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_VIDEO, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_UT}, {@link\nMmTelFeature.MmTelCapabilities#CAPABILITY_TYPE_SMS} @return {@code true} if\nthe MmTel IMS capability is available for this subscription, false otherwise.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 589
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isVtSettingEnabled",
          "documentation": "The user's setting for whether or not they have enabled the \"Video Calling\"\nsetting. @return true if the user\u2019s \u201cVideo Calling\u201d setting is currently\nenabled. @see #setVtSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 604
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isVoWiFiSettingEnabled",
          "documentation": "@return true if the user's setting for Voice over WiFi is enabled and false if\nit is not. @see #setVoWiFiSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 631
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isVoWiFiRoamingSettingEnabled",
          "documentation": "@return true if the user's setting for Voice over WiFi while roaming is\nenabled, false if disabled. @see #setVoWiFiRoamingSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 660
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.getVoWiFiModeSetting",
          "documentation": "@return The Voice over WiFi Mode preference set by the user, which can be one\nof the following: - {@link #WIFI_MODE_WIFI_ONLY} - {@link\n#WIFI_MODE_CELLULAR_PREFERRED} - {@link #WIFI_MODE_WIFI_PREFERRED} @see\n#setVoWiFiSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 715
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.getVoWiFiRoamingModeSetting",
          "documentation": "Set the user's preference for Voice over WiFi calling mode while the device is\nroaming on another network. @return The user's preference for the technology\nto register for IMS over when roaming on another network, can be one of the\nfollowing: - {@link #WIFI_MODE_WIFI_ONLY} - {@link\n#WIFI_MODE_CELLULAR_PREFERRED} - {@link #WIFI_MODE_WIFI_PREFERRED} @see\n#setVoWiFiRoamingSettingEnabled(boolean)\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 754
        },
        {
          "method_name": "android.telephony.ims.ImsMmTelManager.isTtyOverVolteEnabled",
          "documentation": "@return true if TTY over VoLTE is supported @see\nandroid.telecom.TelecomManager#getCurrentTtyMode @see\nandroid.telephony.CarrierConfigManager#KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ImsMmTelManager.java",
          "line": 808
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.registerProvisioningChangedCallback",
          "documentation": "Register a new {@link Callback} to listen to changes to changes in IMS\nprovisioning. When the subscription associated with this callback is removed\n(SIM removed, ESIM swap, etc...), this callback will automatically be removed.\n@param executor The {@link Executor} to call the callback methods on @param\ncallback The provisioning callbackto be registered. @see\n#unregisterProvisioningChangedCallback(Callback) @see\nSubscriptionManager.OnSubscriptionsChangedListener @throws\nIllegalArgumentException if the subscription associated with this callback is\nnot active (SIM is not inserted, ESIM inactive) or the subscription is\ninvalid. @throws ImsException if the subscription associated with this\ncallback is valid, but the {@link ImsService} associated with the subscription\nis not available. This can happen if the service crashed, for example. See\n{@link ImsException#getCode()} for a more detailed reason.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 224
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.unregisterProvisioningChangedCallback",
          "documentation": "Unregister an existing {@link Callback}. When the subscription associated with\nthis callback is removed (SIM removed, ESIM swap, etc...), this callback will\nautomatically be removed. If this method is called for an inactive\nsubscription, it will result in a no-op. @param callback The existing {@link\nCallback} to be removed. @see #registerProvisioningChangedCallback(Executor,\nCallback) @throws IllegalArgumentException if the subscription associated with\nthis callback is invalid.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 249
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.getProvisioningIntValue",
          "documentation": "Query for the integer value associated with the provided key. This operation\nis blocking and should not be performed on the UI thread. @param key An\ninteger that represents the provisioning key, which is defined by the OEM.\n@return an integer value for the provided key, or {@link\nImsConfigImplBase#CONFIG_RESULT_UNKNOWN} if the key doesn't exist. @throws\nIllegalArgumentException if the key provided was invalid.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 269
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.getProvisioningStringValue",
          "documentation": "Query for the String value associated with the provided key. This operation is\nblocking and should not be performed on the UI thread. @param key A String\nthat represents the provisioning key, which is defined by the OEM. @return a\nString value for the provided key, {@code null} if the key doesn't exist, or\n{@link StringResultError} if there was an error getting the value for the\nprovided key. @throws IllegalArgumentException if the key provided was\ninvalid.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 289
        },
        {
          "method_name": "android.telephony.ims.ProvisioningManager.getProvisioningStatusForCapability",
          "documentation": "Get the provisioning status for the IMS MmTel capability specified. If\nprovisioning is not required for the queried {@link\nMmTelFeature.MmTelCapabilities.MmTelCapability} and {@link\nImsRegistrationImplBase.ImsRegistrationTech} combination specified, this\nmethod will always return {@code true}. @see\nCarrierConfigManager#KEY_CARRIER_UT_PROVISIONING_REQUIRED_BOOL @see\nCarrierConfigManager#KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL @return true\nif the device is provisioned for the capability or does not require\nprovisioning, false if the capability does require provisioning and has not\nbeen provisioned yet.\n\n",
          "file": "./aosp/telephony/java/android/telephony/ims/ProvisioningManager.java",
          "line": 380
        }
      ]
    },
    "android.permission.REGISTER_SIM_SUBSCRIPTION": {
      "name": "android.permission.REGISTER_SIM_SUBSCRIPTION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.REGISTER_CALL_PROVIDER": {
      "name": "android.permission.REGISTER_CALL_PROVIDER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.REGISTER_CONNECTION_MANAGER": {
      "name": "android.permission.REGISTER_CONNECTION_MANAGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_INCALL_SERVICE": {
      "name": "android.permission.BIND_INCALL_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.NETWORK_SCAN": {
      "name": "android.permission.NETWORK_SCAN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_VISUAL_VOICEMAIL_SERVICE": {
      "name": "android.permission.BIND_VISUAL_VOICEMAIL_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_SCREENING_SERVICE": {
      "name": "android.permission.BIND_SCREENING_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_PHONE_ACCOUNT_SUGGESTION_SERVICE": {
      "name": "android.permission.BIND_PHONE_ACCOUNT_SUGGESTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_CALL_REDIRECTION_SERVICE": {
      "name": "android.permission.BIND_CALL_REDIRECTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_CONNECTION_SERVICE": {
      "name": "android.permission.BIND_CONNECTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_TELECOM_CONNECTION_SERVICE": {
      "name": "android.permission.BIND_TELECOM_CONNECTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CONTROL_INCALL_EXPERIENCE": {
      "name": "android.permission.CONTROL_INCALL_EXPERIENCE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.RECEIVE_STK_COMMANDS": {
      "name": "android.permission.RECEIVE_STK_COMMANDS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SEND_EMBMS_INTENTS": {
      "name": "android.permission.SEND_EMBMS_INTENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_SENSORS": {
      "name": "android.permission.MANAGE_SENSORS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_IMS_SERVICE": {
      "name": "android.permission.BIND_IMS_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|vendorPrivileged"
    },
    "android.permission.BIND_TELEPHONY_DATA_SERVICE": {
      "name": "android.permission.BIND_TELEPHONY_DATA_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_TELEPHONY_NETWORK_SERVICE": {
      "name": "android.permission.BIND_TELEPHONY_NETWORK_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.WRITE_EMBEDDED_SUBSCRIPTIONS": {
      "name": "android.permission.WRITE_EMBEDDED_SUBSCRIPTIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.telephony.SubscriptionManager.switchToSubscription",
          "documentation": "Switch to a certain subscription @param subId sub id @param callbackIntent\npending intent that will be sent after operation is done.\n\n",
          "file": "./aosp/telephony/java/android/telephony/SubscriptionManager.java",
          "line": 2735
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.getOtaStatus",
          "documentation": "Returns the current status of eUICC OTA.\n\nRequires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS}\npermission. @return the status of eUICC OTA. If the eUICC is not ready, {@link\nOtaStatus#EUICC_OTA_STATUS_UNAVAILABLE} will be returned. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 469
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.downloadSubscription",
          "documentation": "Attempt to download the given {@link DownloadableSubscription}.\n\nRequires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS}\npermission, or the calling app must be authorized to manage both the\ncurrently-active subscription on the current eUICC and the subscription to be\ndownloaded according to the subscription metadata. Without the former, an\n{@link #EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the\ncallback intent to prompt the user to accept the download.\n\nOn a multi-active SIM device, requires the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or a\ncalling app only if the targeted eUICC does not currently have an active\nsubscription or the calling app is authorized to manage the active\nsubscription on the target eUICC, and the calling app is authorized to manage\nany active subscription on any SIM. Without it, an {@link\n#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the\ncallback intent to prompt the user to accept the download. The caller should\nalso be authorized to manage the subscription to be downloaded. @param\nsubscription the subscription to download. @param switchAfterDownload if true,\nthe profile will be activated upon successful download. @param callbackIntent\na PendingIntent to launch when the operation completes.\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 503
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.continueOperation",
          "documentation": "Continue an operation after the user resolves an error.\n\nTo be called by the LUI upon completion of a resolvable error flow.\n\nRequires that the calling app has the {@link\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. @param\nresolutionIntent The original intent used to start the LUI. @param\nresolutionExtras Resolution-specific extras depending on the result of the\nresolution. For example, this may indicate whether the user has consented or\nmay include the input they provided. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 566
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.getDownloadableSubscriptionMetadata",
          "documentation": "Fills in the metadata for a DownloadableSubscription.\n\nMay be used in cases that a DownloadableSubscription was constructed to\ndownload a profile, but the metadata for the profile is unknown (e.g. we only\nknow the activation code). The callback will be triggered with an Intent with\n{@link #EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION} set to the\ndownloadable subscription metadata upon success.\n\nRequires that the calling app has the {@link\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is\nfor internal system use only. @param subscription the subscription which needs\nmetadata filled in @param callbackIntent a PendingIntent to launch when the\noperation completes. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 602
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.getDefaultDownloadableSubscriptionList",
          "documentation": "Gets metadata for subscription which are available for download on this\ndevice.\n\nSubscriptions returned here may be passed to {@link #downloadSubscription}.\nThey may have been pre-assigned to this particular device, for example. The\ncallback will be triggered with an Intent with {@link\n#EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS} set to the list of\navailable subscriptions upon success.\n\nRequires that the calling app has the {@link\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is\nfor internal system use only. @param callbackIntent a PendingIntent to launch\nwhen the operation completes. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 633
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.deleteSubscription",
          "documentation": "Deletes the given subscription.\n\nIf this subscription is currently active, the device will first switch away\nfrom it onto an \"empty\" subscription.\n\nRequires that the calling app has carrier privileges according to the metadata\nof the profile to be deleted, or the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. @param\nsubscriptionId the ID of the subscription to delete. @param callbackIntent a\nPendingIntent to launch when the operation completes.\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 677
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.switchToSubscription",
          "documentation": "Switch to (enable) the given subscription.\n\nRequires the {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS}\npermission, or the calling app must be authorized to manage both the\ncurrently-active subscription and the subscription to be enabled according to\nthe subscription metadata. Without the former, an {@link\n#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the\ncallback intent to prompt the user to accept the download.\n\nOn a multi-active SIM device, requires the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or a\ncalling app only if the targeted eUICC does not currently have an active\nsubscription or the calling app is authorized to manage the active\nsubscription on the target eUICC, and the calling app is authorized to manage\nany active subscription on any SIM. Without it, an {@link\n#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR} will be returned in the\ncallback intent to prompt the user to accept the download. The caller should\nalso be authorized to manage the subscription to be enabled. @param\nsubscriptionId the ID of the subscription to enable. May be {@link\nandroid.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID} to deactivate\nthe current profile without activating another profile to replace it. If it's\na disable operation, requires the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission, or the\ncalling app must be authorized to manage the active subscription on the target\neUICC. @param callbackIntent a PendingIntent to launch when the operation\ncompletes.\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 717
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.updateSubscriptionNickname",
          "documentation": "Update the nickname for the given subscription.\n\nRequires that the calling app has carrier privileges according to the metadata\nof the profile to be updated, or the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. @param\nsubscriptionId the ID of the subscription to update. @param nickname the new\nnickname to apply. @param callbackIntent a PendingIntent to launch when the\noperation completes.\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 742
        },
        {
          "method_name": "android.telephony.euicc.EuiccManager.eraseSubscriptions",
          "documentation": "Erase all subscriptions and reset the eUICC.\n\nRequires that the calling app has the {@code\nandroid.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. @param\ncallbackIntent a PendingIntent to launch when the operation completes. @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/euicc/EuiccManager.java",
          "line": 767
        }
      ]
    },
    "android.permission.BIND_EUICC_SERVICE": {
      "name": "android.permission.BIND_EUICC_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.WRITE_MEDIA_STORAGE": {
      "name": "android.permission.WRITE_MEDIA_STORAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_DOCUMENTS": {
      "name": "android.permission.MANAGE_DOCUMENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CACHE_CONTENT": {
      "name": "android.permission.CACHE_CONTENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ALLOCATE_AGGRESSIVE": {
      "name": "android.permission.ALLOCATE_AGGRESSIVE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.USE_RESERVED_DISK": {
      "name": "android.permission.USE_RESERVED_DISK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.DISABLE_KEYGUARD": {
      "name": "android.permission.DISABLE_KEYGUARD",
      "label": "D\u00e9sactiver le verrouillage de l'\u00e9cran",
      "label_ptr": "permlab_disableKeyguard",
      "description": "Permet \u00e0 l'application de d\u00e9sactiver le verrouillage des touches et toute mesure de s\u00e9curit\u00e9 via mot de passe associ\u00e9e. Par exemple, votre t\u00e9l\u00e9phone d\u00e9sactive le verrouillage des touches lorsque vous recevez un appel, puis le r\u00e9active lorsque vous raccrochez.",
      "description_ptr": "permdesc_disableKeyguard",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.app.KeyguardManager.exitKeyguardSecurely",
          "documentation": "@deprecated Use {@link LayoutParams#FLAG_DISMISS_KEYGUARD} and/or {@link\nLayoutParams#FLAG_SHOW_WHEN_LOCKED} instead; this allows you to seamlessly\nhide the keyguard as your application moves in and out of the foreground and\ndoes not require that any special permissions be requested. Exit the keyguard\nsecurely. The use case for this api is that, after disabling the keyguard,\nyour app, which was granted permission to disable the keyguard and show a\nlimited amount of information deemed safe without the user getting past the\nkeyguard, needs to navigate to something that is not safe to view without\ngetting past the keyguard. This will, if the keyguard is secure, bring up the\nunlock screen of the keyguard. @param callback Lets you know whether the\noperation was successful and it is safe to launch anything that would normally\nbe considered safe once the user has gotten past the keyguard.\n\n",
          "file": "./aosp/core/java/android/app/KeyguardManager.java",
          "line": 569
        }
      ]
    },
    "android.permission.GET_TASKS": {
      "name": "android.permission.GET_TASKS",
      "label": "r\u00e9cup\u00e9rer les applications en cours d'ex\u00e9cution",
      "label_ptr": "permlab_getTasks",
      "description": "Permet \u00e0 l'application de r\u00e9cup\u00e9rer des informations sur des t\u00e2ches en cours d'ex\u00e9cution et r\u00e9cemment ex\u00e9cut\u00e9es. L'application est ainsi susceptible d'obtenir des informations sur les applications utilis\u00e9es sur l'appareil.",
      "description_ptr": "permdesc_getTasks",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.REAL_GET_TASKS": {
      "name": "android.permission.REAL_GET_TASKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.START_TASKS_FROM_RECENTS": {
      "name": "android.permission.START_TASKS_FROM_RECENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.INTERACT_ACROSS_USERS": {
      "name": "android.permission.INTERACT_ACROSS_USERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.content.Context.sendBroadcastAsUser",
          "documentation": "Version of {@link #sendBroadcast(Intent, String)} that allows you to specify\nthe user the broadcast will be sent to. This is not available to applications\nthat are not pre-installed on the system image. @param intent The Intent to\nbroadcast; all receivers matching this Intent will receive the broadcast.\n@param user UserHandle to send the intent to. @param receiverPermission\n(optional) String naming a permission that a receiver must hold in order to\nreceive your broadcast. If null, no permission is required. @param appOp The\napp op associated with the broadcast. @see #sendBroadcast(Intent, String)\n@hide\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2264
        },
        {
          "method_name": "android.content.Context.sendOrderedBroadcastAsUser",
          "documentation": "Similar to above but takes an appOp as well, to enforce restrictions, and an\noptions Bundle. @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,\nBroadcastReceiver, Handler, int, String, Bundle) @hide\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2323
        },
        {
          "method_name": "android.content.Context.sendStickyBroadcastAsUser",
          "documentation": "@hide This is just here for sending CONNECTIVITY_ACTION.\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2459
        },
        {
          "method_name": "android.content.Context.sendStickyOrderedBroadcastAsUser",
          "documentation": "Version of {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver,\nHandler, int, String, Bundle)} that allows you to specify the user the\nbroadcast will be sent to. This is not available to applications that are not\npre-installed on the system image.\n\nSee {@link BroadcastReceiver} for more information on Intent broadcasts.\n@deprecated Sticky broadcasts should not be used. They provide no security\n(anyone can access them), no protection (anyone can modify them), and many\nother problems. The recommended pattern is to use a non-sticky broadcast to\nreport that _something_ has changed, with another mechanism for apps to\nretrieve the current value whenever desired. @param intent The Intent to\nbroadcast; all receivers matching this Intent will receive the broadcast.\n@param user UserHandle to send the intent to. @param resultReceiver Your own\nBroadcastReceiver to treat as the final receiver of the broadcast. @param\nscheduler A custom Handler with which to schedule the resultReceiver callback;\nif null it will be scheduled in the Context's main thread. @param initialCode\nAn initial value for the result code. Often Activity.RESULT_OK. @param\ninitialData An initial value for the result data. Often null. @param\ninitialExtras An initial value for the result extras. Often null. @see\n#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String,\nBundle)\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2499
        },
        {
          "method_name": "android.content.Context.removeStickyBroadcastAsUser",
          "documentation": "Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify\nthe user the broadcast will be sent to. This is not available to applications\nthat are not pre-installed on the system image.\n\nYou must hold the {@link android.Manifest.permission#BROADCAST_STICKY}\npermission in order to use this API. If you do not hold that permission,\n{@link SecurityException} will be thrown. @deprecated Sticky broadcasts should\nnot be used. They provide no security (anyone can access them), no protection\n(anyone can modify them), and many other problems. The recommended pattern is\nto use a non-sticky broadcast to report that _something_ has changed, with\nanother mechanism for apps to retrieve the current value whenever desired.\n@param intent The Intent that was previously broadcast. @param user UserHandle\nto remove the sticky broadcast from. @see #sendStickyBroadcastAsUser\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2529
        },
        {
          "method_name": "android.content.Context.startForegroundServiceAsUser",
          "documentation": "@hide like {@link #startForegroundService(Intent)} but for a specific user.\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2825
        },
        {
          "method_name": "android.content.Context.startServiceAsUser",
          "documentation": "@hide like {@link #startService(Intent)} but for a specific user.\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2864
        },
        {
          "method_name": "android.content.Context.stopServiceAsUser",
          "documentation": "@hide like {@link #stopService(Intent)} but for a specific user.\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2870
        },
        {
          "method_name": "android.content.Context.bindServiceAsUser",
          "documentation": "Same as {@link #bindService(Intent, ServiceConnection, int, UserHandle)}, but\nwith an explicit non-null Handler to run the ServiceConnection callbacks on.\n@hide\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2952
        },
        {
          "method_name": "android.content.pm.PackageManager.getPackageInfoAsUser",
          "documentation": "Retrieve overall information about an application package that is installed on\nthe system. @param packageName The full name (i.e. com.google.apps.contacts)\nof the desired package. @param flags Additional option flags to modify the\ndata returned. @param userId The user id. @return A PackageInfo object\ncontaining information about the package. If flag {@code\nMATCH_UNINSTALLED_PACKAGES} is set and if the package is not found in the list\nof installed applications, the package information is retrieved from the list\nof uninstalled applications (which includes installed applications as well as\napplications with data directory i.e. applications which had been deleted with\n{@code DONT_DELETE_DATA} flag set). @throws NameNotFoundException if a package\nwith the given name cannot be found on the system. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3141
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.hasEnrolledFingerprints",
          "documentation": "@hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 770
        }
      ]
    },
    "android.permission.INTERACT_ACROSS_USERS_FULL": {
      "name": "android.permission.INTERACT_ACROSS_USERS_FULL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer",
      "methods": [
        {
          "method_name": "android.accounts.AccountManager.finishSessionAsUser",
          "documentation": "@see #finishSession @hide\n\n",
          "file": "./aosp/core/java/android/accounts/AccountManager.java",
          "line": 3234
        },
        {
          "method_name": "android.app.WallpaperManager.clearWallpaper",
          "documentation": "Clear the wallpaper for a specific user. The caller must hold the\nINTERACT_ACROSS_USERS_FULL permission to clear another user's wallpaper, and\nmust hold the SET_WALLPAPER permission in all circumstances. @hide\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1637
        },
        {
          "method_name": "android.content.Context.startActivityAsUser",
          "documentation": "Version of {@link #startActivity(Intent, Bundle)} that allows you to specify\nthe user the activity will be started for. This is not available to\napplications that are not pre-installed on the system image. @param intent The\ndescription of the activity to start. @param options Additional options for\nhow the Activity should be started. May be null if there are no options. See\n{@link android.app.ActivityOptions} for how to build the Bundle supplied here;\nthere are no supported definitions for building it manually. @param userId The\nUserHandle of the user to start this activity for. @throws\nActivityNotFoundException   @hide\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 1762
        },
        {
          "method_name": "android.content.Context.startActivitiesAsUser",
          "documentation": "@hide Launch multiple new activities. This is generally the same as calling\n{@link #startActivity(Intent)} for the first Intent in the array, that\nactivity during its creation calling {@link #startActivity(Intent)} for the\nsecond entry, etc. Note that unlike that approach, generally none of the\nactivities except the last in the array will be created at this point, but\nrather will be created when the user first visits them (due to pressing back\nfrom the activity on top).\n\nThis method throws {@link ActivityNotFoundException} if there was no Activity\nfound for _any_ given Intent. In this case the state of the activity stack is\nundefined (some Intents in the list may be on it, some not), so you probably\nwant to avoid such situations. @param intents An array of Intents to be\nstarted. @param options Additional options for how the Activity should be\nstarted. @param userHandle The user for whom to launch the activities See\n{@link android.content.Context#startActivity(Intent, Bundle)}\nContext.startActivity(Intent, Bundle)} for more details. @return The\ncorresponding flag {@link ActivityManager#START_CANCELED}, {@link\nActivityManager#START_SUCCESS} etc. indicating whether the launch was\nsuccessful. @throws ActivityNotFoundException    @see\n#startActivities(Intent[]) @see PackageManager#resolveActivity\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 1867
        },
        {
          "method_name": "android.content.Context.registerReceiverAsUser",
          "documentation": "@hide Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter,\nString, Handler) but for a specific user. This receiver will receiver\nbroadcasts that are sent to the requested user. @param receiver The\nBroadcastReceiver to handle the broadcast. @param user UserHandle to send the\nintent to. @param filter Selects the Intent broadcasts to be received. @param\nbroadcastPermission String naming a permissions that a broadcaster must hold\nin order to send an Intent to you. If null, no permission is required. @param\nscheduler Handler identifying the thread that will receive the Intent. If\nnull, the main thread of the process will be used. @return The first sticky\nintent found that matches filter, or null if there are none. @see\n#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) @see\n#sendBroadcast @see #unregisterReceiver\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2716
        },
        {
          "method_name": "android.content.pm.PackageManager.getInstalledPackagesAsUser",
          "documentation": "Return a List of all packages that are installed on the device, for a specific\nuser. @param flags Additional option flags to modify the data returned. @param\nuserId The user for whom the installed packages are to be listed @return A\nList of PackageInfo objects, one for each installed package, containing\ninformation about the package. In the unlikely case there are no installed\npackages, an empty list is returned. If flag {@code\nMATCH_UNINSTALLED_PACKAGES} is set, the package information is retrieved from\nthe list of uninstalled applications (which includes installed applications as\nwell as applications with data directory i.e. applications which had been\ndeleted with {@code DONT_DELETE_DATA} flag set). @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3495
        },
        {
          "method_name": "android.content.pm.PackageManager.installExistingPackageAsUser",
          "documentation": "If there is already an application with the given package name installed on\nthe system for other users, also install it for the specified user. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 4942
        },
        {
          "method_name": "android.content.pm.PackageManager.getIntentVerificationStatusAsUser",
          "documentation": "Get the status of a Domain Verification Result for an IntentFilter. This is\nrelated to the {@link android.content.IntentFilter#setAutoVerify(boolean)} and\n{@link android.content.IntentFilter#getAutoVerify()} This is used by the\nResolverActivity to change the status depending on what the User select in the\nDisambiguation Dialog and also used by the Settings App for changing the\ndefault App for a domain. @param packageName The package name of the Activity\nassociated with the IntentFilter. @param userId The user id. @return The\nstatus to set to. This can be {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ASK} or {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS} or {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER} or {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED} @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5043
        },
        {
          "method_name": "android.content.pm.PackageManager.getDefaultBrowserPackageNameAsUser",
          "documentation": "Get the default Browser package name for a specific user. @param userId The\nuser id. @return the package name of the default Browser for the specified\nuser. If the user id passed is -1 (all users) it will return a null value.\n@hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5113
        },
        {
          "method_name": "android.content.pm.PackageManager.setDefaultBrowserPackageNameAsUser",
          "documentation": "Set the default Browser package name for a specific user. @param packageName\nThe package name of the default Browser. @param userId The user id. @return\ntrue if the default Browser for the specified user has been set, otherwise\nreturn false. If the user id passed is -1 (all users) this call will not do\nanything and just return false. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5131
        },
        {
          "method_name": "android.content.pm.PackageManager.deletePackageAsUser",
          "documentation": "Attempts to delete a package. Since this may take a little while, the result\nwill be posted back to the given observer. A deletion will fail if the named\npackage cannot be found, or if the named package is a system package. @param\npackageName The name of the package to delete @param observer An observer\ncallback to get notified when the package deletion is complete. {@link\nandroid.content.pm.IPackageDeleteObserver#packageDeleted} will be called when\nthat happens. observer may be null to indicate that no callback is desired.\n@param userId The user Id @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5197
        },
        {
          "method_name": "android.os.UserManager.setUserAdmin",
          "documentation": "Assigns admin privileges to the user, if such a user exists.\n\nRequires {@link android.Manifest.permission#MANAGE_USERS} and {@link\nandroid.Manifest.permission#INTERACT_ACROSS_USERS_FULL} permissions. @param\nuserHandle the id of the user to become admin @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2131
        },
        {
          "method_name": "android.os.UserManager.getUserAccount",
          "documentation": "@return the user's account name, null if not found. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2207
        },
        {
          "method_name": "android.os.UserManager.setUserAccount",
          "documentation": "Set account name for the given user. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2223
        }
      ]
    },
    "android.permission.MANAGE_USERS": {
      "name": "android.permission.MANAGE_USERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.admin.DevicePolicyManager.getDeviceOwnerComponentOnAnyUser",
          "documentation": "@return device owner component name, even if it's running on a different user.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 5190
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getDeviceOwner",
          "documentation": "Returns the device owner package name, only if it's running on the calling\nuser.\n\nBundled components should use {@code getDeviceOwnerComponentOnCallingUser()}\nfor clarity. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 5274
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getDeviceOwnerNameOnAnyUser",
          "documentation": "Returns the device owner name. Note this methodwill* return the device owner\nname when it's running on a different user. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 5308
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getProfileOwnerNameAsUser",
          "documentation": "@hide @param userId The user for whom to fetch the profile owner name, if any.\n@return the human readable name of the organisation associated with this\nprofile owner or null if one is not set. @throws IllegalArgumentException if\nthe userId is invalid.\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 5707
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getPermittedAccessibilityServices",
          "documentation": "Returns the list of accessibility services permitted by the device or profiles\nowners of this user.\n\nNull means all accessibility services are allowed, if a non-null list is\nreturned it will contain the intersection of the permitted lists for any\ndevice or profile owners that apply to this user. It will also include any\nsystem accessibility services. @param userId which user to check for. @return\nList of accessiblity service package names. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 6377
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getPermittedInputMethodsForCurrentUser",
          "documentation": "Returns the list of input methods permitted by the device or profiles owners\nof the current user. (*Not* calling user, due to a limitation in\nInputMethodManager.)\n\nNull means all input methods are allowed, if a non-null list is returned it\nwill contain the intersection of the permitted lists for any device or profile\nowners that apply to this user. It will also include any system input methods.\n@return List of input method package names. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 6480
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.getUserProvisioningState",
          "documentation": "@return the {@link UserProvisioningState} for the current user - for unmanaged\nusers will return {@link #STATE_USER_UNMANAGED} @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 8746
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.isDeviceProvisioned",
          "documentation": "Returns whether the device has been provisioned.\n\nNot for use by third-party applications. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 8890
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.setDeviceProvisioningConfigApplied",
          "documentation": "Writes that the provisioning configuration has been applied.\n\nThe caller must hold the {@link android.Manifest.permission#MANAGE_USERS}\npermission.\n\nNot for use by third-party applications. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 8910
        },
        {
          "method_name": "android.app.admin.DevicePolicyManager.isDeviceProvisioningConfigApplied",
          "documentation": "Returns whether the provisioning configuration has been applied.\n\nThe caller must hold the {@link android.Manifest.permission#MANAGE_USERS}\npermission.\n\nNot for use by third-party applications. @return whether the provisioning\nconfiguration has been applied. @hide\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 8931
        },
        {
          "method_name": "android.os.UserManager.isManagedProfile",
          "documentation": "Checks if the specified user is a managed profile. Requires {@link\nandroid.Manifest.permission#MANAGE_USERS} permission, otherwise the caller\nmust be in the same profile group of specified user. @return whether the\nspecified user is a managed profile. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 1402
        },
        {
          "method_name": "android.os.UserManager.getUserRestrictionSource",
          "documentation": "@hide Returns who set a user restriction on a user. @param restrictionKey the\nstring key representing the restriction @param userHandle the UserHandle of\nthe user for whom to retrieve the restrictions. @return The source of user\nrestriction. Any combination of {@link #RESTRICTION_NOT_SET}, {@link\n#RESTRICTION_SOURCE_SYSTEM}, {@link #RESTRICTION_SOURCE_DEVICE_OWNER} and\n{@link #RESTRICTION_SOURCE_PROFILE_OWNER} @deprecated use {@link\n#getUserRestrictionSources(String, int)} instead.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 1630
        },
        {
          "method_name": "android.os.UserManager.getUserRestrictionSources",
          "documentation": "@hide Returns a list of users who set a user restriction on a given user.\n@param restrictionKey the string key representing the restriction @param\nuserHandle the UserHandle of the user for whom to retrieve the restrictions.\n@return a list of user ids enforcing this restriction.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 1648
        },
        {
          "method_name": "android.os.UserManager.getSeedAccountName",
          "documentation": "@hide Returns the preferred account name for user creation.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2009
        },
        {
          "method_name": "android.os.UserManager.getSeedAccountType",
          "documentation": "@hide Returns the preferred account type for user creation.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2024
        },
        {
          "method_name": "android.os.UserManager.getSeedAccountOptions",
          "documentation": "@hide Returns the preferred account's options bundle for user creation.\n@return Any options set by the requestor that created the user.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2040
        },
        {
          "method_name": "android.os.UserManager.clearSeedAccountData",
          "documentation": "@hide Clears the seed information used to create this user.\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2075
        },
        {
          "method_name": "android.os.UserManager.setUserAdmin",
          "documentation": "Assigns admin privileges to the user, if such a user exists.\n\nRequires {@link android.Manifest.permission#MANAGE_USERS} and {@link\nandroid.Manifest.permission#INTERACT_ACROSS_USERS_FULL} permissions. @param\nuserHandle the id of the user to become admin @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2131
        },
        {
          "method_name": "android.os.UserManager.getSerialNumbersOfUsers",
          "documentation": "Returns serial numbers of all users on this device. @param excludeDying\nspecify if the list should exclude users being removed. @return the list of\nserial numbers of users that exist on the device. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2186
        },
        {
          "method_name": "android.os.UserManager.getUserAccount",
          "documentation": "@return the user's account name, null if not found. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2207
        },
        {
          "method_name": "android.os.UserManager.setUserAccount",
          "documentation": "Set account name for the given user. @hide\n\n",
          "file": "./aosp/core/java/android/os/UserManager.java",
          "line": 2223
        },
        {
          "method_name": "com.android.settingslib.suggestions.SuggestionParser.satisifesRequiredUserType",
          "documentation": "",
          "file": "./aosp/packages/SettingsLib/src/com/android/settingslib/suggestions/SuggestionParser.java",
          "line": 234
        }
      ]
    },
    "android.permission.CREATE_USERS": {
      "name": "android.permission.CREATE_USERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS": {
      "name": "android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS",
      "label": "g\u00e9rer les propri\u00e9taires des profils et de l'appareil",
      "label_ptr": "permlab_manageProfileAndDeviceOwners",
      "description": "Autoriser les applications \u00e0 d\u00e9finir les propri\u00e9taires des profils et celui de l'appareil",
      "description_ptr": "permdesc_manageProfileAndDeviceOwners",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.GET_DETAILED_TASKS": {
      "name": "android.permission.GET_DETAILED_TASKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.REORDER_TASKS": {
      "name": "android.permission.REORDER_TASKS",
      "label": "r\u00e9organiser les applications en cours d'ex\u00e9cution",
      "label_ptr": "permlab_reorderTasks",
      "description": "Permet \u00e0 l'application de d\u00e9placer les t\u00e2ches au premier plan et en arri\u00e8re-plan. L'application peut proc\u00e9der \u00e0 ces op\u00e9rations sans votre intervention.",
      "description_ptr": "permdesc_reorderTasks",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.moveTaskToFront",
          "documentation": "Ask that the task associated with a given task ID be moved to the front of the\nstack, so it is now visible to the user. @param taskId The identifier of the\ntask to be moved, as found in {@link RunningTaskInfo} or {@link\nRecentTaskInfo}. @param flags Additional operational flags. @param options\nAdditional options for the operation, either null or as per {@link\nContext#startActivity(Intent, android.os.Bundle) Context.startActivity(Intent,\nBundle)}.\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2331
        }
      ]
    },
    "android.permission.REMOVE_TASKS": {
      "name": "android.permission.REMOVE_TASKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_ACTIVITY_STACKS": {
      "name": "android.permission.MANAGE_ACTIVITY_STACKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.setTaskWindowingMode",
          "documentation": "Sets the windowing mode for a specific task. Only works on tasks of type\n{@link WindowConfiguration#ACTIVITY_TYPE_STANDARD} @param taskId The id of the\ntask to set the windowing mode for. @param windowingMode The windowing mode to\nset for the task. @param toTop If the task should be moved to the top once the\nwindowing mode changes. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2038
        },
        {
          "method_name": "android.app.ActivityManager.setTaskWindowingModeSplitScreenPrimary",
          "documentation": "Moves the input task to the primary-split-screen stack. @param taskId Id of\ntask to move. @param createMode The mode the primary split screen stack should\nbe created in if it doesn't exist already. See {@link\nandroid.app.ActivityManager#SPLIT_SCREEN_CREATE_MODE_TOP_OR_LEFT} and {@link\nandroid.app.ActivityManager #SPLIT_SCREEN_CREATE_MODE_BOTTOM_OR_RIGHT} @param\ntoTop If the task and stack should be moved to the top. @param animate Whether\nwe should play an animation for the moving the task @param initialBounds If\nthe primary stack gets created, it will use these bounds for the docked stack.\nPass {@code null} to use default bounds. @param showRecents If the recents\nactivity should be shown on the other side of the task going into split-screen\nmode. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2066
        },
        {
          "method_name": "android.app.ActivityManager.resizeStack",
          "documentation": "Resizes the input stack id to the given bounds. @param stackId Id of the stack\nto resize. @param bounds Bounds to resize the stack to or {@code null} for\nfullscreen. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2084
        },
        {
          "method_name": "android.app.ActivityManager.removeStacksInWindowingModes",
          "documentation": "Removes stacks in the windowing modes from the system if they are of activity\ntype ACTIVITY_TYPE_STANDARD or ACTIVITY_TYPE_UNDEFINED @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2101
        },
        {
          "method_name": "android.app.ActivityManager.removeStacksWithActivityTypes",
          "documentation": "Removes stack of the activity types from the system. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 2116
        }
      ]
    },
    "android.permission.ACTIVITY_EMBEDDING": {
      "name": "android.permission.ACTIVITY_EMBEDDING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.START_ANY_ACTIVITY": {
      "name": "android.permission.START_ANY_ACTIVITY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SEND_SHOW_SUSPENDED_APP_DETAILS": {
      "name": "android.permission.SEND_SHOW_SUSPENDED_APP_DETAILS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.RESTART_PACKAGES": {
      "name": "android.permission.RESTART_PACKAGES",
      "label": "fermer les autres applications",
      "label_ptr": "permlab_killBackgroundProcesses",
      "description": "Permet \u00e0 l'application de mettre fin aux processus d'autres applications ex\u00e9cut\u00e9s en arri\u00e8re-plan. Cette autorisation peut interrompre l'ex\u00e9cution d'autres applications.",
      "description_ptr": "permdesc_killBackgroundProcesses",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.KILL_BACKGROUND_PROCESSES": {
      "name": "android.permission.KILL_BACKGROUND_PROCESSES",
      "label": "fermer les autres applications",
      "label_ptr": "permlab_killBackgroundProcesses",
      "description": "Permet \u00e0 l'application de mettre fin aux processus d'autres applications ex\u00e9cut\u00e9s en arri\u00e8re-plan. Cette autorisation peut interrompre l'ex\u00e9cution d'autres applications.",
      "description_ptr": "permdesc_killBackgroundProcesses",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.killBackgroundProcesses",
          "documentation": "Have the system immediately kill all background processes associated with the\ngiven package. This is the same as the kernel killing those processes to\nreclaim memory; the system will take care of restarting these processes in the\nfuture as needed. @param packageName The name of the package whose processes\nare to be killed.\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3678
        }
      ]
    },
    "android.permission.GET_PROCESS_STATE_AND_OOM_SCORE": {
      "name": "android.permission.GET_PROCESS_STATE_AND_OOM_SCORE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.GET_INTENT_SENDER_INTENT": {
      "name": "android.permission.GET_INTENT_SENDER_INTENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SYSTEM_ALERT_WINDOW": {
      "name": "android.permission.SYSTEM_ALERT_WINDOW",
      "label": "Cette application peut se superposer \u00e0 d'autres applications",
      "label_ptr": "permlab_systemAlertWindow",
      "description": "Cette application peut se superposer \u00e0 d'autres applications ou \u00e0 d'autres parties de l'\u00e9cran. Cela peut alt\u00e9rer l'utilisation normale des applications et modifier l'apparence des autres applications.",
      "description_ptr": "permdesc_systemAlertWindow",
      "permission_group": "",
      "protection_level": "signature|preinstalled|appop|pre23|development"
    },
    "android.permission.RUN_IN_BACKGROUND": {
      "name": "android.permission.RUN_IN_BACKGROUND",
      "label": "s'ex\u00e9cuter en arri\u00e8re-plan",
      "label_ptr": "permlab_runInBackground",
      "description": "Cette application peut s'ex\u00e9cuter en arri\u00e8re-plan, ce qui risque d'\u00e9puiser la batterie plus rapidement.",
      "description_ptr": "permdesc_runInBackground",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.USE_DATA_IN_BACKGROUND": {
      "name": "android.permission.USE_DATA_IN_BACKGROUND",
      "label": "consommer des donn\u00e9es en arri\u00e8re-plan",
      "label_ptr": "permlab_useDataInBackground",
      "description": "Cette application peut utiliser des donn\u00e9es en arri\u00e8re-plan, ce qui risque d'augmenter la consommation des donn\u00e9es.",
      "description_ptr": "permdesc_useDataInBackground",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_DISPLAY_OFFSET": {
      "name": "android.permission.SET_DISPLAY_OFFSET",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND": {
      "name": "android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND",
      "label": "s'ex\u00e9cuter en arri\u00e8re-plan",
      "label_ptr": "permlab_runInBackground",
      "description": "Cette application peut s'ex\u00e9cuter en arri\u00e8re-plan, ce qui risque d'\u00e9puiser la batterie plus rapidement.",
      "description_ptr": "permdesc_runInBackground",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND": {
      "name": "android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND",
      "label": "consommer des donn\u00e9es en arri\u00e8re-plan",
      "label_ptr": "permlab_useDataInBackground",
      "description": "Cette application peut utiliser des donn\u00e9es en arri\u00e8re-plan, ce qui risque d'augmenter la consommation des donn\u00e9es.",
      "description_ptr": "permdesc_useDataInBackground",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SET_WALLPAPER": {
      "name": "android.permission.SET_WALLPAPER",
      "label": "configurer le fond d'\u00e9cran",
      "label_ptr": "permlab_setWallpaper",
      "description": "Permet \u00e0 l'application de d\u00e9finir le fond d'\u00e9cran du syst\u00e8me.",
      "description_ptr": "permdesc_setWallpaper",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.app.WallpaperManager.setResource",
          "documentation": "Version of {@link #setResource(int)} that allows the caller to specify which\nof the supported wallpaper categories to set. @param resid The resource ID of\nthe bitmap to be used as the wallpaper image @param which Flags indicating\nwhich wallpaper(s) to configure with the new imagery @see #FLAG_LOCK @see\n#FLAG_SYSTEM @return An integer ID assigned to the newly active wallpaper; or\nzero on failure. @throws IOException\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1151
        },
        {
          "method_name": "android.app.WallpaperManager.setStream",
          "documentation": "Version of {@link #setStream(InputStream, Rect, boolean)} that allows the\ncaller to specify which of the supported wallpaper categories to set. @param\nbitmapData A stream containing the raw data to install as a wallpaper. This\ndata can be in any format handled by {@link BitmapRegionDecoder}. @param\nvisibleCropHint The rectangular subregion of the streamed image that should be\ndisplayed as wallpaper. Passing {@code null} for this parameter means that the\nfull image should be displayed if possible given the image's and device's\naspect ratios, etc. @param allowBackup {@code true} if the OS is permitted to\nback up this wallpaper image for restore to a future device; {@code false}\notherwise. @param which Flags indicating which wallpaper(s) to configure with\nthe new imagery. @return An integer ID assigned to the newly active wallpaper;\nor zero on failure. @see #getWallpaperId(int) @see #FLAG_LOCK @see\n#FLAG_SYSTEM @throws IOException\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1405
        },
        {
          "method_name": "android.app.WallpaperManager.clear",
          "documentation": "Remove one or more currently set wallpapers, reverting to the system default\ndisplay for each one. If {@link #FLAG_SYSTEM} is set in the {@code which}\nparameter, the intent {@link Intent#ACTION_WALLPAPER_CHANGED} will be\nbroadcast upon success. @param which A bitwise combination of {@link\n#FLAG_SYSTEM} or {@link #FLAG_LOCK} @throws IOException If an error occurs\nreverting to the built-in wallpaper.\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1831
        }
      ]
    },
    "android.permission.SET_WALLPAPER_HINTS": {
      "name": "android.permission.SET_WALLPAPER_HINTS",
      "label": "modifier la taille du fond d'\u00e9cran",
      "label_ptr": "permlab_setWallpaperHints",
      "description": "Permet \u00e0 l'application de d\u00e9finir les bulles d'aide concernant la taille du fond d'\u00e9cran du syst\u00e8me.",
      "description_ptr": "permdesc_setWallpaperHints",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.app.WallpaperManager.setDisplayPadding",
          "documentation": "Specify extra padding that the wallpaper should have outside of the display.\nThat is, the given padding supplies additional pixels the wallpaper should\nextend outside of the display itself.\n\nThis method requires the caller to hold the permission {@link\nandroid.Manifest.permission#SET_WALLPAPER_HINTS}. @param padding The number of\npixels the wallpaper should extend beyond the display, on its left, top,\nright, and bottom sides.\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1582
        }
      ]
    },
    "android.permission.READ_WALLPAPER_INTERNAL": {
      "name": "android.permission.READ_WALLPAPER_INTERNAL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SET_TIME": {
      "name": "android.permission.SET_TIME",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SET_TIME_ZONE": {
      "name": "android.permission.SET_TIME_ZONE",
      "label": "S\u00e9lection du fuseau horaire",
      "label_ptr": "permlab_setTimeZone",
      "description": "Permet \u00e0 l'application de modifier le fuseau horaire du t\u00e9l\u00e9phone.",
      "description_ptr": "permdesc_setTimeZone",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.EXPAND_STATUS_BAR": {
      "name": "android.permission.EXPAND_STATUS_BAR",
      "label": "Agrandir/r\u00e9duire la barre d'\u00e9tat",
      "label_ptr": "permlab_expandStatusBar",
      "description": "Permet \u00e0 l'application de r\u00e9duire ou de d\u00e9velopper la barre d'\u00e9tat.",
      "description_ptr": "permdesc_expandStatusBar",
      "permission_group": "",
      "protection_level": "normal"
    },
    "com.android.launcher.permission.INSTALL_SHORTCUT": {
      "name": "com.android.launcher.permission.INSTALL_SHORTCUT",
      "label": "Installer des raccourcis",
      "label_ptr": "permlab_install_shortcut",
      "description": "Permettre \u00e0 une application d'ajouter des raccourcis \u00e0 l'\u00e9cran d'accueil sans l'intervention de l'utilisateur",
      "description_ptr": "permdesc_install_shortcut",
      "permission_group": "",
      "protection_level": "normal"
    },
    "com.android.launcher.permission.UNINSTALL_SHORTCUT": {
      "name": "com.android.launcher.permission.UNINSTALL_SHORTCUT",
      "label": "d\u00e9sinstaller des raccourcis",
      "label_ptr": "permlab_uninstall_shortcut",
      "description": "Permettre \u00e0 l'application de supprimer des raccourcis de l'\u00e9cran d'accueil sans l'intervention de l'utilisateur",
      "description_ptr": "permdesc_uninstall_shortcut",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.READ_SYNC_SETTINGS": {
      "name": "android.permission.READ_SYNC_SETTINGS",
      "label": "lire les param\u00e8tres de synchronisation",
      "label_ptr": "permlab_readSyncSettings",
      "description": "Permet \u00e0 l'application d'acc\u00e9der aux param\u00e8tres de synchronisation d'un compte. Par exemple, cette autorisation peut permettre de d\u00e9terminer si l'application Contacts est synchronis\u00e9e avec un compte ou non.",
      "description_ptr": "permdesc_readSyncSettings",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.WRITE_SYNC_SETTINGS": {
      "name": "android.permission.WRITE_SYNC_SETTINGS",
      "label": "activer/d\u00e9sactiver la synchronisation",
      "label_ptr": "permlab_writeSyncSettings",
      "description": "Permet \u00e0 une application de modifier les param\u00e8tres de synchronisation d'un compte. Cette autorisation peut, par exemple, \u00eatre utilis\u00e9e pour activer la synchronisation de l'application Contacts avec un compte.",
      "description_ptr": "permdesc_writeSyncSettings",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.READ_SYNC_STATS": {
      "name": "android.permission.READ_SYNC_STATS",
      "label": "Lecture des statistiques de synchronisation",
      "label_ptr": "permlab_readSyncStats",
      "description": "Permet \u00e0 une application d'acc\u00e9der aux statistiques de synchronisation d'un compte, y compris l'historique des \u00e9v\u00e9nements de synchronisation et le volume de donn\u00e9es synchronis\u00e9es.",
      "description_ptr": "permdesc_readSyncStats",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SET_SCREEN_COMPATIBILITY": {
      "name": "android.permission.SET_SCREEN_COMPATIBILITY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CHANGE_CONFIGURATION": {
      "name": "android.permission.CHANGE_CONFIGURATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.WRITE_SETTINGS": {
      "name": "android.permission.WRITE_SETTINGS",
      "label": "modifier les param\u00e8tres du syst\u00e8me",
      "label_ptr": "permlab_writeSettings",
      "description": "Permet \u00e0 l'application de modifier les param\u00e8tres du syst\u00e8me. Des applications malveillantes peuvent exploiter cette fonctionnalit\u00e9 pour corrompre la configuration de votre syst\u00e8me.",
      "description_ptr": "permdesc_writeSettings",
      "permission_group": "",
      "protection_level": "signature|preinstalled|appop|pre23",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.isTetheringSupported",
          "documentation": "Check if the device allows for tethering. It may be disabled via {@code\nro.tether.denied} system property, Settings.TETHER_SUPPORTED or due to device\nconfiguration.\n\nIf this app does not have permission to use this API, it will always return\nfalse rather than throw an exception.\n\nIf the device has a hotspot provisioning app, the caller is required to hold\nthe {@link android.Manifest.permission.TETHER_PRIVILEGED} permission.\n\nOtherwise, this method requires the caller to hold the ability to modify\nsystem settings as determined by {@link\nandroid.provider.Settings.System#canWrite}.\n\n@return a boolean - {@code true} indicating Tethering is supported. {@hide}\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 2484
        }
      ]
    },
    "android.permission.WRITE_GSERVICES": {
      "name": "android.permission.WRITE_GSERVICES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.FORCE_STOP_PACKAGES": {
      "name": "android.permission.FORCE_STOP_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.forceStopPackage",
          "documentation": "@see #forceStopPackageAsUser(String, int) @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3739
        }
      ]
    },
    "android.permission.RETRIEVE_WINDOW_CONTENT": {
      "name": "android.permission.RETRIEVE_WINDOW_CONTENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SET_ANIMATION_SCALE": {
      "name": "android.permission.SET_ANIMATION_SCALE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.PERSISTENT_ACTIVITY": {
      "name": "android.permission.PERSISTENT_ACTIVITY",
      "label": "ex\u00e9cuter l'application en continu",
      "label_ptr": "permlab_persistentActivity",
      "description": "Permet \u00e0 l'application de rendre certains de ces composants persistants dans la m\u00e9moire. Cette autorisation peut limiter la m\u00e9moire disponible pour d'autres applications et ralentir le t\u00e9l\u00e9phone.",
      "description_ptr": "permdesc_persistentActivity",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.GET_PACKAGE_SIZE": {
      "name": "android.permission.GET_PACKAGE_SIZE",
      "label": "\u00e9valuer l'espace de stockage de l'application",
      "label_ptr": "permlab_getPackageSize",
      "description": "Permet \u00e0 l'application de r\u00e9cup\u00e9rer son code, ses donn\u00e9es et la taille de sa m\u00e9moire cache.",
      "description_ptr": "permdesc_getPackageSize",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.SET_PREFERRED_APPLICATIONS": {
      "name": "android.permission.SET_PREFERRED_APPLICATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|verifier",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.updateIntentVerificationStatusAsUser",
          "documentation": "Allow to change the status of a Intent Verification status for all\nIntentFilter of an App. This is related to the {@link\nandroid.content.IntentFilter#setAutoVerify(boolean)} and {@link\nandroid.content.IntentFilter#getAutoVerify()} This is used by the\nResolverActivity to change the status depending on what the User select in the\nDisambiguation Dialog and also used by the Settings App for changing the\ndefault App for a domain. @param packageName The package name of the Activity\nassociated with the IntentFilter. @param status The status to set to. This can\nbe {@link #INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ASK} or {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS} or {@link\n#INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER} @param userId The user id.\n@return true if the status has been set. False otherwise. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5067
        },
        {
          "method_name": "android.content.pm.PackageManager.setDefaultBrowserPackageNameAsUser",
          "documentation": "Set the default Browser package name for a specific user. @param packageName\nThe package name of the default Browser. @param userId The user id. @return\ntrue if the default Browser for the specified user has been set, otherwise\nreturn false. If the user id passed is -1 (all users) this call will not do\nanything and just return false. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5131
        }
      ]
    },
    "android.permission.RECEIVE_BOOT_COMPLETED": {
      "name": "android.permission.RECEIVE_BOOT_COMPLETED",
      "label": "s'ex\u00e9cuter au d\u00e9marrage",
      "label_ptr": "permlab_receiveBootCompleted",
      "description": "Permet \u00e0 l'application de se lancer une fois le d\u00e9marrage du syst\u00e8me termin\u00e9. Elle peut rallonger le temps de d\u00e9marrage du t\u00e9l\u00e9phone et ralentir son fonctionnement global en raison de son ex\u00e9cution continue.",
      "description_ptr": "permdesc_receiveBootCompleted",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.BROADCAST_STICKY": {
      "name": "android.permission.BROADCAST_STICKY",
      "label": "Envoi d'une diffusion persistante",
      "label_ptr": "permlab_broadcastSticky",
      "description": "Permet \u00e0 l'application d'envoyer des intentions de diffusion persistantes, qui perdurent une fois la diffusion termin\u00e9e. Une utilisation excessive peut ralentir le t\u00e9l\u00e9phone ou le rendre instable en l'obligeant \u00e0 utiliser trop de m\u00e9moire.",
      "description_ptr": "permdesc_broadcastSticky",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.content.Context.sendStickyBroadcast",
          "documentation": "Perform a {@link #sendBroadcast(Intent)} that is \"sticky,\" meaning the Intent\nyou are sending stays around after the broadcast is complete, so that others\ncan quickly retrieve that data through the return value of {@link\n#registerReceiver(BroadcastReceiver, IntentFilter)}. In all other ways, this\nbehaves the same as {@link #sendBroadcast(Intent)}. @deprecated Sticky\nbroadcasts should not be used. They provide no security (anyone can access\nthem), no protection (anyone can modify them), and many other problems. The\nrecommended pattern is to use a non-sticky broadcast to report that\n_something_ has changed, with another mechanism for apps to retrieve the\ncurrent value whenever desired. @param intent The Intent to broadcast; all\nreceivers matching this Intent will receive the broadcast, and the Intent will\nbe held to be re-broadcast to future receivers. @see #sendBroadcast(Intent)\n@see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int,\nString, Bundle)\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2351
        },
        {
          "method_name": "android.content.Context.sendStickyOrderedBroadcast",
          "documentation": "Version of {@link #sendStickyBroadcast} that allows you to receive data back\nfrom the broadcast. This is accomplished by supplying your own\nBroadcastReceiver when calling, which will be treated as a final receiver at\nthe end of the broadcast -- its {@link BroadcastReceiver#onReceive} method\nwill be called with the result values collected from the other receivers. The\nbroadcast will be serialized in the same way as calling {@link\n#sendOrderedBroadcast(Intent, String)}.\n\nLike {@link #sendBroadcast(Intent)}, this method is asynchronous; it will\nreturn before resultReceiver.onReceive() is called. Note that the sticky data\nstored is only the data you initially supply to the broadcast, not the result\nof any changes made by the receivers.\n\nSee {@link BroadcastReceiver} for more information on Intent broadcasts.\n@deprecated Sticky broadcasts should not be used. They provide no security\n(anyone can access them), no protection (anyone can modify them), and many\nother problems. The recommended pattern is to use a non-sticky broadcast to\nreport that _something_ has changed, with another mechanism for apps to\nretrieve the current value whenever desired. @param intent The Intent to\nbroadcast; all receivers matching this Intent will receive the broadcast.\n@param resultReceiver Your own BroadcastReceiver to treat as the final\nreceiver of the broadcast. @param scheduler A custom Handler with which to\nschedule the resultReceiver callback; if null it will be scheduled in the\nContext's main thread. @param initialCode An initial value for the result\ncode. Often Activity.RESULT_OK. @param initialData An initial value for the\nresult data. Often null. @param initialExtras An initial value for the result\nextras. Often null. @see #sendBroadcast(Intent) @see #sendBroadcast(Intent,\nString) @see #sendOrderedBroadcast(Intent, String) @see\n#sendStickyBroadcast(Intent) @see android.content.BroadcastReceiver @see\n#registerReceiver @see android.app.Activity#RESULT_OK\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2401
        },
        {
          "method_name": "android.content.Context.removeStickyBroadcast",
          "documentation": "Remove the data previously sent with {@link #sendStickyBroadcast}, so that it\nis as if the sticky broadcast had never happened. @deprecated Sticky\nbroadcasts should not be used. They provide no security (anyone can access\nthem), no protection (anyone can modify them), and many other problems. The\nrecommended pattern is to use a non-sticky broadcast to report that\n_something_ has changed, with another mechanism for apps to retrieve the\ncurrent value whenever desired. @param intent The Intent that was previously\nbroadcast. @see #sendStickyBroadcast\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2422
        },
        {
          "method_name": "android.content.Context.sendStickyBroadcastAsUser",
          "documentation": "@hide This is just here for sending CONNECTIVITY_ACTION.\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2459
        },
        {
          "method_name": "android.content.Context.sendStickyOrderedBroadcastAsUser",
          "documentation": "Version of {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver,\nHandler, int, String, Bundle)} that allows you to specify the user the\nbroadcast will be sent to. This is not available to applications that are not\npre-installed on the system image.\n\nSee {@link BroadcastReceiver} for more information on Intent broadcasts.\n@deprecated Sticky broadcasts should not be used. They provide no security\n(anyone can access them), no protection (anyone can modify them), and many\nother problems. The recommended pattern is to use a non-sticky broadcast to\nreport that _something_ has changed, with another mechanism for apps to\nretrieve the current value whenever desired. @param intent The Intent to\nbroadcast; all receivers matching this Intent will receive the broadcast.\n@param user UserHandle to send the intent to. @param resultReceiver Your own\nBroadcastReceiver to treat as the final receiver of the broadcast. @param\nscheduler A custom Handler with which to schedule the resultReceiver callback;\nif null it will be scheduled in the Context's main thread. @param initialCode\nAn initial value for the result code. Often Activity.RESULT_OK. @param\ninitialData An initial value for the result data. Often null. @param\ninitialExtras An initial value for the result extras. Often null. @see\n#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String,\nBundle)\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2499
        },
        {
          "method_name": "android.content.Context.removeStickyBroadcastAsUser",
          "documentation": "Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify\nthe user the broadcast will be sent to. This is not available to applications\nthat are not pre-installed on the system image.\n\nYou must hold the {@link android.Manifest.permission#BROADCAST_STICKY}\npermission in order to use this API. If you do not hold that permission,\n{@link SecurityException} will be thrown. @deprecated Sticky broadcasts should\nnot be used. They provide no security (anyone can access them), no protection\n(anyone can modify them), and many other problems. The recommended pattern is\nto use a non-sticky broadcast to report that _something_ has changed, with\nanother mechanism for apps to retrieve the current value whenever desired.\n@param intent The Intent that was previously broadcast. @param user UserHandle\nto remove the sticky broadcast from. @see #sendStickyBroadcastAsUser\n\n",
          "file": "./aosp/core/java/android/content/Context.java",
          "line": 2529
        }
      ]
    },
    "android.permission.MOUNT_UNMOUNT_FILESYSTEMS": {
      "name": "android.permission.MOUNT_UNMOUNT_FILESYSTEMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MOUNT_FORMAT_FILESYSTEMS": {
      "name": "android.permission.MOUNT_FORMAT_FILESYSTEMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.STORAGE_INTERNAL": {
      "name": "android.permission.STORAGE_INTERNAL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ASEC_ACCESS": {
      "name": "android.permission.ASEC_ACCESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ASEC_CREATE": {
      "name": "android.permission.ASEC_CREATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ASEC_DESTROY": {
      "name": "android.permission.ASEC_DESTROY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ASEC_MOUNT_UNMOUNT": {
      "name": "android.permission.ASEC_MOUNT_UNMOUNT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.ASEC_RENAME": {
      "name": "android.permission.ASEC_RENAME",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.WRITE_APN_SETTINGS": {
      "name": "android.permission.WRITE_APN_SETTINGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CHANGE_NETWORK_STATE": {
      "name": "android.permission.CHANGE_NETWORK_STATE",
      "label": "modifier la connectivit\u00e9 r\u00e9seau",
      "label_ptr": "permlab_changeNetworkState",
      "description": "Permet \u00e0 l'application de modifier l'\u00e9tat de la connectivit\u00e9 du r\u00e9seau.",
      "description_ptr": "permdesc_changeNetworkState",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.CLEAR_APP_CACHE": {
      "name": "android.permission.CLEAR_APP_CACHE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ALLOW_ANY_CODEC_FOR_PLAYBACK": {
      "name": "android.permission.ALLOW_ANY_CODEC_FOR_PLAYBACK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_CA_CERTIFICATES": {
      "name": "android.permission.MANAGE_CA_CERTIFICATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.RECOVERY": {
      "name": "android.permission.RECOVERY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.os.RecoverySystem.processPackage",
          "documentation": "Process a given package with uncrypt. No-op if the package is not on the /data\npartition. @param Context the Context to use @param packageFile the package to\nbe processed @param listener an object to receive periodic progress updates as\nprocessing proceeds. May be null. @throws IOException if there were any errors\nprocessing the package file. @hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 493
        },
        {
          "method_name": "android.os.RecoverySystem.installPackage",
          "documentation": "If the package hasn't been processed (i.e. uncrypt'd), set up\nUNCRYPT_PACKAGE_FILE and delete BLOCK_MAP_FILE to trigger uncrypt during the\nreboot. @param context the Context to use @param packageFile the update\npackage to install. Must be on a partition mountable by recovery. @param\nprocessed if the package has been processed (uncrypt'd). @throws IOException\nif writing the recovery command file fails, or if the reboot itself fails.\n@hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 537
        },
        {
          "method_name": "android.os.RecoverySystem.scheduleUpdateOnBoot",
          "documentation": "Schedule to install the given package on next boot. The caller needs to ensure\nthat the package must have been processed (uncrypt'd) if needed. It sets up\nthe command in BCB (bootloader control block), which will be read by the\nbootloader and the recovery image. @param Context the Context to use. @param\npackageFile the package to be installed. @throws IOException if there were any\nerrors setting up the BCB. @hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 629
        },
        {
          "method_name": "android.os.RecoverySystem.cancelScheduledUpdate",
          "documentation": "Cancel any scheduled update by clearing up the BCB (bootloader control block).\n@param Context the Context to use. @throws IOException if there were any\nerrors clearing up the BCB. @hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 667
        },
        {
          "method_name": "android.os.RecoverySystem.rebootWipeAb",
          "documentation": "Reboot into recovery and wipe the A/B device. @param Context the Context to\nuse. @param packageFile the wipe package to be applied. @param reason the\nreason to wipe. @throws IOException if something goes wrong. @hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 901
        },
        {
          "method_name": "android.os.SystemUpdateManager.retrieveSystemUpdateInfo",
          "documentation": "Queries the current pending system update info.\n\nRequires the {@link android.Manifest.permission#READ_SYSTEM_UPDATE_INFO} or\n{@link android.Manifest.permission#RECOVERY} permission. @return A {@code\nBundle} that contains the pending system update information in key-value\npairs. @throws SecurityException if the caller is not allowed to read the\ninfo.\n\n",
          "file": "./aosp/core/java/android/os/SystemUpdateManager.java",
          "line": 106
        },
        {
          "method_name": "android.os.SystemUpdateManager.updateSystemUpdateInfo",
          "documentation": "Allows a system updater to publish the pending update info.\n\nThe reported info will not persist across reboots. Because only the reporting\nupdater understands the criteria to determine a successful/failed update.\n\nRequires the {@link android.Manifest.permission#RECOVERY} permission. @param\ninfoBundle The {@code PersistableBundle} that contains the system update\ninformation, such as the current update status. {@link #KEY_STATUS} is\nrequired in the bundle. @throws IllegalArgumentException if @link #KEY_STATUS}\ndoes not exist. @throws SecurityException if the caller is not allowed to\nupdate the info.\n\n",
          "file": "./aosp/core/java/android/os/SystemUpdateManager.java",
          "line": 129
        }
      ]
    },
    "android.permission.READ_SYSTEM_UPDATE_INFO": {
      "name": "android.permission.READ_SYSTEM_UPDATE_INFO",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.os.SystemUpdateManager.retrieveSystemUpdateInfo",
          "documentation": "Queries the current pending system update info.\n\nRequires the {@link android.Manifest.permission#READ_SYSTEM_UPDATE_INFO} or\n{@link android.Manifest.permission#RECOVERY} permission. @return A {@code\nBundle} that contains the pending system update information in key-value\npairs. @throws SecurityException if the caller is not allowed to read the\ninfo.\n\n",
          "file": "./aosp/core/java/android/os/SystemUpdateManager.java",
          "line": 106
        }
      ]
    },
    "android.permission.BIND_JOB_SERVICE": {
      "name": "android.permission.BIND_JOB_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.UPDATE_CONFIG": {
      "name": "android.permission.UPDATE_CONFIG",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.QUERY_TIME_ZONE_RULES": {
      "name": "android.permission.QUERY_TIME_ZONE_RULES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.UPDATE_TIME_ZONE_RULES": {
      "name": "android.permission.UPDATE_TIME_ZONE_RULES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.TRIGGER_TIME_ZONE_RULES_CHECK": {
      "name": "android.permission.TRIGGER_TIME_ZONE_RULES_CHECK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.RESET_SHORTCUT_MANAGER_THROTTLING": {
      "name": "android.permission.RESET_SHORTCUT_MANAGER_THROTTLING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_NETWORK_RECOMMENDATION_SERVICE": {
      "name": "android.permission.BIND_NETWORK_RECOMMENDATION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CHANGE_OVERLAY_PACKAGES": {
      "name": "android.permission.CHANGE_OVERLAY_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.WRITE_SECURE_SETTINGS": {
      "name": "android.permission.WRITE_SECURE_SETTINGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.nfc.NfcAdapter.enable",
          "documentation": "Enable NFC hardware.\n\nThis call is asynchronous. Listen for {@link #ACTION_ADAPTER_STATE_CHANGED}\nbroadcasts to find out when the operation is complete.\n\nIf this returns true, then either NFC is already on, or a {@link\n#ACTION_ADAPTER_STATE_CHANGED} broadcast will be sent to indicate a state\ntransition. If this returns false, then there is some problem that prevents an\nattempt to turn NFC on (for example we are in airplane mode and NFC is not\ntoggleable in airplane mode on this platform). @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 848
        },
        {
          "method_name": "android.nfc.NfcAdapter.disable",
          "documentation": "Disable NFC hardware. @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 892
        },
        {
          "method_name": "android.nfc.NfcAdapter.enableSecureNfc",
          "documentation": "Sets Secure NFC feature.\n\nThis API is for the Settings application. @return True if successful @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 1722
        },
        {
          "method_name": "android.nfc.NfcAdapter.enableNdefPush",
          "documentation": "Enable NDEF Push feature.\n\nThis API is for the Settings application. @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 1779
        },
        {
          "method_name": "android.nfc.NfcAdapter.disableNdefPush",
          "documentation": "Disable NDEF Push feature.\n\nThis API is for the Settings application. @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 1798
        },
        {
          "method_name": "android.nfc.NfcAdapter.addNfcUnlockHandler",
          "documentation": "Registers a new NFC unlock handler with the NFC service.\n\nNFC unlock handlers are intended to unlock the keyguard in the presence of a\ntrusted NFC device. The handler should return true if it successfully\nauthenticates the user and unlocks the keyguard.\n\nThe parameter {@code tagTechnologies} determines which Tag technologies will\nbe polled for at the lockscreen. Polling for less tag technologies reduces\nlatency, and so it is strongly recommended to only provide the Tag\ntechnologies that the handler is expected to receive. There must be at least\none tag technology provided, otherwise the unlock handler is ignored. @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 1972
        },
        {
          "method_name": "android.nfc.NfcAdapter.removeNfcUnlockHandler",
          "documentation": "Removes a previously registered unlock handler. Also removes the tag\ntechnologies associated with the removed unlock handler. @hide\n\n",
          "file": "./aosp/core/java/android/nfc/NfcAdapter.java",
          "line": 2022
        },
        {
          "method_name": "android.view.inputmethod.InputMethodManager.setCurrentInputMethodSubtype",
          "documentation": "Switch to a new input method subtype of the current input method. @param\nsubtype A new input method subtype to switch. @return true if the current\nsubtype was successfully switched. When the specified subtype is null, this\nmethod returns false.\n\n",
          "file": "./aosp/core/java/android/view/inputmethod/InputMethodManager.java",
          "line": 2243
        },
        {
          "method_name": "android.location.LocationManager.setLocationEnabledForUser",
          "documentation": "Method for enabling or disabling location. @param enabled true to enable\nlocation. false to disable location @param userHandle the user to set @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1267
        },
        {
          "method_name": "android.location.LocationManager.setProviderEnabledForUser",
          "documentation": "Method for enabling or disabling a single location provider. @param provider\nthe name of the provider @param enabled true to enable the provider. false to\ndisable the provider @param userHandle the user to set @return true if the\nvalue was set, false on database errors @throws IllegalArgumentException if\nprovider is null @hide\n\n",
          "file": "./aosp/location/java/android/location/LocationManager.java",
          "line": 1362
        },
        {
          "method_name": "android.media.RingtoneManager.enableSyncFromParent",
          "documentation": "Enables Settings.System.SYNC_PARENT_SOUNDS for the content's user @hide\n\n",
          "file": "./aosp/media/java/android/media/RingtoneManager.java",
          "line": 794
        },
        {
          "method_name": "com.android.server.InputMethodManagerService.handleShellCommandEnableDisableInputMethod",
          "documentation": "Handles {@code adb shell ime enable} and {@code adb shell ime disable}. @param\nshellCommand {@link ShellCommand} object that is handling this command. @param\nenabled {@code true} if the command was {@code adb shell ime enable}. @return\nExit code of the command.\n\n",
          "file": "./aosp/services/core/java/com/android/server/InputMethodManagerService.java",
          "line": 4937
        },
        {
          "method_name": "com.android.server.InputMethodManagerService.handleShellCommandResetInputMethod",
          "documentation": "Handles {@code adb shell ime reset-ime}. @param shellCommand {@link\nShellCommand} object that is handling this command. @return Exit code of the\ncommand.\n\n",
          "file": "./aosp/services/core/java/com/android/server/InputMethodManagerService.java",
          "line": 4999
        },
        {
          "method_name": "android.telecom.TelecomManager.setDefaultDialer",
          "documentation": "Used to set the default dialer package. @param packageName to set the default\ndialer to. @result {@code true} if the default dialer was successfully\nchanged, {@code false} if the specified package does not correspond to an\ninstalled dialer, or is already the default dialer. Requires permission:\n{@link android.Manifest.permission#MODIFY_PHONE_STATE} Requires permission:\n{@link android.Manifest.permission#WRITE_SECURE_SETTINGS} @hide @deprecated\nUse RoleManager instead.\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1250
        }
      ]
    },
    "android.permission.DUMP": {
      "name": "android.permission.DUMP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.dumpPackageState",
          "documentation": "Perform a system dump of various state associated with the given application\npackage name. This call blocks while the dump is being performed, so should\nnot be done on a UI thread. The data will be written to the given file\ndescriptor as text. @param fd The file descriptor that the dump should be\nwritten to. The file descriptor is _not_ closed by this function; the caller\ncontinues to own it. @param packageName The name of the package that is to be\ndumped.\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 4082
        },
        {
          "method_name": "android.app.StatsManager.addConfig",
          "documentation": "Adds the given configuration and associates it with the given configKey. If a\nconfig with the given configKey already exists for the caller's uid, it is\nreplaced with the new one. @param configKey An arbitrary integer that allows\nclients to track the configuration. @param config Wire-encoded StatsdConfig\nproto that specifies metrics (and all dependencies eg, conditions and\nmatchers). @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service @throws IllegalArgumentException if config is not a\nwire-encoded StatsdConfig proto\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 103
        },
        {
          "method_name": "android.app.StatsManager.addConfiguration",
          "documentation": "@deprecated Use {@link #addConfig(long, byte[])}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 123
        },
        {
          "method_name": "android.app.StatsManager.removeConfig",
          "documentation": "Remove a configuration from logging. @param configKey Configuration key to\nremove. @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 139
        },
        {
          "method_name": "android.app.StatsManager.removeConfiguration",
          "documentation": "@deprecated Use {@link #removeConfig(long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 158
        },
        {
          "method_name": "android.app.StatsManager.setBroadcastSubscriber",
          "documentation": "@deprecated Use {@link #setBroadcastSubscriber(PendingIntent, long, long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 226
        },
        {
          "method_name": "android.app.StatsManager.setFetchReportsOperation",
          "documentation": "Registers the operation that is called to retrieve the metrics data. This must\nbe called each time statsd starts. The config must have been added first (via\n{@link #addConfig}, although addConfig could have been called on a previous\nboot). This operation allows statsd to send metrics data whenever statsd\ndetermines that the metrics in memory are approaching the memory limits. The\nfetch operation should call {@link #getReports} to fetch the data, which also\ndeletes the retrieved metrics from statsd's memory. @param pendingIntent the\nPendingIntent to use when broadcasting info to the subscriber associated with\nthe given subscriberId. May be null, in which case it removes any associated\npending intent with this configKey. @param configKey The integer naming the\nconfig to which this operation is attached. @throws StatsUnavailableException\nif unsuccessful due to failing to connect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 251
        },
        {
          "method_name": "android.app.StatsManager.setDataFetchOperation",
          "documentation": "@deprecated Use {@link #setFetchReportsOperation(PendingIntent, long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 279
        },
        {
          "method_name": "android.app.StatsManager.getReports",
          "documentation": "Request the data collected for the given configKey. This getter is destructive\n- it also clears the retrieved metrics from statsd's memory. @param configKey\nConfiguration key to retrieve data from. @return Serialized\nConfigMetricsReportList proto. @throws StatsUnavailableException if\nunsuccessful due to failing to connect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 297
        },
        {
          "method_name": "android.app.StatsManager.getData",
          "documentation": "@deprecated Use {@link #getReports(long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 316
        },
        {
          "method_name": "android.app.StatsManager.getStatsMetadata",
          "documentation": "Clients can request metadata for statsd. Will contain stats across all\nconfigurations but not the actual metrics themselves (metrics must be\ncollected via {@link #getReports(long)}. This getter is not destructive and\nwill not reset any metrics/counters. @return Serialized StatsdStatsReport\nproto. @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 333
        },
        {
          "method_name": "android.app.StatsManager.getMetadata",
          "documentation": "@deprecated Use {@link #getStatsMetadata()}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 352
        },
        {
          "method_name": "android.os.BugreportManager.startBugreport",
          "documentation": "Starts a bugreport.\n\nThis starts a bugreport in the background. However the call itself can take\nseveral seconds to return in the worst case. {@code callback} will receive\nprogress and status updates.\n\nThe bugreport artifacts will be copied over to the given file descriptors only\nif the user consents to sharing with the calling app.\n\n{@link BugreportManager} takes ownership of {@code bugreportFd} and {@code\nscreenshotFd}. @param bugreportFd file to write the bugreport. This should be\nopened in write-only, append mode. @param screenshotFd file to write the\nscreenshot, if necessary. This should be opened in write-only, append mode.\n@param params options that specify what kind of a bugreport should be taken\n@param callback callback for progress and status updates\n\n",
          "file": "./aosp/core/java/android/os/BugreportManager.java",
          "line": 144
        },
        {
          "method_name": "android.os.BugreportManager.cancelBugreport",
          "documentation": "",
          "file": "./aosp/core/java/android/os/BugreportManager.java",
          "line": 184
        },
        {
          "method_name": "android.os.IncidentManager.reportIncident",
          "documentation": "Take an incident report and put it in dropbox.\n\n",
          "file": "./aosp/core/java/android/os/IncidentManager.java",
          "line": 55
        },
        {
          "method_name": "com.android.server.os.BugreportManagerServiceImpl.setListener",
          "documentation": "",
          "file": "./aosp/services/core/java/com/android/server/os/BugreportManagerServiceImpl.java",
          "line": 67
        },
        {
          "method_name": "com.android.server.os.BugreportManagerServiceImpl.startBugreport",
          "documentation": "",
          "file": "./aosp/services/core/java/com/android/server/os/BugreportManagerServiceImpl.java",
          "line": 74
        },
        {
          "method_name": "com.android.server.os.BugreportManagerServiceImpl.cancelBugreport",
          "documentation": "",
          "file": "./aosp/services/core/java/com/android/server/os/BugreportManagerServiceImpl.java",
          "line": 104
        },
        {
          "method_name": "android.telecom.TelecomManager.dumpAnalytics",
          "documentation": "Dumps telecom analytics for uploading. @return @hide\n\n",
          "file": "./aosp/telecomm/java/android/telecom/TelecomManager.java",
          "line": 1858
        }
      ]
    },
    "android.permission.READ_LOGS": {
      "name": "android.permission.READ_LOGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.SET_DEBUG_APP": {
      "name": "android.permission.SET_DEBUG_APP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.SET_PROCESS_LIMIT": {
      "name": "android.permission.SET_PROCESS_LIMIT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.SET_ALWAYS_FINISH": {
      "name": "android.permission.SET_ALWAYS_FINISH",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.SIGNAL_PERSISTENT_PROCESSES": {
      "name": "android.permission.SIGNAL_PERSISTENT_PROCESSES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.GET_ACCOUNTS_PRIVILEGED": {
      "name": "android.permission.GET_ACCOUNTS_PRIVILEGED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.GET_PASSWORD": {
      "name": "android.permission.GET_PASSWORD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DIAGNOSTIC": {
      "name": "android.permission.DIAGNOSTIC",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.STATUS_BAR": {
      "name": "android.permission.STATUS_BAR",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.STATUS_BAR_SERVICE": {
      "name": "android.permission.STATUS_BAR_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_QUICK_SETTINGS_TILE": {
      "name": "android.permission.BIND_QUICK_SETTINGS_TILE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FORCE_BACK": {
      "name": "android.permission.FORCE_BACK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.UPDATE_DEVICE_STATS": {
      "name": "android.permission.UPDATE_DEVICE_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.AlarmManager.set",
          "documentation": "Direct callback version of {@link #set(int, long, long, long, PendingIntent,\nWorkSource)}. Note that repeating alarms must use the PendingIntent variant,\nnot an OnAlarmListener.\n\nThe OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will\nbe invoked via the specified target Handler, or on the application's main\nlooper if {@code null} is passed as the {@code targetHandler} parameter. @hide\n\n",
          "file": "./aosp/core/java/android/app/AlarmManager.java",
          "line": 659
        },
        {
          "method_name": "android.app.job.JobScheduler.scheduleAsPackage",
          "documentation": "@param job The job to be scheduled. @param packageName The package on behalf\nof which the job is to be scheduled. This will be used to track battery usage\nand appIdleState. @param userId User on behalf of whom this job is to be\nscheduled. @param tag Debugging tag for dumps associated with this job\n(instead of the service class) @hide\n\n",
          "file": "./aosp/core/java/android/app/job/JobScheduler.java",
          "line": 141
        },
        {
          "method_name": "android.bluetooth.le.BluetoothLeScanner.startScanFromSource",
          "documentation": "Start Bluetooth LE scan. Same as {@link #startScan(List, ScanSettings,\nScanCallback)} but allows the caller to specify on behalf of which\napplication(s) the work is being done. @param filters {@link ScanFilter}s for\nfinding exact BLE devices. @param settings Settings for the scan. @param\nworkSource {@link WorkSource} identifying the application(s) for which to\nblame for the scan. @param callback Callback used to deliver scan results.\n@hide\n\n",
          "file": "./aosp/core/java/android/bluetooth/le/BluetoothLeScanner.java",
          "line": 201
        },
        {
          "method_name": "android.net.wifi.WifiManager.startScan",
          "documentation": "\n\n",
          "file": "./aosp/wifi/java/android/net/wifi/WifiManager.java",
          "line": 1645
        }
      ]
    },
    "android.permission.GET_APP_OPS_STATS": {
      "name": "android.permission.GET_APP_OPS_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.app.AppOpsManager.getPackagesForOps",
          "documentation": "Retrieve current operation state for all applications. @param ops The set of\noperations you are interested in, or null if you want all of them. @hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1849
        },
        {
          "method_name": "android.app.AppOpsManager.getOpsForPackage",
          "documentation": "Retrieve current operation state for one application. @param uid The uid of\nthe application of interest. @param packageName The name of the application of\ninterest. @param ops The set of operations you are interested in, or null if\nyou want all of them. @hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1867
        }
      ]
    },
    "android.permission.UPDATE_APP_OPS_STATS": {
      "name": "android.permission.UPDATE_APP_OPS_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|installer"
    },
    "android.permission.MANAGE_APP_OPS_RESTRICTIONS": {
      "name": "android.permission.MANAGE_APP_OPS_RESTRICTIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer"
    },
    "android.permission.MANAGE_APP_OPS_MODES": {
      "name": "android.permission.MANAGE_APP_OPS_MODES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer|verifier",
      "methods": [
        {
          "method_name": "android.app.AppOpsManager.setUidMode",
          "documentation": "Sets given app op in the specified mode for app ops in the UID. This applies\nto all apps currently in the UID or installed in this UID in the future.\n@param appOp The app op. @param uid The UID for which to set the app. @param\nmode The app op mode to set. @hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1906
        },
        {
          "method_name": "android.app.AppOpsManager.setMode",
          "documentation": "Change the operating mode for the given op in the given app package. You must\npass in both the uid and name of the application whose mode is being modified;\nif these do not match, the modification will not be applied. @param op The\noperation to modify. One of the OPSTR_* constants. @param uid The user id of\nthe application whose mode will be changed. @param packageName The name of the\napplication package name whose mode will be changed. @hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1959
        },
        {
          "method_name": "android.app.AppOpsManager.setRestriction",
          "documentation": "Set a non-persisted restriction on an audio operation at a stream-level.\nRestrictions are temporary additional constraints imposed on top of the\npersisted rules defined by {@link #setMode}. @param code The operation to\nrestrict. @param usage The {@link android.media.AudioAttributes} usage value.\n@param mode The restriction mode (MODE_IGNORED,MODE_ERRORED) or MODE_ALLOWED\nto unrestrict. @param exceptionPackages Optional list of packages to exclude\nfrom the restriction. @hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1980
        },
        {
          "method_name": "android.app.AppOpsManager.resetAllModes",
          "documentation": "\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 1993
        }
      ]
    },
    "android.permission.INTERNAL_SYSTEM_WINDOW": {
      "name": "android.permission.INTERNAL_SYSTEM_WINDOW",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS": {
      "name": "android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer"
    },
    "android.permission.MANAGE_APP_TOKENS": {
      "name": "android.permission.MANAGE_APP_TOKENS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.REGISTER_WINDOW_MANAGER_LISTENERS": {
      "name": "android.permission.REGISTER_WINDOW_MANAGER_LISTENERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FREEZE_SCREEN": {
      "name": "android.permission.FREEZE_SCREEN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.INJECT_EVENTS": {
      "name": "android.permission.INJECT_EVENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FILTER_EVENTS": {
      "name": "android.permission.FILTER_EVENTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.RETRIEVE_WINDOW_TOKEN": {
      "name": "android.permission.RETRIEVE_WINDOW_TOKEN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MODIFY_ACCESSIBILITY_DATA": {
      "name": "android.permission.MODIFY_ACCESSIBILITY_DATA",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CHANGE_ACCESSIBILITY_VOLUME": {
      "name": "android.permission.CHANGE_ACCESSIBILITY_VOLUME",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FRAME_STATS": {
      "name": "android.permission.FRAME_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.TEMPORARY_ENABLE_ACCESSIBILITY": {
      "name": "android.permission.TEMPORARY_ENABLE_ACCESSIBILITY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_ACTIVITY_WATCHER": {
      "name": "android.permission.SET_ACTIVITY_WATCHER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SHUTDOWN": {
      "name": "android.permission.SHUTDOWN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.STOP_APP_SWITCHES": {
      "name": "android.permission.STOP_APP_SWITCHES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.GET_TOP_ACTIVITY_INFO": {
      "name": "android.permission.GET_TOP_ACTIVITY_INFO",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_INPUT_STATE": {
      "name": "android.permission.READ_INPUT_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_INPUT_METHOD": {
      "name": "android.permission.BIND_INPUT_METHOD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_MIDI_DEVICE_SERVICE": {
      "name": "android.permission.BIND_MIDI_DEVICE_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_ACCESSIBILITY_SERVICE": {
      "name": "android.permission.BIND_ACCESSIBILITY_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_PRINT_SERVICE": {
      "name": "android.permission.BIND_PRINT_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_PRINT_RECOMMENDATION_SERVICE": {
      "name": "android.permission.BIND_PRINT_RECOMMENDATION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_PRINT_SERVICES": {
      "name": "android.permission.READ_PRINT_SERVICES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|preinstalled",
      "methods": [
        {
          "method_name": "android.print.PrintManager.addPrintServicesChangeListener",
          "documentation": "Listen for changes to the installed and enabled print services. @param\nlistener the listener to add @param handler the handler the listener is called\nback on @see android.print.PrintManager#getPrintServices @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 562
        },
        {
          "method_name": "android.print.PrintManager.removePrintServicesChangeListener",
          "documentation": "Stop listening for changes to the installed and enabled print services. @param\nlistener the listener to remove @see\nandroid.print.PrintManager#getPrintServices @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 598
        },
        {
          "method_name": "android.print.PrintManager.getPrintServices",
          "documentation": "Gets the list of print services, but does not register for updates. The user\nhas to register for updates by itself, or use {@link PrintServicesLoader}.\n@param selectionFlags flags selecting which services to get. Either {@link\n#ENABLED_SERVICES},{@link #DISABLED_SERVICES}, or both. @return The print\nservice list or an empty list. @see\n#addPrintServicesChangeListener(PrintServicesChangeListener, Handler) @see\n#removePrintServicesChangeListener(PrintServicesChangeListener) @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 640
        }
      ]
    },
    "android.permission.READ_PRINT_SERVICE_RECOMMENDATIONS": {
      "name": "android.permission.READ_PRINT_SERVICE_RECOMMENDATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|preinstalled",
      "methods": [
        {
          "method_name": "android.print.PrintManager.addPrintServiceRecommendationsChangeListener",
          "documentation": "Listen for changes to the print service recommendations. @param listener the\nlistener to add @param handler the handler the listener is called back on @see\nandroid.print.PrintManager#getPrintServiceRecommendations @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 666
        },
        {
          "method_name": "android.print.PrintManager.removePrintServiceRecommendationsChangeListener",
          "documentation": "Stop listening for changes to the print service recommendations. @param\nlistener the listener to remove @see\nandroid.print.PrintManager#getPrintServiceRecommendations @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 703
        },
        {
          "method_name": "android.print.PrintManager.getPrintServiceRecommendations",
          "documentation": "Gets the list of print service recommendations, but does not register for\nupdates. The user has to register for updates by itself, or use {@link\nPrintServiceRecommendationsLoader}. @return The print service recommendations\nlist or an empty list. @see #addPrintServiceRecommendationsChangeListener @see\n#removePrintServiceRecommendationsChangeListener @hide\n\n",
          "file": "./aosp/core/java/android/print/PrintManager.java",
          "line": 743
        }
      ]
    },
    "android.permission.BIND_NFC_SERVICE": {
      "name": "android.permission.BIND_NFC_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_PRINT_SPOOLER_SERVICE": {
      "name": "android.permission.BIND_PRINT_SPOOLER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_COMPANION_DEVICE_MANAGER_SERVICE": {
      "name": "android.permission.BIND_COMPANION_DEVICE_MANAGER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_RUNTIME_PERMISSION_PRESENTER_SERVICE": {
      "name": "android.permission.BIND_RUNTIME_PERMISSION_PRESENTER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_TEXT_SERVICE": {
      "name": "android.permission.BIND_TEXT_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_VPN_SERVICE": {
      "name": "android.permission.BIND_VPN_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_WALLPAPER": {
      "name": "android.permission.BIND_WALLPAPER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_VOICE_INTERACTION": {
      "name": "android.permission.BIND_VOICE_INTERACTION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_AUTOFILL_SERVICE": {
      "name": "android.permission.BIND_AUTOFILL_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_AUTOFILL": {
      "name": "android.permission.BIND_AUTOFILL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_AUTOFILL_FIELD_CLASSIFICATION_SERVICE": {
      "name": "android.permission.BIND_AUTOFILL_FIELD_CLASSIFICATION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_TEXTCLASSIFIER_SERVICE": {
      "name": "android.permission.BIND_TEXTCLASSIFIER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_VOICE_KEYPHRASES": {
      "name": "android.permission.MANAGE_VOICE_KEYPHRASES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_REMOTE_DISPLAY": {
      "name": "android.permission.BIND_REMOTE_DISPLAY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_TV_INPUT": {
      "name": "android.permission.BIND_TV_INPUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_TV_REMOTE_SERVICE": {
      "name": "android.permission.BIND_TV_REMOTE_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.TV_VIRTUAL_REMOTE_CONTROLLER": {
      "name": "android.permission.TV_VIRTUAL_REMOTE_CONTROLLER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CHANGE_HDMI_CEC_ACTIVE_SOURCE": {
      "name": "android.permission.CHANGE_HDMI_CEC_ACTIVE_SOURCE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvView.setMain",
          "documentation": "Sets this as the main {@link TvView}.\n\nThe main {@link TvView} is a {@link TvView} whose corresponding TV input\ndetermines the HDMI-CEC active source device. For an HDMI port input, one of\nsource devices that is connected to that HDMI port becomes the active source.\nFor an HDMI-CEC logical device input, the corresponding HDMI-CEC logical\ndevice becomes the active source. For any non-HDMI input (including the tuner,\ncomposite, S-Video, etc.), the internal device (= TV itself) becomes the\nactive source.\n\nFirst tuned {@link TvView} becomes main automatically, and keeps to be main\nuntil either {@link #reset} is called for the main {@link TvView} or {@code\nsetMain()} is called for other {@link TvView}. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvView.java",
          "line": 204
        }
      ]
    },
    "android.permission.MODIFY_PARENTAL_CONTROLS": {
      "name": "android.permission.MODIFY_PARENTAL_CONTROLS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvInputManager.setParentalControlsEnabled",
          "documentation": "Sets the user's parental controls enabled state. @param enabled The user's\nparental controls enabled state. {@code true} if the user enabled the parental\ncontrols, {@code false} otherwise. @see #isParentalControlsEnabled @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1305
        },
        {
          "method_name": "android.media.tv.TvInputManager.addBlockedRating",
          "documentation": "Adds a user blocked content rating. @param rating The content rating to block.\n@see #isRatingBlocked @see #removeBlockedRating @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1355
        },
        {
          "method_name": "android.media.tv.TvInputManager.removeBlockedRating",
          "documentation": "Removes a user blocked content rating. @param rating The content rating to\nunblock. @see #isRatingBlocked @see #addBlockedRating @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1374
        },
        {
          "method_name": "android.media.tv.TvView.unblockContent",
          "documentation": "Requests to unblock TV content according to the given rating.\n\nThis notifies TV input that blocked content is now OK to play. @param\nunblockedRating A TvContentRating to unblock. @see\nTvInputService.Session#notifyContentBlocked(TvContentRating) @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvView.java",
          "line": 397
        }
      ]
    },
    "android.permission.READ_CONTENT_RATING_SYSTEMS": {
      "name": "android.permission.READ_CONTENT_RATING_SYSTEMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvInputManager.getTvContentRatingSystemList",
          "documentation": "Returns the list of all TV content rating systems defined. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1389
        }
      ]
    },
    "android.permission.NOTIFY_TV_INPUTS": {
      "name": "android.permission.NOTIFY_TV_INPUTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.tv.TvInputManager.notifyPreviewProgramBrowsableDisabled",
          "documentation": "Notifies the TV input of the given preview program that the program's\nbrowsable state is disabled. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1404
        },
        {
          "method_name": "android.media.tv.TvInputManager.notifyWatchNextProgramBrowsableDisabled",
          "documentation": "Notifies the TV input of the given watch next program that the program's\nbrowsable state is disabled. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1423
        },
        {
          "method_name": "android.media.tv.TvInputManager.notifyPreviewProgramAddedToWatchNext",
          "documentation": "Notifies the TV input of the given preview program that the program is added\nto watch next. @hide\n\n",
          "file": "./aosp/media/java/android/media/tv/TvInputManager.java",
          "line": 1441
        }
      ]
    },
    "android.permission.BIND_ROUTE_PROVIDER": {
      "name": "android.permission.BIND_ROUTE_PROVIDER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_DEVICE_ADMIN": {
      "name": "android.permission.BIND_DEVICE_ADMIN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_DEVICE_ADMINS": {
      "name": "android.permission.MANAGE_DEVICE_ADMINS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.admin.DevicePolicyManager.setActiveProfileOwner",
          "documentation": "@hide @deprecated Use #ACTION_SET_PROFILE_OWNER Sets the given component as an\nactive admin and registers the package as the profile owner for this user. The\npackage must already be installed and there shouldn't be an existing profile\nowner registered for this user. Also, this method must be called before the\nuser setup has been completed.\n\nThis method can only be called by system apps that hold MANAGE_USERS\npermission and MANAGE_DEVICE_ADMINS permission. @param admin The component to\nregister as an active admin and profile owner. @param ownerName The user-\nvisible name of the entity that is managing this user. @return whether the\nadmin was successfully registered as the profile owner. @throws\nIllegalArgumentException if packageName is null, the package isn't installed,\nor the user has already been set up.\n\n",
          "file": "./aosp/core/java/android/app/admin/DevicePolicyManager.java",
          "line": 5363
        }
      ]
    },
    "android.permission.SET_ORIENTATION": {
      "name": "android.permission.SET_ORIENTATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_POINTER_SPEED": {
      "name": "android.permission.SET_POINTER_SPEED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_INPUT_CALIBRATION": {
      "name": "android.permission.SET_INPUT_CALIBRATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_KEYBOARD_LAYOUT": {
      "name": "android.permission.SET_KEYBOARD_LAYOUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.TABLET_MODE": {
      "name": "android.permission.TABLET_MODE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.REQUEST_INSTALL_PACKAGES": {
      "name": "android.permission.REQUEST_INSTALL_PACKAGES",
      "label": "demander l'installation de packages",
      "label_ptr": "permlab_requestInstallPackages",
      "description": "Permet \u00e0 une application de demander l'installation de packages.",
      "description_ptr": "permdesc_requestInstallPackages",
      "permission_group": "",
      "protection_level": "signature|appop"
    },
    "android.permission.REQUEST_DELETE_PACKAGES": {
      "name": "android.permission.REQUEST_DELETE_PACKAGES",
      "label": "demander la suppression de packages",
      "label_ptr": "permlab_requestDeletePackages",
      "description": "Permet \u00e0 une application de demander la suppression de packages.",
      "description_ptr": "permdesc_requestDeletePackages",
      "permission_group": "",
      "protection_level": "normal",
      "methods": [
        {
          "method_name": "android.content.pm.PackageInstaller.uninstall",
          "documentation": "Uninstall the given package with a specific version code, removing it\ncompletely from the device. This method is only available to the current\n\"installer of record\" for the package. If the version code of the package does\nnot match the one passed in the versioned package argument this method is a\nno-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to uninstall the latest\nversion of the package. @param versionedPackage The versioned package to\nuninstall. @param flags Flags for uninstall. @param statusReceiver Where to\ndeliver the result. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageInstaller.java",
          "line": 533
        }
      ]
    },
    "android.permission.INSTALL_PACKAGES": {
      "name": "android.permission.INSTALL_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.PackageInstaller.setPermissionsResult",
          "documentation": "\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageInstaller.java",
          "line": 547
        },
        {
          "method_name": "android.content.pm.PackageManager.installExistingPackageAsUser",
          "documentation": "If there is already an application with the given package name installed on\nthe system for other users, also install it for the specified user. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 4942
        },
        {
          "method_name": "android.content.pm.PackageManager.setUpdateAvailable",
          "documentation": "\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5155
        }
      ]
    },
    "android.permission.INSTALL_SELF_UPDATES": {
      "name": "android.permission.INSTALL_SELF_UPDATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.INSTALL_PACKAGE_UPDATES": {
      "name": "android.permission.INSTALL_PACKAGE_UPDATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "com.android.permission.INSTALL_EXISTING_PACKAGES": {
      "name": "com.android.permission.INSTALL_EXISTING_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CLEAR_APP_USER_DATA": {
      "name": "android.permission.CLEAR_APP_USER_DATA",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer"
    },
    "android.permission.GET_APP_GRANTED_URI_PERMISSIONS": {
      "name": "android.permission.GET_APP_GRANTED_URI_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CLEAR_APP_GRANTED_URI_PERMISSIONS": {
      "name": "android.permission.CLEAR_APP_GRANTED_URI_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MANAGE_SCOPED_ACCESS_DIRECTORY_PERMISSIONS": {
      "name": "android.permission.MANAGE_SCOPED_ACCESS_DIRECTORY_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FORCE_PERSISTABLE_URI_PERMISSIONS": {
      "name": "android.permission.FORCE_PERSISTABLE_URI_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DELETE_CACHE_FILES": {
      "name": "android.permission.DELETE_CACHE_FILES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.INTERNAL_DELETE_CACHE_FILES": {
      "name": "android.permission.INTERNAL_DELETE_CACHE_FILES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DELETE_PACKAGES": {
      "name": "android.permission.DELETE_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.PackageInstaller.uninstall",
          "documentation": "Uninstall the given package with a specific version code, removing it\ncompletely from the device. This method is only available to the current\n\"installer of record\" for the package. If the version code of the package does\nnot match the one passed in the versioned package argument this method is a\nno-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to uninstall the latest\nversion of the package. @param versionedPackage The versioned package to\nuninstall. @param flags Flags for uninstall. @param statusReceiver Where to\ndeliver the result. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageInstaller.java",
          "line": 533
        },
        {
          "method_name": "android.content.pm.PackageManager.deletePackage",
          "documentation": "Attempts to delete a package. Since this may take a little while, the result\nwill be posted back to the given observer. A deletion will fail if the calling\ncontext lacks the {@link android.Manifest.permission#DELETE_PACKAGES}\npermission, if the named package cannot be found, or if the named package is a\nsystem package. @param packageName The name of the package to delete @param\nobserver An observer callback to get notified when the package deletion is\ncomplete. {@link android.content.pm.IPackageDeleteObserver#packageDeleted}\nwill be called when that happens. observer may be null to indicate that no\ncallback is desired. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5175
        },
        {
          "method_name": "android.content.pm.PackageManager.deletePackageAsUser",
          "documentation": "Attempts to delete a package. Since this may take a little while, the result\nwill be posted back to the given observer. A deletion will fail if the named\npackage cannot be found, or if the named package is a system package. @param\npackageName The name of the package to delete @param observer An observer\ncallback to get notified when the package deletion is complete. {@link\nandroid.content.pm.IPackageDeleteObserver#packageDeleted} will be called when\nthat happens. observer may be null to indicate that no callback is desired.\n@param userId The user Id @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5197
        }
      ]
    },
    "android.permission.MOVE_PACKAGE": {
      "name": "android.permission.MOVE_PACKAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CHANGE_COMPONENT_ENABLED_STATE": {
      "name": "android.permission.CHANGE_COMPONENT_ENABLED_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.GRANT_RUNTIME_PERMISSIONS": {
      "name": "android.permission.GRANT_RUNTIME_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer|verifier",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.grantRuntimePermission",
          "documentation": "Grant a runtime permission to an application which the application does not\nalready have. The permission must have been requested by the application. If\nthe application is not allowed to hold the permission, a {@link\njava.lang.SecurityException} is thrown. If the package or permission is\ninvalid, a {@link java.lang.IllegalArgumentException} is thrown.\n\n**Note:** Using this API requires holding\nandroid.permission.GRANT_RUNTIME_PERMISSIONS and if the user id is not the\ncurrent user android.permission.INTERACT_ACROSS_USERS_FULL.\n\n@param packageName The package to which to grant the permission. @param\npermissionName The permission name to grant. @param user The user for which to\ngrant the permission. @see #revokeRuntimePermission(String, String,\nandroid.os.UserHandle) @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3639
        },
        {
          "method_name": "android.content.pm.PackageManager.getPermissionFlags",
          "documentation": "Gets the state flags associated with a permission. @param permissionName The\npermission for which to get the flags. @param packageName The package name for\nwhich to get the flags. @param user The user for which to get permission\nflags. @return The permission flags. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3684
        },
        {
          "method_name": "android.content.pm.PackageManager.updatePermissionFlags",
          "documentation": "Updates the flags associated with a permission by replacing the flags in the\nspecified mask with the provided flag values. @param permissionName The\npermission for which to update the flags. @param packageName The package name\nfor which to update the flags. @param flagMask The flags which to replace.\n@param flagValues The flags with which to replace. @param user The user for\nwhich to update the permission flags. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3704
        }
      ]
    },
    "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS": {
      "name": "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer|verifier"
    },
    "android.permission.REVOKE_RUNTIME_PERMISSIONS": {
      "name": "android.permission.REVOKE_RUNTIME_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer|verifier",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.revokeRuntimePermission",
          "documentation": "Revoke a runtime permission that was previously granted by {@link\n#grantRuntimePermission(String, String, android.os.UserHandle)}. The\npermission must have been requested by and granted to the application. If the\napplication is not allowed to hold the permission, a {@link\njava.lang.SecurityException} is thrown. If the package or permission is\ninvalid, a {@link java.lang.IllegalArgumentException} is thrown.\n\n**Note:** Using this API requires holding\nandroid.permission.REVOKE_RUNTIME_PERMISSIONS and if the user id is not the\ncurrent user android.permission.INTERACT_ACROSS_USERS_FULL.\n\n@param packageName The package from which to revoke the permission. @param\npermissionName The permission name to revoke. @param user The user for which\nto revoke the permission. @see #grantRuntimePermission(String, String,\nandroid.os.UserHandle) @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3666
        },
        {
          "method_name": "android.content.pm.PackageManager.getPermissionFlags",
          "documentation": "Gets the state flags associated with a permission. @param permissionName The\npermission for which to get the flags. @param packageName The package name for\nwhich to get the flags. @param user The user for which to get permission\nflags. @return The permission flags. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3684
        },
        {
          "method_name": "android.content.pm.PackageManager.updatePermissionFlags",
          "documentation": "Updates the flags associated with a permission by replacing the flags in the\nspecified mask with the provided flag values. @param permissionName The\npermission for which to update the flags. @param packageName The package name\nfor which to update the flags. @param flagMask The flags which to replace.\n@param flagValues The flags with which to replace. @param user The user for\nwhich to update the permission flags. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3704
        }
      ]
    },
    "android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS": {
      "name": "android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.addOnPermissionsChangeListener",
          "documentation": "Adds a listener for permission changes for installed packages. @param listener\nThe listener to add. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5604
        },
        {
          "method_name": "android.content.pm.PackageManager.removeOnPermissionsChangeListener",
          "documentation": "Remvoes a listener for permission changes for installed packages. @param\nlistener The listener to remove. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5615
        }
      ]
    },
    "android.permission.ACCESS_SURFACE_FLINGER": {
      "name": "android.permission.ACCESS_SURFACE_FLINGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_FRAME_BUFFER": {
      "name": "android.permission.READ_FRAME_BUFFER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_INPUT_FLINGER": {
      "name": "android.permission.ACCESS_INPUT_FLINGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DISABLE_INPUT_DEVICE": {
      "name": "android.permission.DISABLE_INPUT_DEVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.view.InputDevice.enable",
          "documentation": "Enables the input device. @hide\n\n",
          "file": "./aosp/core/java/android/view/InputDevice.java",
          "line": 792
        },
        {
          "method_name": "android.view.InputDevice.disable",
          "documentation": "Disables the input device. @hide\n\n",
          "file": "./aosp/core/java/android/view/InputDevice.java",
          "line": 803
        }
      ]
    },
    "android.permission.CONFIGURE_WIFI_DISPLAY": {
      "name": "android.permission.CONFIGURE_WIFI_DISPLAY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CONTROL_WIFI_DISPLAY": {
      "name": "android.permission.CONTROL_WIFI_DISPLAY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CONFIGURE_DISPLAY_COLOR_MODE": {
      "name": "android.permission.CONFIGURE_DISPLAY_COLOR_MODE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.view.Display.requestColorMode",
          "documentation": "Request the display applies a color mode. @hide\n\n",
          "file": "./aosp/core/java/android/view/Display.java",
          "line": 832
        }
      ]
    },
    "android.permission.CONTROL_DISPLAY_SATURATION": {
      "name": "android.permission.CONTROL_DISPLAY_SATURATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.display.DisplayManager.setSaturationLevel",
          "documentation": "Set the level of color saturation to apply to the display. @param level The\namount of saturation to apply, between 0 and 1 inclusive. 0 produces a\ngrayscale image, 1 is normal. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 559
        }
      ]
    },
    "android.permission.BRIGHTNESS_SLIDER_USAGE": {
      "name": "android.permission.BRIGHTNESS_SLIDER_USAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.hardware.display.DisplayManager.getBrightnessEvents",
          "documentation": "Fetch {@link BrightnessChangeEvent}s. @hide until we make it a system api.\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 655
        }
      ]
    },
    "android.permission.ACCESS_AMBIENT_LIGHT_STATS": {
      "name": "android.permission.ACCESS_AMBIENT_LIGHT_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.hardware.display.DisplayManager.getAmbientBrightnessStats",
          "documentation": "Fetch {@link AmbientBrightnessDayStats}s. @hide until we make it a system api\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 667
        }
      ]
    },
    "android.permission.CONFIGURE_DISPLAY_BRIGHTNESS": {
      "name": "android.permission.CONFIGURE_DISPLAY_BRIGHTNESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.hardware.display.DisplayManager.setBrightnessConfiguration",
          "documentation": "Sets the global display brightness configuration. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 679
        },
        {
          "method_name": "android.hardware.display.DisplayManager.getBrightnessConfiguration",
          "documentation": "Gets the global display brightness configuration or the default curve if one\nhasn't been set. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 704
        },
        {
          "method_name": "android.hardware.display.DisplayManager.getDefaultBrightnessConfiguration",
          "documentation": "Gets the default global display brightness configuration or null one hasn't\nbeen configured. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/display/DisplayManager.java",
          "line": 731
        }
      ]
    },
    "android.permission.CONTROL_DISPLAY_BRIGHTNESS": {
      "name": "android.permission.CONTROL_DISPLAY_BRIGHTNESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CONTROL_VPN": {
      "name": "android.permission.CONTROL_VPN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.VpnService.prepareAndAuthorize",
          "documentation": "Version of {@link #prepare(Context)} which does not require user consent.\n\nRequires {@link android.Manifest.permission#CONTROL_VPN} and should generally\nnot be used. Only acceptable in situations where user consent has been\nobtained through other means.\n\nOnce this is run, future preparations may be done with the standard prepare\nmethod as this will authorize the package to prepare the VPN without consent\nin the future. @hide\n\n",
          "file": "./aosp/core/java/android/net/VpnService.java",
          "line": 228
        }
      ]
    },
    "android.permission.CONTROL_ALWAYS_ON_VPN": {
      "name": "android.permission.CONTROL_ALWAYS_ON_VPN",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.setAlwaysOnVpnPackageForUser",
          "documentation": "Configures an always-on VPN connection through a specific application. This\nconnection is automatically granted and persisted after a reboot.\n\nThe designated package should declare a {@link VpnService} in its manifest\nguarded by {@link android.Manifest.permission.BIND_VPN_SERVICE}, otherwise the\ncall will fail. @param userId The identifier of the user to set an always-on\nVPN for. @param vpnPackage The package name for an installed VPN app on the\ndevice, or {@code null} to remove an existing always-on VPN configuration.\n@param lockdownEnabled {@code true} to disallow networking when the VPN is not\nconnected or {@code false} otherwise. @param lockdownWhitelist The list of\npackages that are allowed to access network directly when VPN is in lockdown\nmode but is not running. Non-existent packages are ignored so this method must\nbe called when a package that should be whitelisted is installed or\nuninstalled. @return {@code true} if the package is set as always-on VPN\ncontroller; {@code false} otherwise. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1056
        },
        {
          "method_name": "android.net.ConnectivityManager.getAlwaysOnVpnPackageForUser",
          "documentation": "Returns the package name of the currently set always-on VPN application. If\nthere is no always-on VPN set, or the VPN is provided by the system instead of\nby an app, {@code null} will be returned. @return Package name of VPN\ncontroller responsible for always-on VPN, or {@code null} if none is set.\n@hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1076
        },
        {
          "method_name": "android.net.ConnectivityManager.isVpnLockdownEnabled",
          "documentation": "@return whether always-on VPN is in lockdown mode. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1090
        },
        {
          "method_name": "android.net.ConnectivityManager.getVpnLockdownWhitelist",
          "documentation": "@return the list of packages that are allowed to access network when always-on\nVPN is in lockdown mode but not connected. Returns {@code null} when VPN\nlockdown is not active. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1106
        }
      ]
    },
    "android.permission.CAPTURE_AUDIO_OUTPUT": {
      "name": "android.permission.CAPTURE_AUDIO_OUTPUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CAPTURE_AUDIO_HOTWORD": {
      "name": "android.permission.CAPTURE_AUDIO_HOTWORD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MODIFY_AUDIO_ROUTING": {
      "name": "android.permission.MODIFY_AUDIO_ROUTING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.AudioManager.requestAudioFocus",
          "documentation": "@hide Request or lock audio focus. This method is to be used by system\ncomponents that have registered an {@link\nandroid.media.audiopolicy.AudioPolicy} to request audio focus, but also to\n\"lock\" it so focus granting is temporarily disabled. @param afr see the\ndescription of the same parameter in {@link\n#requestAudioFocus(AudioFocusRequest)} @param ap a registered {@link\nandroid.media.audiopolicy.AudioPolicy} instance when locking focus, or null.\n@return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link\n#AUDIOFOCUS_REQUEST_GRANTED} or {@link #AUDIOFOCUS_REQUEST_DELAYED}. @throws\nNullPointerException if the AudioFocusRequest is null @throws\nIllegalArgumentException when trying to lock focus without an AudioPolicy\n\n",
          "file": "./aosp/media/java/android/media/AudioManager.java",
          "line": 2697
        },
        {
          "method_name": "android.media.AudioManager.setFocusRequestResult",
          "documentation": "@hide Set the result to the audio focus request received through {@link\nAudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo, int)}. @param afi\nthe information about the focus requester @param requestResult the result to\nthe focus request to be passed to the requester @param ap a valid registered\n{@link AudioPolicy} configured as a focus policy.\n\n",
          "file": "./aosp/media/java/android/media/AudioManager.java",
          "line": 2865
        },
        {
          "method_name": "android.media.AudioManager.dispatchAudioFocusChange",
          "documentation": "@hide Notifies an application with a focus listener of gain or loss of audio\nfocus. This method can only be used by owners of an {@link AudioPolicy}\nconfigured with {@link AudioPolicy.Builder#setIsAudioFocusPolicy(boolean)} set\nto true. @param afi the recipient of the focus change, that has previously\nrequested audio focus, and that was received by the {@code AudioPolicy}\nthrough {@link\nAudioPolicy.AudioPolicyFocusListener#onAudioFocusRequest(AudioFocusInfo,\nint)}. @param focusChange one of focus gain types ({@link #AUDIOFOCUS_GAIN},\n{@link #AUDIOFOCUS_GAIN_TRANSIENT}, {@link\n#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or {@link\n#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}) or one of the focus loss types ({@link\nAudioManager#AUDIOFOCUS_LOSS}, {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT},\nor {@link AudioManager#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK}).  \nFor the focus gain, the change type should be the same as the app requested.\n@param ap a valid registered {@link AudioPolicy} configured as a focus policy.\n@return {@link #AUDIOFOCUS_REQUEST_GRANTED} if the dispatch was successfully\nsent, or {@link #AUDIOFOCUS_REQUEST_FAILED} if the focus client didn't have a\nlistener, or if there was an error sending the request. @throws\nNullPointerException if the {@link AudioFocusInfo} or {@link AudioPolicy} are\nnull.\n\n",
          "file": "./aosp/media/java/android/media/AudioManager.java",
          "line": 2904
        },
        {
          "method_name": "android.media.AudioManager.registerAudioPolicy",
          "documentation": "@hide Register the given {@link AudioPolicy}. This call is synchronous and\nblocks until the registration process successfully completed or failed to\ncomplete. @param policy the non-null {@link AudioPolicy} to register. @return\n{@link #ERROR} if there was an error communicating with the registration\nservice or if the user doesn't have the required {@link\nandroid.Manifest.permission#MODIFY_AUDIO_ROUTING} permission, {@link #SUCCESS}\notherwise.\n\n",
          "file": "./aosp/media/java/android/media/AudioManager.java",
          "line": 3166
        },
        {
          "method_name": "android.media.AudioManager.unregisterAudioPolicyAsync",
          "documentation": "@hide @param policy the non-null {@link AudioPolicy} to unregister.\n\n",
          "file": "./aosp/media/java/android/media/AudioManager.java",
          "line": 3192
        }
      ]
    },
    "android.permission.CAPTURE_VIDEO_OUTPUT": {
      "name": "android.permission.CAPTURE_VIDEO_OUTPUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CAPTURE_SECURE_VIDEO_OUTPUT": {
      "name": "android.permission.CAPTURE_SECURE_VIDEO_OUTPUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MEDIA_CONTENT_CONTROL": {
      "name": "android.permission.MEDIA_CONTENT_CONTROL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SET_VOLUME_KEY_LONG_PRESS_LISTENER": {
      "name": "android.permission.SET_VOLUME_KEY_LONG_PRESS_LISTENER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.media.session.MediaSessionManager.setOnVolumeKeyLongPressListener",
          "documentation": "Set the volume key long-press listener. While the listener is set, the\nlistener gets the volume key long-presses instead of changing volume.\n\nSystem can only have a single volume key long-press listener. @param listener\nThe volume key long-press listener. {@code null} to reset. @param handler The\nhandler on which the listener should be invoked, or {@code null} if the\nlistener should be invoked on the calling thread's looper. @hide\n\n",
          "file": "./aosp/media/java/android/media/session/MediaSessionManager.java",
          "line": 640
        }
      ]
    },
    "android.permission.SET_MEDIA_KEY_LISTENER": {
      "name": "android.permission.SET_MEDIA_KEY_LISTENER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development",
      "methods": [
        {
          "method_name": "android.media.session.MediaSessionManager.setOnMediaKeyListener",
          "documentation": "Set the media key listener. While the listener is set, the listener gets the\nmedia key before any other media sessions but after the global priority\nsession. If the listener handles the key (i.e. returns {@code true}), other\nsessions will not get the event.\n\nSystem can only have a single media key listener. @param listener The media\nkey listener. {@code null} to reset. @param handler The handler on which the\nlistener should be invoked, or {@code null} if the listener should be invoked\non the calling thread's looper. @hide\n\n",
          "file": "./aosp/media/java/android/media/session/MediaSessionManager.java",
          "line": 676
        }
      ]
    },
    "android.permission.BRICK": {
      "name": "android.permission.BRICK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.REBOOT": {
      "name": "android.permission.REBOOT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.os.RecoverySystem.rebootWipeAb",
          "documentation": "Reboot into recovery and wipe the A/B device. @param Context the Context to\nuse. @param packageFile the wipe package to be applied. @param reason the\nreason to wipe. @throws IOException if something goes wrong. @hide\n\n",
          "file": "./aosp/core/java/android/os/RecoverySystem.java",
          "line": 901
        }
      ]
    },
    "android.permission.DEVICE_POWER": {
      "name": "android.permission.DEVICE_POWER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.os.PowerManager.userActivity",
          "documentation": "Notifies the power manager that user activity happened.\n\nResets the auto-off timer and brightens the screen if the device is not\nasleep. This is what happens normally when a key or the touch screen is\npressed or when some other user activity occurs. This method does not wake up\nthe device if it has been put to sleep.\n\nRequires the {@link android.Manifest.permission#DEVICE_POWER} or {@link\nandroid.Manifest.permission#USER_ACTIVITY} permission.\n\n@param when The time of the user activity, in the {@link\nSystemClock#uptimeMillis()} time base. This timestamp is used to correctly\norder the user activity request with other power management functions. It\nshould be set to the timestamp of the input event that caused the user\nactivity. @param event The user activity event. @param flags Optional user\nactivity flags. @see #wakeUp @see #goToSleep @hide Requires signature or\nsystem permission.\n\n",
          "file": "./aosp/core/java/android/os/PowerManager.java",
          "line": 853
        }
      ]
    },
    "android.permission.USER_ACTIVITY": {
      "name": "android.permission.USER_ACTIVITY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.os.PowerManager.userActivity",
          "documentation": "Notifies the power manager that user activity happened.\n\nResets the auto-off timer and brightens the screen if the device is not\nasleep. This is what happens normally when a key or the touch screen is\npressed or when some other user activity occurs. This method does not wake up\nthe device if it has been put to sleep.\n\nRequires the {@link android.Manifest.permission#DEVICE_POWER} or {@link\nandroid.Manifest.permission#USER_ACTIVITY} permission.\n\n@param when The time of the user activity, in the {@link\nSystemClock#uptimeMillis()} time base. This timestamp is used to correctly\norder the user activity request with other power management functions. It\nshould be set to the timestamp of the input event that caused the user\nactivity. @param event The user activity event. @param flags Optional user\nactivity flags. @see #wakeUp @see #goToSleep @hide Requires signature or\nsystem permission.\n\n",
          "file": "./aosp/core/java/android/os/PowerManager.java",
          "line": 853
        }
      ]
    },
    "android.permission.NET_TUNNELING": {
      "name": "android.permission.NET_TUNNELING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.FACTORY_TEST": {
      "name": "android.permission.FACTORY_TEST",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BROADCAST_PACKAGE_REMOVED": {
      "name": "android.permission.BROADCAST_PACKAGE_REMOVED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BROADCAST_SMS": {
      "name": "android.permission.BROADCAST_SMS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BROADCAST_WAP_PUSH": {
      "name": "android.permission.BROADCAST_WAP_PUSH",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BROADCAST_NETWORK_PRIVILEGED": {
      "name": "android.permission.BROADCAST_NETWORK_PRIVILEGED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MASTER_CLEAR": {
      "name": "android.permission.MASTER_CLEAR",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CALL_PRIVILEGED": {
      "name": "android.permission.CALL_PRIVILEGED",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.telephony.TelephonyManager.getCompleteVoiceMailNumber",
          "documentation": "Returns the complete voice mail number. Return null if it is unavailable.\n@param subId @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 3931
        }
      ]
    },
    "android.permission.PERFORM_CDMA_PROVISIONING": {
      "name": "android.permission.PERFORM_CDMA_PROVISIONING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.PERFORM_SIM_ACTIVATION": {
      "name": "android.permission.PERFORM_SIM_ACTIVATION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CONTROL_LOCATION_UPDATES": {
      "name": "android.permission.CONTROL_LOCATION_UPDATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.telephony.TelephonyManager.enableLocationUpdates",
          "documentation": "Enables location update notifications for a subscription. {@link\nPhoneStateListener#onCellLocationChanged\nPhoneStateListener.onCellLocationChanged} will be called on location updates.\n@param subId for which the location updates are enabled @hide\n\n",
          "file": "./aosp/telephony/java/android/telephony/TelephonyManager.java",
          "line": 1865
        }
      ]
    },
    "android.permission.ACCESS_CHECKIN_PROPERTIES": {
      "name": "android.permission.ACCESS_CHECKIN_PROPERTIES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.PACKAGE_USAGE_STATS": {
      "name": "android.permission.PACKAGE_USAGE_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development|appop",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.getPackageImportance",
          "documentation": "Return the importance of a given package name, based on the processes that are\ncurrently running. The return value is one of the importance constants defined\nin {@link RunningAppProcessInfo}, giving you the highest importance of all the\nprocesses that this package has code running inside of. If there are no\nprocesses running its code, {@link RunningAppProcessInfo#IMPORTANCE_GONE} is\nreturned. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3507
        },
        {
          "method_name": "android.app.ActivityManager.getUidImportance",
          "documentation": "Return the importance of a given uid, based on the processes that are\ncurrently running. The return value is one of the importance constants defined\nin {@link RunningAppProcessInfo}, giving you the highest importance of all the\nprocesses that this uid has running. If there are no processes running its\ncode, {@link RunningAppProcessInfo#IMPORTANCE_GONE} is returned. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3527
        },
        {
          "method_name": "android.app.ActivityManager.addOnUidImportanceListener",
          "documentation": "Start monitoring changes to the imoportance of uids running in the system.\n@param listener The listener callback that will receive change reports. @param\nimportanceCutpoint The level of importance in which the caller is interested\nin differences. For example, if {@link\nRunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE} is used here, you will receive a\ncall each time a uids importance transitions between being <= {@link\nRunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE} and > {@link\nRunningAppProcessInfo#IMPORTANCE_PERCEPTIBLE}.\n\nThe caller must hold the {@link\nandroid.Manifest.permission#PACKAGE_USAGE_STATS} permission to use this\nfeature.\n\n@throws IllegalArgumentException If the listener is already registered.\n@throws SecurityException If the caller does not hold {@link\nandroid.Manifest.permission#PACKAGE_USAGE_STATS}. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3575
        },
        {
          "method_name": "android.app.ActivityManager.removeOnUidImportanceListener",
          "documentation": "Remove an importance listener that was previously registered with {@link\n#addOnUidImportanceListener}. @throws IllegalArgumentException If the listener\nis not registered. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3604
        },
        {
          "method_name": "android.app.StatsManager.addConfig",
          "documentation": "Adds the given configuration and associates it with the given configKey. If a\nconfig with the given configKey already exists for the caller's uid, it is\nreplaced with the new one. @param configKey An arbitrary integer that allows\nclients to track the configuration. @param config Wire-encoded StatsdConfig\nproto that specifies metrics (and all dependencies eg, conditions and\nmatchers). @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service @throws IllegalArgumentException if config is not a\nwire-encoded StatsdConfig proto\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 103
        },
        {
          "method_name": "android.app.StatsManager.addConfiguration",
          "documentation": "@deprecated Use {@link #addConfig(long, byte[])}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 123
        },
        {
          "method_name": "android.app.StatsManager.removeConfig",
          "documentation": "Remove a configuration from logging. @param configKey Configuration key to\nremove. @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 139
        },
        {
          "method_name": "android.app.StatsManager.removeConfiguration",
          "documentation": "@deprecated Use {@link #removeConfig(long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 158
        },
        {
          "method_name": "android.app.StatsManager.setBroadcastSubscriber",
          "documentation": "@deprecated Use {@link #setBroadcastSubscriber(PendingIntent, long, long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 226
        },
        {
          "method_name": "android.app.StatsManager.setFetchReportsOperation",
          "documentation": "Registers the operation that is called to retrieve the metrics data. This must\nbe called each time statsd starts. The config must have been added first (via\n{@link #addConfig}, although addConfig could have been called on a previous\nboot). This operation allows statsd to send metrics data whenever statsd\ndetermines that the metrics in memory are approaching the memory limits. The\nfetch operation should call {@link #getReports} to fetch the data, which also\ndeletes the retrieved metrics from statsd's memory. @param pendingIntent the\nPendingIntent to use when broadcasting info to the subscriber associated with\nthe given subscriberId. May be null, in which case it removes any associated\npending intent with this configKey. @param configKey The integer naming the\nconfig to which this operation is attached. @throws StatsUnavailableException\nif unsuccessful due to failing to connect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 251
        },
        {
          "method_name": "android.app.StatsManager.setDataFetchOperation",
          "documentation": "@deprecated Use {@link #setFetchReportsOperation(PendingIntent, long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 279
        },
        {
          "method_name": "android.app.StatsManager.getReports",
          "documentation": "Request the data collected for the given configKey. This getter is destructive\n- it also clears the retrieved metrics from statsd's memory. @param configKey\nConfiguration key to retrieve data from. @return Serialized\nConfigMetricsReportList proto. @throws StatsUnavailableException if\nunsuccessful due to failing to connect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 297
        },
        {
          "method_name": "android.app.StatsManager.getData",
          "documentation": "@deprecated Use {@link #getReports(long)}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 316
        },
        {
          "method_name": "android.app.StatsManager.getStatsMetadata",
          "documentation": "Clients can request metadata for statsd. Will contain stats across all\nconfigurations but not the actual metrics themselves (metrics must be\ncollected via {@link #getReports(long)}. This getter is not destructive and\nwill not reset any metrics/counters. @return Serialized StatsdStatsReport\nproto. @throws StatsUnavailableException if unsuccessful due to failing to\nconnect to stats service\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 333
        },
        {
          "method_name": "android.app.StatsManager.getMetadata",
          "documentation": "@deprecated Use {@link #getStatsMetadata()}\n\n",
          "file": "./aosp/core/java/android/app/StatsManager.java",
          "line": 352
        },
        {
          "method_name": "android.app.usage.UsageStatsManager.getAppStandbyBucket",
          "documentation": "{@hide} Returns the current standby bucket of the specified app. The caller\nmust hold the permission android.permission.PACKAGE_USAGE_STATS. @param\npackageName the package for which to fetch the current standby bucket.\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 500
        },
        {
          "method_name": "android.app.usage.UsageStatsManager.getAppStandbyBuckets",
          "documentation": "{@hide} Returns the current standby bucket of every app that has a bucket\nassigned to it. The caller must hold the permission\nandroid.permission.PACKAGE_USAGE_STATS. The key of the returned Map is the\npackage name and the value is the bucket assigned to the package. @see\n#getAppStandbyBucket()\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 538
        },
        {
          "method_name": "android.content.pm.dex.ArtManager.snapshotRuntimeProfile",
          "documentation": "Snapshots a runtime profile according to the {@code profileType} parameter. If\n{@code profileType} is {@link ArtManager#PROFILE_APPS} the method will\nsnapshot the profile for for an apk belonging to the package {@code\npackageName}. The apk is identified by {@code codePath}. If {@code\nprofileType} is {@code ArtManager.PROFILE_BOOT_IMAGE} the method will snapshot\nthe profile for the boot image. In this case {@code codePath can be null}. The\nparameters {@code packageName} and {@code codePath} are ignored. u The calling\nprocess must have {@code android.permission.READ_RUNTIME_PROFILE} permission.\nThe result will be posted on the {@code executor} using the given {@code\ncallback}. The profile will be available as a read-only {@link\nandroid.os.ParcelFileDescriptor}. This method will throw {@link\nIllegalStateException} if {@link ArtManager#isRuntimeProfilingEnabled(int)}\ndoes not return true for the given {@code profileType}. @param profileType the\ntype of profile that should be snapshot (boot image or app) @param packageName\nthe target package name or null if the target is the boot image @param\ncodePath the code path for which the profile should be retrieved or null if\nthe target is the boot image @param callback the callback which should be used\nfor the result @param executor the executor which should be used to post the\nresult\n\n",
          "file": "./aosp/core/java/android/content/pm/dex/ArtManager.java",
          "line": 108
        },
        {
          "method_name": "android.content.pm.dex.ArtManager.isRuntimeProfilingEnabled",
          "documentation": "Returns true if runtime profiles are enabled for the given type, false\notherwise. The calling process must have {@code\nandroid.permission.READ_RUNTIME_PROFILE} permission. @param profileType can be\neither {@link ArtManager#PROFILE_APPS} or {@link\nArtManager#PROFILE_BOOT_IMAGE}\n\n",
          "file": "./aosp/core/java/android/content/pm/dex/ArtManager.java",
          "line": 132
        },
        {
          "method_name": "android.os.IncidentManager.reportIncident",
          "documentation": "Take an incident report and put it in dropbox.\n\n",
          "file": "./aosp/core/java/android/os/IncidentManager.java",
          "line": 55
        }
      ]
    },
    "android.permission.OBSERVE_APP_USAGE": {
      "name": "android.permission.OBSERVE_APP_USAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.usage.UsageStatsManager.registerAppUsageObserver",
          "documentation": "@hide Register an app usage limit observer that receives a callback on the\nprovided intent when the sum of usages of apps in the packages array exceeds\nthe {@code timeLimit} specified. The observer will automatically be\nunregistered when the time limit is reached and the intent is delivered.\nRegistering an {@code observerId} that was already registered will override\nthe previous one. No more than 1000 unique {@code observerId} may be\nregistered by a single uid at any one time. @param observerId A unique id\nassociated with the group of apps to be monitored. There can be multiple\ngroups with common packages and different time limits. @param packages The\nlist of packages to observe for foreground activity time. Cannot be null and\nmust include at least one package. @param timeLimit The total time the set of\napps can be in the foreground before the callbackIntent is delivered. Must be\nat least one minute. @param timeUnit The unit for time specified in {@code\ntimeLimit}. Cannot be null. @param callbackIntent The PendingIntent that will\nbe dispatched when the time limit is exceeded by the group of apps. The\ndelivered Intent will also contain the extras {@link #EXTRA_OBSERVER_ID},\n{@link #EXTRA_TIME_LIMIT} and {@link #EXTRA_TIME_USED}. Cannot be null.\n@throws SecurityException if the caller doesn't have the OBSERVE_APP_USAGE\npermission or is not the profile owner of this user.\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 603
        },
        {
          "method_name": "android.app.usage.UsageStatsManager.unregisterAppUsageObserver",
          "documentation": "@hide Unregister the app usage observer specified by the {@code observerId}.\nThis will only apply to any observer registered by this application.\nUnregistering an observer that was already unregistered or never registered\nwill have no effect. @param observerId The id of the observer that was\npreviously registered. @throws SecurityException if the caller doesn't have\nthe OBSERVE_APP_USAGE permission or is not the profile owner of this user.\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 624
        }
      ]
    },
    "android.permission.CHANGE_APP_IDLE_STATE": {
      "name": "android.permission.CHANGE_APP_IDLE_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.usage.UsageStatsManager.setAppStandbyBucket",
          "documentation": "{@hide} Changes an app's standby bucket to the provided value. The caller can\nonly set the standby bucket for a different app than itself. @param\npackageName the package name of the app to set the bucket for. A\nSecurityException will be thrown if the package name is that of the caller.\n@param bucket the standby bucket to set it to, which should be one of\nSTANDBY_BUCKET_*. Setting a standby bucket outside of the range of\nSTANDBY_BUCKET_ACTIVE to STANDBY_BUCKET_NEVER will result in a\nSecurityException.\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 521
        },
        {
          "method_name": "android.app.usage.UsageStatsManager.setAppStandbyBuckets",
          "documentation": "{@hide} Changes the app standby bucket for multiple apps at once. The Map is\nkeyed by the package name and the value is one of STANDBY_BUCKET_*. @param\nappBuckets a map of package name to bucket value.\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 563
        }
      ]
    },
    "android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST": {
      "name": "android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.BroadcastOptions.setTemporaryAppWhitelistDuration",
          "documentation": "Set a duration for which the system should temporary place an application on\nthe power whitelist when this broadcast is being delivered to it. @param\nduration The duration in milliseconds; 0 means to not place on whitelist.\n\n",
          "file": "./aosp/core/java/android/app/BroadcastOptions.java",
          "line": 85
        },
        {
          "method_name": "android.app.usage.UsageStatsManager.whitelistAppTemporarily",
          "documentation": "{@hide} Temporarily whitelist the specified app for a short duration. This is\nto allow an app receiving a high priority message to be able to access the\nnetwork and acquire wakelocks even if the device is in power-save mode or the\napp is currently considered inactive. @param packageName The package name of\nthe app to whitelist. @param duration Duration to whitelist the app for, in\nmilliseconds. It is recommended that this be limited to 10s of seconds.\nRequested duration will be clamped to a few minutes. @param user The user for\nwhom the package should be whitelisted. Passing in a user that is not the same\nas the caller's process will require the INTERACT_ACROSS_USERS permission.\n@see #isAppInactive(String)\n\n",
          "file": "./aosp/core/java/android/app/usage/UsageStatsManager.java",
          "line": 715
        }
      ]
    },
    "android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS": {
      "name": "android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
      "label": "demander \u00e0 ignorer les optimisations de batterie",
      "label_ptr": "permlab_requestIgnoreBatteryOptimizations",
      "description": "Autorise une application \u00e0 demander l'autorisation d'ignorer les optimisations de batterie pour cette application.",
      "description_ptr": "permdesc_requestIgnoreBatteryOptimizations",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.BATTERY_STATS": {
      "name": "android.permission.BATTERY_STATS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|development"
    },
    "android.permission.STATSCOMPANION": {
      "name": "android.permission.STATSCOMPANION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BACKUP": {
      "name": "android.permission.BACKUP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.backup.BackupManager.beginRestoreSession",
          "documentation": "Begin the process of restoring data from backup. See the {@link\nandroid.app.backup.RestoreSession} class for documentation on that process.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 332
        },
        {
          "method_name": "android.app.backup.BackupManager.setBackupEnabled",
          "documentation": "Enable/disable the backup service entirely. When disabled, no backup or\nrestore operations will take place. Data-changed notifications will still be\nobserved and collected, however, so that changes made while the mechanism was\ndisabled will still be backed up properly if it is enabled at some point in\nthe future. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 360
        },
        {
          "method_name": "android.app.backup.BackupManager.isBackupEnabled",
          "documentation": "Report whether the backup mechanism is currently enabled. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 378
        },
        {
          "method_name": "android.app.backup.BackupManager.isBackupServiceActive",
          "documentation": "Report whether the backup mechanism is currently active. When it is inactive,\nthe device will not perform any backup operations, nor will it deliver data\nfor restore, although clients can still safely call BackupManager methods.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 399
        },
        {
          "method_name": "android.app.backup.BackupManager.setAutoRestore",
          "documentation": "Enable/disable data restore at application install time. When enabled, app\ninstallation will include an attempt to fetch the app's historical data from\nthe archival restore dataset (if any). When disabled, no such attempt will be\nmade. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 423
        },
        {
          "method_name": "android.app.backup.BackupManager.getCurrentTransport",
          "documentation": "Identify the currently selected transport. @return The name of the currently\nactive backup transport. In case of failure or if no transport is currently\nactive, this method returns {@code null}. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 443
        },
        {
          "method_name": "android.app.backup.BackupManager.listAllTransports",
          "documentation": "Request a list of all available backup transports' names. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 462
        },
        {
          "method_name": "android.app.backup.BackupManager.updateTransportAttributes",
          "documentation": "Update the attributes of the transport identified by {@code\ntransportComponent}. If the specified transport has not been bound at least\nonce (for registration), this call will be ignored. Only the host process of\nthe transport can change its description, otherwise a {@link\nSecurityException} will be thrown. @param transportComponent The identity of\nthe transport being described. @param name A {@link String} with the new name\nfor the transport. This is NOT for identification. MUST NOT be {@code null}.\n@param configurationIntent An {@link Intent} that can be passed to {@link\nContext#startActivity} in order to launch the transport's configuration UI. It\nmay be {@code null} if the transport does not offer any user-facing\nconfiguration UI. @param currentDestinationString A {@link String} describing\nthe destination to which the transport is currently sending data. MUST NOT be\n{@code null}. @param dataManagementIntent An {@link Intent} that can be passed\nto {@link Context#startActivity} in order to launch the transport's data-\nmanagement UI. It may be {@code null} if the transport does not offer any\nuser-facing data management UI. @param dataManagementLabel A {@link String} to\nbe used as the label for the transport's data management affordance. This MUST\nbe {@code null} when dataManagementIntent is {@code null} and MUST NOT be\n{@code null} when dataManagementIntent is not {@code null}. @throws\nSecurityException If the UID of the calling process differs from the package\nUID of {@code transportComponent} or if the caller does NOT have BACKUP\npermission. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 502
        },
        {
          "method_name": "android.app.backup.BackupManager.selectBackupTransport",
          "documentation": "Specify the current backup transport and get notified when the transport is\nready to be used. This method is async because BackupManager might need to\nbind to the specified transport which is in a separate process. @param\ntransport ComponentName of the service hosting the transport. This is\ndifferent from the transport's name that is returned by {@link\nBackupTransport#name()}. @param listener A listener object to get a callback\non the transport being selected. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 565
        },
        {
          "method_name": "android.app.backup.BackupManager.backupNow",
          "documentation": "Schedule an immediate backup attempt for all pending key/value updates. This\nis primarily intended for transports to use when they detect a suitable\nopportunity for doing a backup pass. If there are no pending updates to be\nsent, no action will be taken. Even if some updates are pending, the transport\nwill still be asked to confirm via the usual requestBackupTime() method. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 591
        },
        {
          "method_name": "android.app.backup.BackupManager.getAvailableRestoreToken",
          "documentation": "Ask the framework which dataset, if any, the given package's data would be\nrestored from if we were to install it right now. @param packageName The name\nof the package whose most-suitable dataset we wish to look up @return The\ndataset token from which a restore should be attempted, or zero if no suitable\ndata is available. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 615
        },
        {
          "method_name": "android.app.backup.BackupManager.isAppEligibleForBackup",
          "documentation": "Ask the framework whether this app is eligible for backup. @param packageName\nThe name of the package. @return Whether this app is eligible for backup.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 637
        },
        {
          "method_name": "android.app.backup.BackupManager.requestBackup",
          "documentation": "Request an immediate backup, providing an observer to which results of the\nbackup operation will be published. The Android backup system will decide for\neach package whether it will be full app data backup or key/value-pair-based\nbackup.\n\nIf this method returns {@link BackupManager#SUCCESS}, the OS will attempt to\nbackup all provided packages using the remote transport. @param packages List\nof package names to backup. @param observer The {@link BackupObserver} to\nreceive callbacks during the backup operation. Could be {@code null}. @param\nmonitor The {@link BackupManagerMonitorWrapper} to receive callbacks of\nimportant events during the backup operation. Could be {@code null}. @param\nflags {@link #FLAG_NON_INCREMENTAL_BACKUP}. @return {@link\nBackupManager#SUCCESS} on success; nonzero on error. @throws\nIllegalArgumentException on null or empty {@code packages} param. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 691
        },
        {
          "method_name": "android.app.backup.BackupManager.cancelBackups",
          "documentation": "Cancel all running backups. After this call returns, no currently running\nbackups will interact with the selected transport. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 718
        },
        {
          "method_name": "android.app.backup.BackupManager.getConfigurationIntent",
          "documentation": "Returns an {@link Intent} for the specified transport's configuration UI. This\nvalue is set by {@link #updateTransportAttributes(ComponentName, String,\nIntent, String, Intent, String)}. @param transportName The name of the\nregistered transport. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 739
        },
        {
          "method_name": "android.app.backup.BackupManager.getDestinationString",
          "documentation": "Returns a {@link String} describing where the specified transport is sending\ndata. This value is set by {@link #updateTransportAttributes(ComponentName,\nString, Intent, String, Intent, String)}. @param transportName The name of the\nregistered transport. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 760
        },
        {
          "method_name": "android.app.backup.BackupManager.getDataManagementIntent",
          "documentation": "Returns an {@link Intent} for the specified transport's data management UI.\nThis value is set by {@link #updateTransportAttributes(ComponentName, String,\nIntent, String, Intent, String)}. @param transportName The name of the\nregistered transport. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 781
        },
        {
          "method_name": "android.app.backup.BackupManager.getDataManagementLabel",
          "documentation": "Returns a {@link String} describing what the specified transport's data\nmanagement intent is used for. This value is set by {@link\n#updateTransportAttributes(ComponentName, String, Intent, String, Intent,\nString)}. @param transportName The name of the registered transport. @hide\n\n",
          "file": "./aosp/core/java/android/app/backup/BackupManager.java",
          "line": 804
        }
      ]
    },
    "android.permission.RECOVER_KEYSTORE": {
      "name": "android.permission.RECOVER_KEYSTORE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getInstance",
          "documentation": "Gets a new instance of the class.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 286
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.isRecoverableKeyStoreEnabled",
          "documentation": "Checks whether the recoverable key store is currently available.\n\nIf it returns true, the device must currently be using a screen lock that is\nsupported for use with the recoverable key store, i.e. AOSP PIN, pattern or\npassword.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 299
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.initRecoveryService",
          "documentation": "Initializes the recovery service for the calling application. The detailed\nsteps should be:\n\n  1. Parse {@code signatureFile} to get relevant information. \n  2. Validate the signer's X509 certificate, contained in {@code signatureFile}, against the root certificate pre-installed in the OS and chosen by {@code rootCertificateAlias}. \n  3. Verify the public-key signature, contained in {@code signatureFile}, and verify it against the entire {@code certificateFile}. \n  4. Parse {@code certificateFile} to get relevant information. \n  5. Check the serial number, contained in {@code certificateFile}, and skip the following steps if the serial number is not larger than the one previously stored. \n  6. Randomly choose a X509 certificate from the endpoint X509 certificates, contained in {@code certificateFile}, and validate it against the root certificate pre-installed in the OS and chosen by {@code rootCertificateAlias}. \n  7. Store the chosen X509 certificate and the serial in local database for later use. \n@param rootCertificateAlias the alias of a root certificate pre-installed in\nthe OS @param certificateFile the binary content of the XML file containing a\nlist of recovery service X509 certificates, and other metadata including the\nserial number @param signatureFile the binary content of the XML file\ncontaining the public-key signature of the entire certificate file, and a\nsigner's X509 certificate @throws CertificateException if the given\ncertificate files cannot be parsed or validated @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 344
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getRecoveryData",
          "documentation": "@deprecated Use {@link #getKeyChainSnapshot()} @removed\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 372
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getKeyChainSnapshot",
          "documentation": "Returns data necessary to store all recoverable keys. Key material is\nencrypted with user secret and recovery public key. @return Data necessary to\nrecover keystore or {@code null} if snapshot is not available. @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 385
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.setSnapshotCreatedPendingIntent",
          "documentation": "Sets a listener which notifies recovery agent that new recovery snapshot is\navailable. {@link #getKeyChainSnapshot} can be used to get the snapshot. Note\nthat every recovery agent can have at most one registered listener at any\ntime. @param intent triggered when new snapshot is available. Unregisters\nlistener if the value is {@code null}. @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 410
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.setServerParams",
          "documentation": "Server parameters used to generate new recovery key blobs. This value will be\nincluded in {@code KeyChainSnapshot.getEncryptedRecoveryKeyBlob()}. The same\nvalue must be included in vaultParams {@link RecoverySession#start(CertPath,\nbyte[], byte[], List)}. @param serverParams included in recovery key blob.\n@see #getKeyChainSnapshot @throws InternalRecoveryServiceException if an\nunexpected error occurred in the recovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 432
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getAliases",
          "documentation": "Returns a list of aliases of keys belonging to the application.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 458
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.setRecoveryStatus",
          "documentation": "Sets the recovery status for given key. It is used to notify the keystore that\nthe key was successfully stored on the server or that there was an error. An\napplication can check this value using {@link #getRecoveryStatus(String,\nString)}. @param alias The alias of the key whose status to set. @param status\nThe status of the key. One of {@link #RECOVERY_STATUS_SYNCED}, {@link\n#RECOVERY_STATUS_SYNC_IN_PROGRESS} or {@link\n#RECOVERY_STATUS_PERMANENT_FAILURE}. @throws InternalRecoveryServiceException\nif an unexpected error occurred in the recovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 493
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getRecoveryStatus",
          "documentation": "Returns the recovery status for the key with the given {@code alias}.\n\n  * {@link #RECOVERY_STATUS_SYNCED} \n  * {@link #RECOVERY_STATUS_SYNC_IN_PROGRESS} \n  * {@link #RECOVERY_STATUS_PERMANENT_FAILURE} \n@see #setRecoveryStatus(String, int) @throws InternalRecoveryServiceException\nif an unexpected error occurred in the recovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 529
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.setRecoverySecretTypes",
          "documentation": "Specifies a set of secret types used for end-to-end keystore encryption.\nKnowing all of them is necessary to recover data. @param secretTypes {@link\nKeyChainProtectionParams#TYPE_LOCKSCREEN} @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 554
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getRecoverySecretTypes",
          "documentation": "Defines a set of secret types used for end-to-end keystore encryption. Knowing\nall of them is necessary to generate KeyChainSnapshot. @return list of\nrecovery secret types @see KeyChainSnapshot @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 576
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.generateAndStoreKey",
          "documentation": "Deprecated. Generates a AES256/GCM/NoPADDING key called {@code alias} and\nloads it into the recoverable key store. Returns the raw material of the key.\n@param alias The key alias. @param account The account associated with the key\n@throws InternalRecoveryServiceException if an unexpected error occurred in\nthe recovery service. @throws LockScreenRequiredException if the user has not\nset a lock screen. This is required to generate recoverable keys, as the\nsnapshots are encrypted using a key derived from the lock screen. @deprecated\nUse {@link #generateKey(String)} @removed\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 604
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.generateKey",
          "documentation": "Generates a recoverable key with the given {@code alias}. @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service. @throws LockScreenRequiredException if the user does not\nhave a lock screen set. A lock screen is required to generate recoverable\nkeys.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 629
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.importKey",
          "documentation": "Imports a 256-bit recoverable AES key with the given {@code alias} and the raw\nbytes {@code keyBytes}. @throws InternalRecoveryServiceException if an\nunexpected error occurred in the recovery service. @throws\nLockScreenRequiredException if the user does not have a lock screen set. A\nlock screen is required to generate recoverable keys.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 660
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getKey",
          "documentation": "Gets a key called {@code alias} from the recoverable key store. @param alias\nThe key alias. @return The key. @throws InternalRecoveryServiceException if an\nunexpected error occurred in the recovery service. @throws\nUnrecoverableKeyException if key is permanently invalidated or not found.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 690
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.removeKey",
          "documentation": "Removes a key called {@code alias} from the recoverable key store. @param\nalias The key alias. @throws InternalRecoveryServiceException if an unexpected\nerror occurred in the recovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 726
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.createRecoverySession",
          "documentation": "Returns a new {@link RecoverySession}.\n\nA recovery session is required to restore keys from a remote store.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 742
        },
        {
          "method_name": "android.security.keystore.recovery.RecoveryController.getRootCertificates",
          "documentation": "",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoveryController.java",
          "line": 747
        },
        {
          "method_name": "android.security.keystore.recovery.RecoverySession.newInstance",
          "documentation": "A new session, started by the {@link RecoveryController}.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoverySession.java",
          "line": 65
        },
        {
          "method_name": "android.security.keystore.recovery.RecoverySession.start",
          "documentation": "Starts a recovery session and returns a blob with proof of recovery secret\npossession. The method generates a symmetric key for a session, which trusted\nremote device can use to return recovery key. @param rootCertificateAlias The\nalias of the root certificate that is already in the Android OS. The root\ncertificate will be used for validating {@code verifierCertPath}. @param\nverifierCertPath The certificate path used to create the recovery blob on the\nsource device. Keystore will verify the certificate path by using the root of\ntrust. @param vaultParams Must match the parameters in the corresponding field\nin the recovery blob. Used to limit number of guesses. @param vaultChallenge\nData passed from server for this recovery session and used to prevent replay\nattacks. @param secrets Secrets provided by user, the method only uses type\nand secret fields. @return The binary blob with recovery claim. It is\nencrypted with verifierPublicKey and contains a proof of user secrets\npossession, session symmetric key and parameters necessary to identify the\ncounter with the number of failed recovery attempts. @throws\nCertificateException if the {@code verifierCertPath} is invalid. @throws\nInternalRecoveryServiceException if an unexpected error occurred in the\nrecovery service.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoverySession.java",
          "line": 132
        },
        {
          "method_name": "android.security.keystore.recovery.RecoverySession.recoverKeys",
          "documentation": "@deprecated Use {@link #recoverKeyChainSnapshot(byte[], List)} instead.\n@removed\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoverySession.java",
          "line": 169
        },
        {
          "method_name": "android.security.keystore.recovery.RecoverySession.recoverKeyChainSnapshot",
          "documentation": "Imports key chain snapshot recovered from a remote vault. @param\nrecoveryKeyBlob Recovery blob encrypted by symmetric key generated for this\nsession. @param applicationKeys Application keys. Key material can be\ndecrypted using recoveryKeyBlob and session key generated by {@link #start}.\n@return {@code Map} from recovered keys aliases to their references. @throws\nSessionExpiredException if {@code session} has since been closed. @throws\nDecryptionFailedException if unable to decrypt the snapshot. @throws\nInternalRecoveryServiceException if an error occurs internal to the recovery\nservice.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoverySession.java",
          "line": 189
        },
        {
          "method_name": "android.security.keystore.recovery.RecoverySession.close",
          "documentation": "Deletes all data associated with {@code session}.\n\n",
          "file": "./aosp/core/java/android/security/keystore/recovery/RecoverySession.java",
          "line": 247
        }
      ]
    },
    "android.permission.CONFIRM_FULL_BACKUP": {
      "name": "android.permission.CONFIRM_FULL_BACKUP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_REMOTEVIEWS": {
      "name": "android.permission.BIND_REMOTEVIEWS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_APPWIDGET": {
      "name": "android.permission.BIND_APPWIDGET",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_SLICE_PERMISSIONS": {
      "name": "android.permission.MANAGE_SLICE_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_KEYGUARD_APPWIDGET": {
      "name": "android.permission.BIND_KEYGUARD_APPWIDGET",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS": {
      "name": "android.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.CHANGE_BACKGROUND_DATA_SETTING": {
      "name": "android.permission.CHANGE_BACKGROUND_DATA_SETTING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.GLOBAL_SEARCH": {
      "name": "android.permission.GLOBAL_SEARCH",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.GLOBAL_SEARCH_CONTROL": {
      "name": "android.permission.GLOBAL_SEARCH_CONTROL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_SEARCH_INDEXABLES": {
      "name": "android.permission.READ_SEARCH_INDEXABLES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_SETTINGS_SUGGESTIONS_SERVICE": {
      "name": "android.permission.BIND_SETTINGS_SUGGESTIONS_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_WALLPAPER_COMPONENT": {
      "name": "android.permission.SET_WALLPAPER_COMPONENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.WallpaperManager.setWallpaperComponent",
          "documentation": "Set the live wallpaper. This can only be called by packages with\nandroid.permission.SET_WALLPAPER_COMPONENT permission. The caller must hold\nthe INTERACT_ACROSS_USERS_FULL permission to change another user's wallpaper.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/WallpaperManager.java",
          "line": 1671
        }
      ]
    },
    "android.permission.READ_DREAM_STATE": {
      "name": "android.permission.READ_DREAM_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.WRITE_DREAM_STATE": {
      "name": "android.permission.WRITE_DREAM_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_CACHE_FILESYSTEM": {
      "name": "android.permission.ACCESS_CACHE_FILESYSTEM",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.COPY_PROTECTED_DATA": {
      "name": "android.permission.COPY_PROTECTED_DATA",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CRYPT_KEEPER": {
      "name": "android.permission.CRYPT_KEEPER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.READ_NETWORK_USAGE_HISTORY": {
      "name": "android.permission.READ_NETWORK_USAGE_HISTORY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_NETWORK_POLICY": {
      "name": "android.permission.MANAGE_NETWORK_POLICY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MODIFY_NETWORK_ACCOUNTING": {
      "name": "android.permission.MODIFY_NETWORK_ACCOUNTING",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_SUBSCRIPTION_PLANS": {
      "name": "android.permission.MANAGE_SUBSCRIPTION_PLANS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.intent.category.MASTER_CLEAR.permission.C2D_MESSAGE": {
      "name": "android.intent.category.MASTER_CLEAR.permission.C2D_MESSAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.PACKAGE_VERIFICATION_AGENT": {
      "name": "android.permission.PACKAGE_VERIFICATION_AGENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_PACKAGE_VERIFIER": {
      "name": "android.permission.BIND_PACKAGE_VERIFIER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SET_HARMFUL_APP_WARNINGS": {
      "name": "android.permission.SET_HARMFUL_APP_WARNINGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|verifier",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.setHarmfulAppWarning",
          "documentation": "Sets or clears the harmful app warning details for the given app. When set,\nany attempt to launch an activity in this package will be intercepted and a\nwarning dialog will be shown to the user instead, with the given warning. The\nuser will have the option to proceed with the activity launch, or to uninstall\nthe application. @param packageName The full name of the package to warn on.\n@param warning A warning string to display to the user describing the threat\nposed by the application, or null to clear the warning. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 6210
        },
        {
          "method_name": "android.content.pm.PackageManager.getHarmfulAppWarning",
          "documentation": "Returns the harmful app warning string for the given app, or null if there is\nnone set. @param packageName The full name of the desired package. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 6224
        }
      ]
    },
    "android.permission.INTENT_FILTER_VERIFICATION_AGENT": {
      "name": "android.permission.INTENT_FILTER_VERIFICATION_AGENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.verifyIntentFilter",
          "documentation": "Allows a package listening to the {@link\nIntent#ACTION_INTENT_FILTER_NEEDS_VERIFICATION} intent filter verification\nbroadcast to respond to the package manager. The response must include the\n{@code verificationCode} which is one of {@link\nPackageManager#INTENT_FILTER_VERIFICATION_SUCCESS} or {@link\nPackageManager#INTENT_FILTER_VERIFICATION_FAILURE}. @param verificationId\npending package identifier as passed via the {@link\nPackageManager#EXTRA_VERIFICATION_ID} Intent extra. @param verificationCode\neither {@link PackageManager#INTENT_FILTER_VERIFICATION_SUCCESS} or {@link\nPackageManager#INTENT_FILTER_VERIFICATION_FAILURE}. @param failedDomains a\nlist of failed domains if the verificationCode is {@link\nPackageManager#INTENT_FILTER_VERIFICATION_FAILURE}, otherwise null; @throws\nSecurityException if the caller does not have the\nINTENT_FILTER_VERIFICATION_AGENT permission. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 5018
        }
      ]
    },
    "android.permission.BIND_INTENT_FILTER_VERIFIER": {
      "name": "android.permission.BIND_INTENT_FILTER_VERIFIER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.SERIAL_PORT": {
      "name": "android.permission.SERIAL_PORT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY": {
      "name": "android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.UPDATE_LOCK": {
      "name": "android.permission.UPDATE_LOCK",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_NOTIFICATIONS": {
      "name": "android.permission.ACCESS_NOTIFICATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged|appop"
    },
    "android.permission.ACCESS_NOTIFICATION_POLICY": {
      "name": "android.permission.ACCESS_NOTIFICATION_POLICY",
      "label": "acc\u00e9der au mode Ne pas d\u00e9ranger",
      "label_ptr": "permlab_access_notification_policy",
      "description": "Permet \u00e0 l'application de consulter et de modifier la configuration du mode Ne pas d\u00e9ranger.",
      "description_ptr": "permdesc_access_notification_policy",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.MANAGE_NOTIFICATIONS": {
      "name": "android.permission.MANAGE_NOTIFICATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.USE_COLORIZED_NOTIFICATIONS": {
      "name": "android.permission.USE_COLORIZED_NOTIFICATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|setup"
    },
    "android.permission.ACCESS_KEYGUARD_SECURE_STORAGE": {
      "name": "android.permission.ACCESS_KEYGUARD_SECURE_STORAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.app.trust.TrustManager.setDeviceLockedForUser",
          "documentation": "Changes the lock status for the given user. This is only applicable to Managed\nProfiles, other users should be handled by Keyguard. @param userId The id for\nthe user to be locked/unlocked. @param locked The value for that user's locked\nstate.\n\n",
          "file": "./aosp/core/java/android/app/trust/TrustManager.java",
          "line": 62
        },
        {
          "method_name": "android.app.trust.TrustManager.unlockedByFingerprintForUser",
          "documentation": "Updates the trust state for the user due to the user unlocking via\nfingerprint. Should only be called if user authenticated via fingerprint and\nbouncer can be skipped. @param userId\n\n",
          "file": "./aosp/core/java/android/app/trust/TrustManager.java",
          "line": 205
        },
        {
          "method_name": "android.app.trust.TrustManager.clearAllFingerprints",
          "documentation": "Clears authenticated fingerprints for all users.\n\n",
          "file": "./aosp/core/java/android/app/trust/TrustManager.java",
          "line": 217
        }
      ]
    },
    "android.permission.MANAGE_FINGERPRINT": {
      "name": "android.permission.MANAGE_FINGERPRINT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.enroll",
          "documentation": "Request fingerprint enrollment. This call warms up the fingerprint hardware\nand starts scanning for fingerprints. Progress will be indicated by callbacks\nto the {@link EnrollmentCallback} object. It terminates when {@link\nEnrollmentCallback#onEnrollmentError(int, CharSequence)} or {@link\nEnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, at\nwhich point the object is no longer valid. The operation can be canceled by\nusing the provided cancel object. @param token a unique token provided by a\nrecent creation or verification of device credentials (e.g. pin, pattern or\npassword). @param cancel an object that can be used to cancel enrollment\n@param flags optional flags @param userId the user to whom this fingerprint\nwill belong to @param callback an object to receive enrollment events @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 569
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.preEnroll",
          "documentation": "Requests a pre-enrollment auth token to tie enrollment to the confirmation of\nexisting device credentials (e.g. pin/pattern/password). @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 608
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.postEnroll",
          "documentation": "Finishes enrollment and cancels the current auth token. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 623
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.setActiveUser",
          "documentation": "Sets the active user. This is meant to be used to select the current profile\nfor enrollment to allow separate enrolled fingers for a work profile @param\nuserId @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 640
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.remove",
          "documentation": "Remove given fingerprint template from fingerprint hardware and/or protected\nstorage. @param fp the fingerprint item to remove @param userId the user who\nthis fingerprint belongs to @param callback an optional callback to verify\nthat fingerprint templates have been successfully removed. May be null of no\ncallback is required. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 658
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.enumerate",
          "documentation": "Enumerate all fingerprint templates stored in hardware and/or protected\nstorage. @param userId the user who this fingerprint belongs to @param\ncallback an optional callback to verify that fingerprint templates have been\nsuccessfully removed. May be null of no callback is required. @hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 681
        },
        {
          "method_name": "android.hardware.fingerprint.FingerprintManager.rename",
          "documentation": "Renames the given fingerprint template @param fpId the fingerprint id @param\nuserId the user who this fingerprint belongs to @param newName the new name\n@hide\n\n",
          "file": "./aosp/core/java/android/hardware/fingerprint/FingerprintManager.java",
          "line": 703
        }
      ]
    },
    "android.permission.RESET_FINGERPRINT_LOCKOUT": {
      "name": "android.permission.RESET_FINGERPRINT_LOCKOUT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CONTROL_KEYGUARD": {
      "name": "android.permission.CONTROL_KEYGUARD",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.TRUST_LISTENER": {
      "name": "android.permission.TRUST_LISTENER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.app.trust.TrustManager.isTrustUsuallyManaged",
          "documentation": "@return whether {@param userId} has enabled and configured trust agents.\nIgnores short-term unavailability of trust due to {@link\nLockPatternUtils.StrongAuthTracker}.\n\n",
          "file": "./aosp/core/java/android/app/trust/TrustManager.java",
          "line": 191
        }
      ]
    },
    "android.permission.PROVIDE_TRUST_AGENT": {
      "name": "android.permission.PROVIDE_TRUST_AGENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.SHOW_KEYGUARD_MESSAGE": {
      "name": "android.permission.SHOW_KEYGUARD_MESSAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.KeyguardManager.requestDismissKeyguard",
          "documentation": "If the device is currently locked (see {@link #isKeyguardLocked()}, requests\nthe Keyguard to be dismissed.\n\nIf the Keyguard is not secure or the device is currently in a trusted state,\ncalling this method will immediately dismiss the Keyguard without any user\ninteraction.\n\nIf the Keyguard is secure and the device is not in a trusted state, this will\nbring up the UI so the user can enter their credentials.\n\nIf the value set for the {@link Activity} attr {@link\nandroid.R.attr#turnScreenOn} is true, the screen will turn on when the\nkeyguard is dismissed. @param activity The activity requesting the dismissal.\nThe activity must be either visible by using {@link\nLayoutParams#FLAG_SHOW_WHEN_LOCKED} or must be in a state in which it would be\nvisible if Keyguard would not be hiding it. If that's not the case, the\nrequest will fail immediately and {@link\nKeyguardDismissCallback#onDismissError} will be invoked. @param message A\nmessage that will be shown in the keyguard explaining why the user would want\nto dismiss it. @param callback The callback to be called if the request to\ndismiss Keyguard was successful or {@code null} if the caller isn't interested\nin knowing the result. The callback will not be invoked if the activity was\ndestroyed before the callback was received. @hide\n\n",
          "file": "./aosp/core/java/android/app/KeyguardManager.java",
          "line": 517
        }
      ]
    },
    "android.permission.LAUNCH_TRUST_AGENT_SETTINGS": {
      "name": "android.permission.LAUNCH_TRUST_AGENT_SETTINGS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_TRUST_AGENT": {
      "name": "android.permission.BIND_TRUST_AGENT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_NOTIFICATION_LISTENER_SERVICE": {
      "name": "android.permission.BIND_NOTIFICATION_LISTENER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_NOTIFICATION_ASSISTANT_SERVICE": {
      "name": "android.permission.BIND_NOTIFICATION_ASSISTANT_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_CHOOSER_TARGET_SERVICE": {
      "name": "android.permission.BIND_CHOOSER_TARGET_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.PROVIDE_RESOLVER_RANKER_SERVICE": {
      "name": "android.permission.PROVIDE_RESOLVER_RANKER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_RESOLVER_RANKER_SERVICE": {
      "name": "android.permission.BIND_RESOLVER_RANKER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_CONDITION_PROVIDER_SERVICE": {
      "name": "android.permission.BIND_CONDITION_PROVIDER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_DREAM_SERVICE": {
      "name": "android.permission.BIND_DREAM_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_CACHE_QUOTA_SERVICE": {
      "name": "android.permission.BIND_CACHE_QUOTA_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.INVOKE_CARRIER_SETUP": {
      "name": "android.permission.INVOKE_CARRIER_SETUP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_NETWORK_CONDITIONS": {
      "name": "android.permission.ACCESS_NETWORK_CONDITIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_DRM_CERTIFICATES": {
      "name": "android.permission.ACCESS_DRM_CERTIFICATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_MEDIA_PROJECTION": {
      "name": "android.permission.MANAGE_MEDIA_PROJECTION",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.READ_INSTALL_SESSIONS": {
      "name": "android.permission.READ_INSTALL_SESSIONS",
      "label": "acc\u00e9der aux sessions d'installation",
      "label_ptr": "permlab_readInstallSessions",
      "description": "Permet \u00e0 une application d'acc\u00e9der aux sessions d'installation. Cela lui permet de consulter les d\u00e9tails relatifs \u00e0 l'installation des packages actifs.",
      "description_ptr": "permdesc_readInstallSessions",
      "permission_group": "",
      "protection_level": "normal"
    },
    "android.permission.REMOVE_DRM_CERTIFICATES": {
      "name": "android.permission.REMOVE_DRM_CERTIFICATES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.BIND_CARRIER_MESSAGING_SERVICE": {
      "name": "android.permission.BIND_CARRIER_MESSAGING_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_VOICE_INTERACTION_SERVICE": {
      "name": "android.permission.ACCESS_VOICE_INTERACTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_CARRIER_SERVICES": {
      "name": "android.permission.BIND_CARRIER_SERVICES",
      "label": "associer aux services de l'op\u00e9rateur",
      "label_ptr": "permlab_bindCarrierServices",
      "description": "Permet \u00e0 l'application autoris\u00e9e de s'associer aux services d'un op\u00e9rateur. Ne devrait pas \u00eatre n\u00e9cessaire pour les applications standards.",
      "description_ptr": "permdesc_bindCarrierServices",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT": {
      "name": "android.permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.KILL_UID": {
      "name": "android.permission.KILL_UID",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.killUid",
          "documentation": "Kills the specified UID. @param uid The UID to kill. @param reason The reason\nfor the kill. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 3696
        }
      ]
    },
    "android.permission.LOCAL_MAC_ADDRESS": {
      "name": "android.permission.LOCAL_MAC_ADDRESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.net.ConnectivityManager.getCaptivePortalServerUrl",
          "documentation": "Gets a URL that can be used for resolving whether a captive portal is present.\n1. This URL should respond with a 204 response to a GET request to indicate no\ncaptive portal is present. 2. This URL must be HTTP as redirect responses are\nused to find captive portal sign-in pages. Captive portals cannot respond to\nHTTPS requests with redirects. The system network validation may be using\ndifferent strategies to detect captive portals, so this method does not\nnecessarily return a URL used by the system. It only returns a URL that may be\nrelevant for other components trying to detect captive portals. @hide\n\n",
          "file": "./aosp/core/java/android/net/ConnectivityManager.java",
          "line": 1364
        }
      ]
    },
    "android.permission.PEERS_MAC_ADDRESS": {
      "name": "android.permission.PEERS_MAC_ADDRESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|setup"
    },
    "android.permission.DISPATCH_NFC_MESSAGE": {
      "name": "android.permission.DISPATCH_NFC_MESSAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MODIFY_DAY_NIGHT_MODE": {
      "name": "android.permission.MODIFY_DAY_NIGHT_MODE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.ACCESS_INSTANT_APPS": {
      "name": "android.permission.ACCESS_INSTANT_APPS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|installer|verifier",
      "methods": [
        {
          "method_name": "android.content.pm.PackageManager.getInstantApps",
          "documentation": "Gets the instant applications the user recently used. @return The instant app\nlist. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3887
        },
        {
          "method_name": "android.content.pm.PackageManager.getInstantAppIcon",
          "documentation": "Gets the icon for an instant application. @param packageName The app package\nname. @hide\n\n",
          "file": "./aosp/core/java/android/content/pm/PackageManager.java",
          "line": 3898
        }
      ]
    },
    "android.permission.VIEW_INSTANT_APPS": {
      "name": "android.permission.VIEW_INSTANT_APPS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|preinstalled"
    },
    "android.permission.MANAGE_BIND_INSTANT_SERVICE": {
      "name": "android.permission.MANAGE_BIND_INSTANT_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "com.android.server.InputMethodManagerService.handleSetBindInstantServiceAllowed",
          "documentation": "Handles {@code adb shell cmd input_method set-bind-instant-service-allowed}.\n@param shellCommand {@link ShellCommand} object that is handling this command.\n@return Exit code of the command.\n\n",
          "file": "./aosp/services/core/java/com/android/server/InputMethodManagerService.java",
          "line": 4850
        }
      ]
    },
    "android.permission.RECEIVE_MEDIA_RESOURCE_USAGE": {
      "name": "android.permission.RECEIVE_MEDIA_RESOURCE_USAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_SOUND_TRIGGER": {
      "name": "android.permission.MANAGE_SOUND_TRIGGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.media.soundtrigger.SoundTriggerDetector.startRecognition",
          "documentation": "Starts recognition on the associated sound model. Result is indicated via the\n{@link Callback}. @return Indicates whether the call succeeded or not.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerDetector.java",
          "line": 261
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerDetector.stopRecognition",
          "documentation": "Stops recognition for the associated model.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerDetector.java",
          "line": 285
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.updateModel",
          "documentation": "Updates the given sound trigger model.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 84
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.getModel",
          "documentation": "Returns the sound trigger model represented by the given UUID. An instance of\n{@link Model} is returned.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 97
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.deleteModel",
          "documentation": "Deletes the sound model represented by the provided UUID.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 110
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.createSoundTriggerDetector",
          "documentation": "Creates an instance of {@link SoundTriggerDetector} which can be used to\nstart/stop recognition on the model and register for triggers from the model.\nNote that this call invalidates any previously returned instances for the same\nsound model Uuid. @param soundModelId UUID of the sound model to create the\nreceiver object for. @param callback Instance of the {@link\nSoundTriggerDetector#Callback} object for the callbacks for the given sound\nmodel. @param handler The Handler to use for the callback operations. A null\nvalue will use the current thread's Looper. @return Instance of {@link\nSoundTriggerDetector} or null on error.\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 132
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.loadSoundModel",
          "documentation": "Loads a given sound model into the sound trigger. Note the model will be\nunloaded if there is an error/the system service is restarted. @hide\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 244
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.startRecognition",
          "documentation": "Starts recognition for the given model id. All events from the model will be\nsent to the service.\n\nThis only supports generic sound trigger events. For keyphrase events, please\nuse {@link android.service.voice.VoiceInteractionService}. @param soundModelId\nId of the sound model @param params Opaque data sent to each service call of\nthe service as the {@code params} argument @param detectionService The\ncomponent name of the service that should receive the events. Needs to\nsubclass {@link SoundTriggerDetectionService} @param config Configures the\nrecognition @return {@link SoundTrigger#STATUS_OK} if the recognition could be\nstarted, error code otherwise @hide\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 307
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.stopRecognition",
          "documentation": "Stops the given model's recognition. @hide\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 327
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.unloadSoundModel",
          "documentation": "Removes the given model from memory. Will also stop any pending recognitions.\n@hide\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 344
        },
        {
          "method_name": "android.media.soundtrigger.SoundTriggerManager.isRecognitionActive",
          "documentation": "Returns true if the given model has had detection started on it. @hide\n\n",
          "file": "./aosp/media/java/android/media/soundtrigger/SoundTriggerManager.java",
          "line": 362
        }
      ]
    },
    "android.permission.BIND_SOUND_TRIGGER_DETECTION_SERVICE": {
      "name": "android.permission.BIND_SOUND_TRIGGER_DETECTION_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DISPATCH_PROVISIONING_MESSAGE": {
      "name": "android.permission.DISPATCH_PROVISIONING_MESSAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.READ_BLOCKED_NUMBERS": {
      "name": "android.permission.READ_BLOCKED_NUMBERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.WRITE_BLOCKED_NUMBERS": {
      "name": "android.permission.WRITE_BLOCKED_NUMBERS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.BIND_VR_LISTENER_SERVICE": {
      "name": "android.permission.BIND_VR_LISTENER_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.RESTRICTED_VR_ACCESS": {
      "name": "android.permission.RESTRICTED_VR_ACCESS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|preinstalled",
      "methods": [
        {
          "method_name": "android.app.ActivityManager.setPersistentVrThread",
          "documentation": "Enable more aggressive scheduling for latency-sensitive low-runtime VR threads\nthat persist beyond a single process. Only one thread can be a persistent VR\nthread at a time, and that thread may be subject to restrictions on the amount\nof time it can run. Calling this method will disable aggressive scheduling for\nnon-persistent VR threads set via {@link #setVrThread}. If persistent VR mode\nis disabled then the persistent VR thread loses its new scheduling priority;\nthis method must be called again to set the persistent thread. To reset the\npersistent VR thread, a tid of 0 can be passed. @see\nandroid.os.Process#myTid() @param tid tid of the VR thread @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityManager.java",
          "line": 4351
        },
        {
          "method_name": "android.app.VrManager.registerVrStateCallback",
          "documentation": "Registers a callback to be notified of changes to the VR Mode state. @param\ncallback The callback to register. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 73
        },
        {
          "method_name": "android.app.VrManager.unregisterVrStateCallback",
          "documentation": "Deregisters VR State callbacks. @param callback The callback to deregister.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 103
        },
        {
          "method_name": "android.app.VrManager.getVrModeEnabled",
          "documentation": "Returns the current VrMode state. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 128
        },
        {
          "method_name": "android.app.VrManager.getPersistentVrModeEnabled",
          "documentation": "Returns the current VrMode state. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 146
        },
        {
          "method_name": "android.app.VrManager.setPersistentVrModeEnabled",
          "documentation": "Sets the persistent VR mode state of a device. When a device is in persistent\nVR mode it will remain in VR mode even if the foreground does not specify Vr\nmode being enabled. Mainly used by VR viewers to indicate that a device is\nplaced in a VR viewer. @see Activity#setVrModeEnabled(boolean, ComponentName)\n@param enabled true if the device should be placed in persistent VR mode.\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 164
        },
        {
          "method_name": "android.app.VrManager.setVr2dDisplayProperties",
          "documentation": "Sets the resolution and DPI of the vr2d virtual display used to display 2D\napplications in VR mode. @param vr2dDisplayProp properties to be set to the\nvirtual display for 2D applications in VR mode. {@hide}\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 183
        },
        {
          "method_name": "android.app.VrManager.setAndBindVrCompositor",
          "documentation": "Set the component name of the compositor service to bind. @param componentName\nComponentName of a Service in the application's compositor process to bind to,\nor null to clear the current binding.\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 199
        },
        {
          "method_name": "android.app.VrManager.setVrInputMethod",
          "documentation": "Start VR Input method for the packageName in {@link ComponentName}. This\nmethod notifies InputMethodManagerService to use VR IME instead of regular\nphone IME. @param componentName ComponentName of a VR InputMethod that should\nbe set as selected input by InputMethodManagerService. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 233
        },
        {
          "method_name": "android.view.WindowManager.getCurrentImeTouchRegion",
          "documentation": "Return the touch region for the current IME window, or an empty region if\nthere is none. @return The region of the IME that is accepting touch inputs,\nor null if there is no IME, no region or there was an error. @hide\n\n",
          "file": "./aosp/core/java/android/view/WindowManager.java",
          "line": 423
        },
        {
          "method_name": "android.view.inputmethod.InputMethodManager.getVrInputMethodList",
          "documentation": "Returns a list of VR InputMethod currently installed. @hide\n\n",
          "file": "./aosp/core/java/android/view/inputmethod/InputMethodManager.java",
          "line": 742
        }
      ]
    },
    "android.permission.ACCESS_VR_MANAGER": {
      "name": "android.permission.ACCESS_VR_MANAGER",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.app.VrManager.setStandbyEnabled",
          "documentation": "Sets the current standby status of the VR device. Standby mode is only used on\nstandalone vr devices. Standby mode is a deep sleep state where it's\nappropriate to turn off vr mode. @param standby True if the device is entering\nstandby, false if it's exiting standby. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 216
        }
      ]
    },
    "android.permission.ACCESS_VR_STATE": {
      "name": "android.permission.ACCESS_VR_STATE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|preinstalled",
      "methods": [
        {
          "method_name": "android.app.VrManager.registerVrStateCallback",
          "documentation": "Registers a callback to be notified of changes to the VR Mode state. @param\ncallback The callback to register. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 73
        },
        {
          "method_name": "android.app.VrManager.unregisterVrStateCallback",
          "documentation": "Deregisters VR State callbacks. @param callback The callback to deregister.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 103
        },
        {
          "method_name": "android.app.VrManager.getVrModeEnabled",
          "documentation": "Returns the current VrMode state. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 128
        },
        {
          "method_name": "android.app.VrManager.getPersistentVrModeEnabled",
          "documentation": "Returns the current VrMode state. @hide\n\n",
          "file": "./aosp/core/java/android/app/VrManager.java",
          "line": 146
        }
      ]
    },
    "android.permission.UPDATE_LOCK_TASK_PACKAGES": {
      "name": "android.permission.UPDATE_LOCK_TASK_PACKAGES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|setup"
    },
    "android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME": {
      "name": "android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.NOTIFICATION_DURING_SETUP": {
      "name": "android.permission.NOTIFICATION_DURING_SETUP",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_AUTO_FILL": {
      "name": "android.permission.MANAGE_AUTO_FILL",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MODIFY_THEME_OVERLAY": {
      "name": "android.permission.MODIFY_THEME_OVERLAY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.INSTANT_APP_FOREGROUND_SERVICE": {
      "name": "android.permission.INSTANT_APP_FOREGROUND_SERVICE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|development|instant|appop"
    },
    "android.permission.FOREGROUND_SERVICE": {
      "name": "android.permission.FOREGROUND_SERVICE",
      "label": "",
      "label_ptr": "permlab_foregroundService",
      "description": "",
      "description_ptr": "permdesc_foregroundService",
      "permission_group": "",
      "protection_level": "normal|instant"
    },
    "android.permission.ACCESS_SHORTCUTS": {
      "name": "android.permission.ACCESS_SHORTCUTS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|textClassifier"
    },
    "android.permission.UNLIMITED_SHORTCUTS_API_CALLS": {
      "name": "android.permission.UNLIMITED_SHORTCUTS_API_CALLS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|textClassifier"
    },
    "android.permission.READ_RUNTIME_PROFILES": {
      "name": "android.permission.READ_RUNTIME_PROFILES",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.content.pm.dex.ArtManager.snapshotRuntimeProfile",
          "documentation": "Snapshots a runtime profile according to the {@code profileType} parameter. If\n{@code profileType} is {@link ArtManager#PROFILE_APPS} the method will\nsnapshot the profile for for an apk belonging to the package {@code\npackageName}. The apk is identified by {@code codePath}. If {@code\nprofileType} is {@code ArtManager.PROFILE_BOOT_IMAGE} the method will snapshot\nthe profile for the boot image. In this case {@code codePath can be null}. The\nparameters {@code packageName} and {@code codePath} are ignored. u The calling\nprocess must have {@code android.permission.READ_RUNTIME_PROFILE} permission.\nThe result will be posted on the {@code executor} using the given {@code\ncallback}. The profile will be available as a read-only {@link\nandroid.os.ParcelFileDescriptor}. This method will throw {@link\nIllegalStateException} if {@link ArtManager#isRuntimeProfilingEnabled(int)}\ndoes not return true for the given {@code profileType}. @param profileType the\ntype of profile that should be snapshot (boot image or app) @param packageName\nthe target package name or null if the target is the boot image @param\ncodePath the code path for which the profile should be retrieved or null if\nthe target is the boot image @param callback the callback which should be used\nfor the result @param executor the executor which should be used to post the\nresult\n\n",
          "file": "./aosp/core/java/android/content/pm/dex/ArtManager.java",
          "line": 108
        },
        {
          "method_name": "android.content.pm.dex.ArtManager.isRuntimeProfilingEnabled",
          "documentation": "Returns true if runtime profiles are enabled for the given type, false\notherwise. The calling process must have {@code\nandroid.permission.READ_RUNTIME_PROFILE} permission. @param profileType can be\neither {@link ArtManager#PROFILE_APPS} or {@link\nArtManager#PROFILE_BOOT_IMAGE}\n\n",
          "file": "./aosp/core/java/android/content/pm/dex/ArtManager.java",
          "line": 132
        }
      ]
    },
    "android.permission.MANAGE_AUDIO_POLICY": {
      "name": "android.permission.MANAGE_AUDIO_POLICY",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MODIFY_QUIET_MODE": {
      "name": "android.permission.MODIFY_QUIET_MODE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged"
    },
    "android.permission.MANAGE_CAMERA": {
      "name": "android.permission.MANAGE_CAMERA",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS": {
      "name": "android.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature|privileged",
      "methods": [
        {
          "method_name": "android.app.Activity.registerRemoteAnimations",
          "documentation": "Registers remote animations per transition type for this activity. @param\ndefinition The remote animation definition that defines which transition\nwhould run which remote animation. @hide\n\n",
          "file": "./aosp/core/java/android/app/Activity.java",
          "line": 7909
        },
        {
          "method_name": "android.app.ActivityOptions.makeRemoteAnimation",
          "documentation": "Create an {@link ActivityOptions} instance that lets the application control\nthe entire animation using a {@link RemoteAnimationAdapter}. @hide\n\n",
          "file": "./aosp/core/java/android/app/ActivityOptions.java",
          "line": 854
        }
      ]
    },
    "android.permission.WATCH_APPOPS": {
      "name": "android.permission.WATCH_APPOPS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature",
      "methods": [
        {
          "method_name": "android.app.AppOpsManager.startWatchingMode",
          "documentation": "Monitor for changes to the operating mode for the given op in the given app\npackage.\n\nIf you don't hold the {@link android.Manifest.permission#WATCH_APPOPS}\npermission you can watch changes only for your UID. @param op The operation to\nmonitor, one of OP_*. @param packageName The name of the application to\nmonitor. @param flags Option flags: any combination of {@link\n#WATCH_FOREGROUND_CHANGES} or 0. @param callback Where to report changes.\n@hide\n\n",
          "file": "./aosp/core/java/android/app/AppOpsManager.java",
          "line": 2077
        }
      ]
    },
    "android.permission.OPEN_APPLICATION_DETAILS_OPEN_BY_DEFAULT_PAGE": {
      "name": "android.permission.OPEN_APPLICATION_DETAILS_OPEN_BY_DEFAULT_PAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.DISABLE_HIDDEN_API_CHECKS": {
      "name": "android.permission.DISABLE_HIDDEN_API_CHECKS",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    },
    "android.permission.MONITOR_DEFAULT_SMS_PACKAGE": {
      "name": "android.permission.MONITOR_DEFAULT_SMS_PACKAGE",
      "label": "",
      "label_ptr": "",
      "description": "",
      "description_ptr": "",
      "permission_group": "",
      "protection_level": "signature"
    }
  }
}